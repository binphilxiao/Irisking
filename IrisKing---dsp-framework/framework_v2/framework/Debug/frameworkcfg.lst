TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    1

       1                    ;;   Do *not* directly modify this file.  It was   
       2                    ;;   generated by the Configuration Tool; any 
       3                    ;;   changes risk being overwritten.               
       4                    
       5                    ;; INPUT framework.cdb
       6                    
       7                    ;; CONFIGURATION/VERSION INFORMATION
       8                            .asg "Tue Jul 29 10:47:51 2008", VERS$DATE
       9                    
      10                    ;; PROLOGUE
      11                            .include frameworkcfg.h62
      12                            .copy confbeg.s62
 B     1                    ;
 B     2                    ;  Copyright 2003 by Texas Instruments Incorporated.
 B     3                    ;  All rights reserved. Property of Texas Instruments Incorporated.
 B     4                    ;  Restricted rights to use, duplicate or disclose this code are
 B     5                    ;  granted through contract.
 B     6                    ;  
 B     7                    ;
 B     8                    ; "@(#) DSP/BIOS 4.90.270 01-13-05 (barracuda-o07)"
 B     9                    ;
 B    10                    ;  ======== confbeg.s62 ========
 B    11                    ;  The statements in this file are inserted at the beginning of 
 B    12                    ;  every BIOS configuration file.
 B    13                    ;
 B    14                    
 B    15                    
      13                    
      14                    ;; TYPE HEADERS
      15                            .include gbl.h62
      16                            .include mem.h62
      17                            .include obj.h62
      18                            .include buf.h62
      19                            .include clk.h62
      20                            .include prd.h62
      21                            .include rtdx.h62
      22                            .include hst.h62
      23                            .include hwi.h62
      24                            .include swi.h62
      25                            .include tsk.h62
      26                            .include idl.h62
      27                            .include isrc.h62
      28                            .include log.h62
      29                            .include pip.h62
 +   636                    
      30                            .include sem.h62
      31                            .include mbx.h62
      32                            .include que.h62
      33                            .include lck.h62
      34                            .include sio.h62
      35                            .include sts.h62
      36                            .include sys.h62
 +   117                        
      37                            .include gio.h62
 +   132                        
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    2

      38                            .include dev.h62
      39                            .include udev.h62
      40                            .include dgn.h62
 +   215                    
      41                            .include dhl.h62
 +   197                    
      42                            .include dpi.h62
      43                            .include hook.h62
 +   225                    
      44                            .include dio.h62
      45                    
      46                    ;; TYPE ATTRIBUTES
      47          00000002  MEM$NUMOF           .set 2
      48          00000000  MEM$SETOF           .set 00H
      49          00000000  OBJ$NUMOF           .set 0
      50          00000000  OBJ$SETOF           .set 00H
      51          00000002  BUF$NUMOF           .set 2
      52          00000000  BUF$SETOF           .set 00H
      53          00000001  CLK$NUMOF           .set 1
      54          00000000  CLK$SETOF           .set 00H
      55          00000000  PRD$NUMOF           .set 0
      56          00000000  PRD$SETOF           .set 00H
      57          00000000  RTDX$NUMOF          .set 0
      58          00000000  RTDX$SETOF          .set 00H
      59          00000002  HST$NUMOF           .set 2
      60          00000003  HST$SETOF           .set 03H
      61          00000010  HWI$NUMOF           .set 16
      62          0000FFFF  HWI$SETOF           .set 0ffffH
      63          00000001  SWI$NUMOF           .set 1
      64          00000000  SWI$SETOF           .set 00H
      65          00000002  TSK$NUMOF           .set 2
      66          00000000  TSK$SETOF           .set 00H
      67          00000003  IDL$NUMOF           .set 3
      68          00000000  IDL$SETOF           .set 00H
      69          00000000  ISRC$NUMOF          .set 0
      70          00000000  ISRC$SETOF          .set 00H
      71          00000002  LOG$NUMOF           .set 2
      72          00000000  LOG$SETOF           .set 00H
      73          00000000  PIP$NUMOF           .set 0
      74          00000000  PIP$SETOF           .set 00H
      75          00000000  SEM$NUMOF           .set 0
      76          00000000  SEM$SETOF           .set 00H
      77          00000000  MBX$NUMOF           .set 0
      78          00000000  MBX$SETOF           .set 00H
      79          00000000  QUE$NUMOF           .set 0
      80          00000000  QUE$SETOF           .set 00H
      81          00000000  LCK$NUMOF           .set 0
      82          00000000  LCK$SETOF           .set 00H
      83          00000000  SIO$NUMOF           .set 0
      84          00000000  SIO$SETOF           .set 00H
      85          00000006  STS$NUMOF           .set 6
      86          00000000  STS$SETOF           .set 00H
      87          00000000  DEV$NUMOF           .set 0
      88          00000000  DEV$SETOF           .set 00H
      89          00000003  UDEV$NUMOF          .set 3
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    3

      90          00000000  UDEV$SETOF          .set 00H
      91          00000000  DGN$NUMOF           .set 0
      92          00000000  DGN$SETOF           .set 00H
      93          00000000  DHL$NUMOF           .set 0
      94          00000000  DHL$SETOF           .set 00H
      95          00000000  DPI$NUMOF           .set 0
      96          00000000  DPI$SETOF           .set 00H
      97          00000000  HOOK$NUMOF          .set 0
      98          00000000  HOOK$SETOF          .set 00H
      99          00000000  DIO$NUMOF           .set 0
     100          00000000  DIO$SETOF           .set 00H
     101                    
     102                    ;; module GBL (ROM, BIGENDIAN, USERINIT, USERINITFXN, ENABLEINST, CACHE, L2CONFIGURE, L2MODE, L2PRIORI
     103                            .global GBL$                     ; == 1
     104                            .global GBL_ROM                  ; frameworkcfg.h62
     105                            .global GBL_BIGENDIAN            ; frameworkcfg.h62
     106                            .global GBL_USERINIT             ; frameworkcfg.h62
     107                            .global GBL_USERINITFXN          ; frameworkcfg.cmd
     108                            .global GBL_ENABLEINST           ; frameworkcfg.h62
     109                            .global GBL_CACHE                ; frameworkcfg.h62
     110                            .global GBL_L2CONFIGURE          ; frameworkcfg.h62
     111                            .global GBL_L2MODE               ; frameworkcfg.h62
     112                            .global GBL_L2PRIORITY           ; frameworkcfg.h62
     113                            .global GBL_L2MARMASK            ; frameworkcfg.h62
     114                            .global GBL_SUPPORTCSL           ; frameworkcfg.h62
     115                            .global GBL_TRCMASKVALUE         ; frameworkcfg.h62
     116                            .global GBL_CALLCSLCFGINIT       ; frameworkcfg.h62
     117                            .global GBL_C641XL2PRIORITY      ; frameworkcfg.h62
     118                            .global GBL_L2MARMASK1           ; frameworkcfg.h62
     119                            .global GBL_L2MARMASK2           ; frameworkcfg.h62
     120                            .global GBL_L2MARMASK3           ; frameworkcfg.h62
     121                            .global GBL_L2MARMASK4           ; frameworkcfg.h62
     122                            .global GBL_L2MARMASK5           ; frameworkcfg.h62
     123                            .global GBL_L2CONFIGALLOC        ; frameworkcfg.h62
     124                            .global GBL_L2ALLOC              ; frameworkcfg.h62
     125                    
     126                    ;; module MEM (gNumHeap, SEGZERO, MALLOCSEG)
     127                            .global MEM$                     ; == 1
     128                            .global MEM_gNumHeap             ; frameworkcfg.h62
     129                            .global MEM_SEGZERO              ; frameworkcfg.cmd
     130                            .global MEM_MALLOCSEG            ; frameworkcfg.cmd
     131                    
     132                    ;; module OBJ ()
     133                            .global OBJ$                     ; == 0
     134                    
     135                    ;; module BUF (ENABLED)
     136                            .global BUF$                     ; == 1
     137                            .global BUF_ENABLED              ; frameworkcfg.h62
     138                    
     139                    ;; module CLK (INTBIT, REGS, TIMERNUM, USETIMER, TCR, TDDR, TDDRHIGH, PRD, PRDHIGH, COUNTSPMS, COUNTSP
     140                            .global CLK$                     ; == 1
     141                            .global CLK_INTBIT               ; frameworkcfg.h62
     142                            .global CLK_REGS                 ; frameworkcfg.h62
     143                            .global CLK_TIMERNUM             ; frameworkcfg.h62
     144                            .global CLK_USETIMER             ; frameworkcfg.h62
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    4

     145                            .global CLK_TCR                  ; frameworkcfg.h62
     146                            .global CLK_TDDR                 ; frameworkcfg.h62
     147                            .global CLK_TDDRHIGH             ; frameworkcfg.h62
     148                            .global CLK_PRD                  ; frameworkcfg.h62
     149                            .global CLK_PRDHIGH              ; frameworkcfg.h62
     150                            .global CLK_COUNTSPMS            ; frameworkcfg.h62
     151                            .global CLK_COUNTSPMSHIGH        ; frameworkcfg.h62
     152                            .global CLK_TIMEFXN              ; frameworkcfg.cmd
     153                            .global CLK_HOOKFXN              ; frameworkcfg.cmd
     154                    
     155                    ;; module PRD (SCALAR, THOOKFXN)
     156                            .global PRD$                     ; == 1
     157                            .global PRD_SCALAR               ; frameworkcfg.h62
     158                            .global PRD_THOOKFXN             ; frameworkcfg.cmd
     159                    
     160                    ;; module RTDX (USERTDX, USERTEXECUTION, DATAMEMSEG, BUFMEMSIZE)
     161                            .global RTDX$                    ; == 1
     162                            .global RTDX_USERTDX             ; frameworkcfg.h62
     163                            .global RTDX_USERTEXECUTION      ; frameworkcfg.h62
     164                            .global RTDX_DATAMEMSEG          ; frameworkcfg.cmd
     165                            .global RTDX_BUFMEMSIZE          ; frameworkcfg.h62
     166                    
     167                    ;; module HST (RTDX, DSM, NONE, MAXFRAMESET, MAXFRAMEALLOWED, DSMBUFSEG, DSMMEMSIZE)
     168                            .global HST$                     ; == 1
     169                            .global HST_RTDX                 ; frameworkcfg.h62
     170                            .global HST_DSM                  ; frameworkcfg.h62
     171                            .global HST_NONE                 ; frameworkcfg.h62
     172                            .global HST_MAXFRAMESET          ; frameworkcfg.h62
     173                            .global HST_MAXFRAMEALLOWED      ; frameworkcfg.h62
     174                            .global HST_DSMBUFSEG            ; frameworkcfg.cmd
     175                            .global HST_DSMMEMSIZE           ; frameworkcfg.h62
     176                    
     177                    ;; module HWI (ZEROTAB, GENERATE_RESET_VEC, POLARITYMASK, INTRMULTLOW, INTRMULTHIGH)
     178                            .global HWI$                     ; == 1
     179                            .global HWI_ZEROTAB              ; frameworkcfg.h62
     180                            .global HWI_GENERATE_RESET_VEC   ; frameworkcfg.h62
     181                            .global HWI_POLARITYMASK         ; frameworkcfg.h62
     182                            .global HWI_INTRMULTLOW          ; frameworkcfg.h62
     183                            .global HWI_INTRMULTHIGH         ; frameworkcfg.h62
     184                    
     185                    ;; module SWI (EHOOKFXN, IHOOKFXN, EXECFXN, RUNFXN)
     186                            .global SWI$                     ; == 1
     187                            .global SWI_EHOOKFXN             ; frameworkcfg.cmd
     188                            .global SWI_IHOOKFXN             ; frameworkcfg.cmd
     189                            .global SWI_EXECFXN              ; frameworkcfg.cmd
     190                            .global SWI_RUNFXN               ; frameworkcfg.cmd
     191                    
     192                    ;; module TSK (STACKSIZE, STACKSEG, PRIORITY, VCREATEFXN, VDELETEFXN, VEXITFXN, SWITCHFXN, READYFXN, N
     193                            .global TSK$                     ; == 1
     194                            .global TSK_STACKSIZE            ; frameworkcfg.h62
     195                            .global TSK_STACKSEG             ; frameworkcfg.cmd
     196                            .global TSK_PRIORITY             ; frameworkcfg.h62
     197                            .global TSK_VCREATEFXN           ; frameworkcfg.cmd
     198                            .global TSK_VDELETEFXN           ; frameworkcfg.cmd
     199                            .global TSK_VEXITFXN             ; frameworkcfg.cmd
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    5

     200                            .global TSK_SWITCHFXN            ; frameworkcfg.h62
     201                            .global TSK_READYFXN             ; frameworkcfg.h62
     202                            .global TSK_NUM_HOOKS            ; frameworkcfg.h62
     203                    
     204                    ;; module IDL (USECLKIDLTIME, CALIBRFXN)
     205                            .global IDL$                     ; == 1
     206                            .global IDL_USECLKIDLTIME        ; frameworkcfg.h62
     207                            .global IDL_CALIBRFXN            ; frameworkcfg.cmd
     208                    
     209                    ;; module ISRC ()
     210                            .global ISRC$                    ; == 1
     211                    
     212                    ;; module LOG (ENABLED)
     213                            .global LOG$                     ; == 1
     214                            .global LOG_ENABLED              ; frameworkcfg.h62
     215                    
     216                    ;; module PIP (gNumEmbed, gNextId)
     217                            .global PIP$                     ; == 0
     218                            .global PIP_gNumEmbed            ; frameworkcfg.h62
     219                            .global PIP_gNextId              ; frameworkcfg.h62
     220                    
     221                    ;; module SEM ()
     222                            .global SEM$                     ; == 0
     223                    
     224                    ;; module MBX ()
     225                            .global MBX$                     ; == 0
     226                    
     227                    ;; module QUE ()
     228                            .global QUE$                     ; == 1
     229                    
     230                    ;; module LCK ()
     231                            .global LCK$                     ; == 1
     232                    
     233                    ;; module SIO ()
     234                            .global SIO$                     ; == 0
     235                    
     236                    ;; module STS ()
     237                            .global STS$                     ; == 1
     238                    
     239                    ;; module SYS (ABORTFXN, ERRORFXN, EXITFXN, PUTCFXN)
     240                            .global SYS$                     ; == 1
     241                            .global SYS_ABORTFXN             ; frameworkcfg.cmd
     242                            .global SYS_ERRORFXN             ; frameworkcfg.cmd
     243                            .global SYS_EXITFXN              ; frameworkcfg.cmd
     244                            .global SYS_PUTCFXN              ; frameworkcfg.cmd
     245                    
     246                    ;; module GIO (CREATEFXN, DELETEFXN, PENDFXN, POSTFXN)
     247                            .global GIO$                     ; == 1
     248                            .global GIO_CREATEFXN            ; frameworkcfg.cmd
     249                            .global GIO_DELETEFXN            ; frameworkcfg.cmd
     250                            .global GIO_PENDFXN              ; frameworkcfg.cmd
     251                            .global GIO_POSTFXN              ; frameworkcfg.cmd
     252                    
     253                    ;; module DEV ()
     254                            .global DEV$                     ; == 0
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    6

     255                    
     256                    ;; module UDEV ()
     257                            .global UDEV$                    ; == 1
     258                    
     259                    ;; module DGN ()
     260                            .global DGN$                     ; == 0
     261                    
     262                    ;; module DHL (gChannelsAvailable)
     263                            .global DHL$                     ; == 0
     264                            .global DHL_gChannelsAvailable   ; frameworkcfg.h62
     265                    
     266                    ;; module DPI ()
     267                            .global DPI$                     ; == 0
     268                    
     269                    ;; module HOOK (KNLID)
     270                            .global HOOK$                    ; == 0
     271                            .global HOOK_KNLID               ; frameworkcfg.h62
     272                    
     273                    ;; module DIO (STATIC, NUMTSKBASE, NUMSWIBASE)
     274                            .global DIO$                     ; == 0
     275                            .global DIO_STATIC               ; frameworkcfg.h62
     276                            .global DIO_NUMTSKBASE           ; frameworkcfg.h62
     277                            .global DIO_NUMSWIBASE           ; frameworkcfg.h62
     278                    
     279                    ;; MODULE CONFIGURATION
     280                    
     281                    ;; ======== GBL_config ========
     282                            .asg 00H, _ROM
     283                            .asg 00H, _BIGENDIAN
     284                            .asg 01H, _USERINIT
     285                            .asg _dm642_init, _USERINITFXN
     286                            .asg 01H, _ENABLEINST
     287                            .asg 00H, _CACHE
     288                            .asg 00H, _L2CONFIGURE
     289                            .asg 00H, _L2MODE
     290                            .asg 00H, _L2PRIORITY
     291                            .asg 00H, _L2MARMASK
     292                            .asg 01H, _SUPPORTCSL
     293                            .asg 0dbefH, _TRCMASKVALUE
     294                            .asg 01H, _CALLCSLCFGINIT
     295                            .asg 00H, _C641XL2PRIORITY
     296                            .asg 00H, _L2MARMASK1
     297                            .asg 00H, _L2MARMASK2
     298                            .asg 00H, _L2MARMASK3
     299                            .asg 00H, _L2MARMASK4
     300                            .asg 00H, _L2MARMASK5
     301                            .asg 00H, _L2CONFIGALLOC
     302                            .asg 02226H, _L2ALLOC
     303 00000000                   GBL_config  _ROM, _BIGENDIAN, _USERINIT, _USERINITFXN, _ENABLEINST, _CACHE, _L2CONFIGURE, _L2M
1                                   
1                                   ; reference special symbol GBL_boot defined in BIOS boot file to make sure
1                                   ; we are linking correct boot file (workaround for SDSsq24217)
1                                   .ref GBL_boot
1                           
1                                   .def TRC_cinit
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    7

1                                   .def _TRC_R_mask
1                                   .asg    _dm642_init, USERINITFXN        ; used by GBL_init
1                           
1                                   ;
1                                   ; print a warning message if project build options do not match
1                                   ; global configuration options.
1                                   ;
1                                   .if .BIG_ENDIAN
1                                       .if (GBL_BIGENDIAN == 0)
1                                           .emsg "Project build options do not match Global configuration settings.  Compiler opt
1                                       .endif
1                                   .else
1                                       .if (GBL_BIGENDIAN == 1)
1                                           .emsg "Project build options do not match Global configuration settings.  Compiler opt
1                                       .endif
1                                   .endif
1                           
1                                   ; initialize 'gblinit' variable, used in GBL_init
1        00000000           gblinit .sect ".gblinit"
1                           
1                                   ;
1                                   ; fill stack with '0xc0ffee'
1                                   ;
1                                   ; Don't overwrite the bottom 16 words to avoid trashing
1                                   ; valid stack data. (Only one of these words contains
1                                   ; valid data, but just to be safe we leave 16 untouched).
1                                   ;
1                                   ; (stacksize / wordsize) since size is in words
1                                   ;
1        00000000 00000000%         .word ( (GBL_stackend-GBL_stackbeg+1) / STD_TARGWORDMAUS ) - 16 ; nwords
1        00000004 00000000!         .word GBL_stackbeg                      ; addr
1        00000008 00C0FFEE          .word 0xc0ffee                          ; value
1                           
1                                   ;
1                                   ;  DEFINE A SPECIAL WORD THAT WILL BE COPIED TO TRC_R_mask
1                                   ;  AT PROGRAM INITIALIZATION, INSTEAD OF PUTTING TRC_cinit
1                                   ;  INTO THE .cinit SECTION.
1                                   ;  THIS WAY WE CAN WRITE TO BOTH TRC_R_mask AND TRC_cinit
1                                   ;  AND APPLICATION PROGRAMS CAN STILL USE THE .cinit SECTION
1                                   ;  AFTER INITIALIZATION IS DONE.
1                                   ;
1        00000000                   .sect ".trcdata"
1                           
1        00000000           TRC_cinit:
1                                   .align 4
1        00000000 0000DBEF          .word GBL_TRCMASKVALUE          ; defined by configuration tool
1                           
1                                   ; We need to initialize TRC_R_mask, but can't use a .cinit
1                                   ; record, so it can't go into .bss as it was before since
1                                   ; the initialization below causes the whole .bss section to
1                                   ; become initialized and filled.
1                                   ;
1        00000004           TRC_R_mask:
1                                   .align 4
1        00000004 0000DBEF          .word GBL_TRCMASKVALUE          ; defined by configuration tool
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    8

1                           
1                 00000004+ _TRC_R_mask     .set    TRC_R_mask
1                           
1        00000008           GBL_initdone
1        00000008                   .sect ".trcdata"
1        00000008 00000000          .word 0
1                           
     304                    
     305                    ;; ======== MEM_config ========
     306                            .asg 01H, _gNumHeap
     307                            .asg SDRAM, _SEGZERO
     308                            .asg SDRAM, _MALLOCSEG
     309 0000000c                   MEM_config  _gNumHeap, _SEGZERO, _MALLOCSEG
1                           
1                               ;
1                               ; Proceed only if there are heaps declared.
1                               ;
1                               .if 01H
1                                   .global _MEM        ; Pointer to configuration parameters
1                                   .global _MEM_memtab        ; Array of memory heaps
1                                   .global __MEM_NUMSEGMENTS    ; Number of memory heaps
1                           
1                                   ;
1                                   ; The following two .bss/.cinit sets make configured values readable
1                                   ; in the established SPOX manner, e.g., MEM->MALLOCSEG.
1                                   ;
1        00000000           MEM_config    .usect    ".mem", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000000                   .sect ".cinit"
1                                   .align STD_TARGALIGN
1        00000000 00000004          .word 1 * STD_TARGWORDMAUS
1        00000004 00000000-         .word MEM_config   
1                           
1                                   ;; If MALLOCSEG = MEM_NULL then put in an err value in for MALLOCSEG$idx
1                                   .if ($symcmp("SDRAM", "MEM_NULL") == 0)
1                                       .word -1
1                                   .else
1        00000008 00000000              .word SDRAM$idx
1                                   .endif
1                           
1        0000000c                   .sect ".cinit"
1                                   .align STD_TARGALIGN
1        00000010 00000004          .word 1 * STD_TARGWORDMAUS
1        00000014 00000000!         .word _MEM   
1        00000018 00000000-         .word MEM_config
1                           
1                                   ;
1                                   ; This declares space for the array of configured heaps, the .cinit
1                                   ; parts are defined for each task in MEM_Obj.  This space has to be
1                                   ; reserved NOW, before the MEM_Obj macro is called and the elements
1                                   ; of the table are defined.
1                                   ;
1        00000000                   .bss _MEM_memtab, 01H * 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                   ;
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    9

1                                   ; Set MEM_tabIdx to 1 if _segzero is set to a MEM segment other then
1                                   ; MEM_NULL because the MEM segment will in the 0th place.
1                                   ; If _segzero is MEM_NULL then set MEM_tabIdx to 0 since MEM_NULL is
1                                   ; only a place holder and not a real MEM segment with a heap.
1                                   ;
1                                   .if $symcmp("MEM_NULL", "SDRAM") == 0
1                                       .asg    0, MEM_tabIdx        ; Index into MEM_memtab
1                                   .else
1                                       .asg    1, MEM_tabIdx        ; Index into MEM_memtab
1                                   .endif
1                           
1                               ;
1                               ; _MEM_memtab needs to be set to zero if no heap are defined
1                               ;
1                               .else
1                               .global _MEM_memtab
1                           _MEM_memtab .set 00h
1                               .endif        ; .if :_gNumHeap:
1                           
     310                    
     311                    ;; ======== OBJ_config ========
     312 0000001c                   OBJ_config
1                           
1                           
1                                   .asg    "_OBJ_table + 0 * STD_TARGWORDMAUS",    OBJ_TAB_SEM
1                                   .asg    "_OBJ_table + 2 * STD_TARGWORDMAUS",    OBJ_TAB_SWI
1                                   .asg    "_OBJ_table + 4 * STD_TARGWORDMAUS",    OBJ_TAB_TSK
1                                   .asg    "_OBJ_table + 6 * STD_TARGWORDMAUS",    OBJ_TAB_MBX
1                                   .asg    "_OBJ_table + 8 * STD_TARGWORDMAUS",    OBJ_TAB_SIO
1                                   .asg    "_OBJ_table + 10 * STD_TARGWORDMAUS",   OBJ_TAB_DEV
1                                   .asg    "_OBJ_table + 12 * STD_TARGWORDMAUS",   OBJ_TAB_BUF
1                           
1                                   .asg _OBJ_table + 0 * STD_TARGWORDMAUS, OBJ_sem$next
1                                   .asg _OBJ_table + 2 * STD_TARGWORDMAUS, OBJ_swi$next
1                                   .asg _OBJ_table + 4 * STD_TARGWORDMAUS, OBJ_tsk$next
1                                   .asg _OBJ_table + 6 * STD_TARGWORDMAUS, OBJ_mbx$next
1                                   .asg _OBJ_table + 8 * STD_TARGWORDMAUS, OBJ_sio$next
1                                   .asg _OBJ_table + 10 * STD_TARGWORDMAUS,  OBJ_dev$next
1                                   .asg _OBJ_table + 12 * STD_TARGWORDMAUS,  OBJ_buf$next
1                           
1                                   .asg _OBJ_table + 0 * STD_TARGWORDMAUS, OBJ_sem$prev
1                                   .asg _OBJ_table + 2 * STD_TARGWORDMAUS, OBJ_swi$prev
1                                   .asg _OBJ_table + 4 * STD_TARGWORDMAUS, OBJ_tsk$prev
1                                   .asg _OBJ_table + 6 * STD_TARGWORDMAUS, OBJ_mbx$prev
1                                   .asg _OBJ_table + 8 * STD_TARGWORDMAUS, OBJ_sio$prev
1                                   .asg _OBJ_table + 10 * STD_TARGWORDMAUS, OBJ_dev$prev
1                                   .asg _OBJ_table + 12 * STD_TARGWORDMAUS, OBJ_buf$prev
1                           
1                                   .asg    1,      SEM$sernum
1                                   .asg    1,      SWI$sernum
1                                   .asg    1,      TSK$sernum
1                                   .asg    1,      MBX$sernum
1                                   .asg    1,      SIO$sernum
1                                   .asg    1,      DEV$sernum
1                                   .asg    1,      BUF$sernum
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   10

1                           
     313                    
     314                    ;; ======== BUF_config ========
     315                            .asg 01H, _ENABLED
     316 0000001c                   BUF_config  _ENABLED
     317                    
     318                    ;; ======== CLK_config ========
     319                            .asg 04000H, _INTBIT
     320                            .asg 01940000H, _REGS
     321                            .asg 00H, _TIMERNUM
     322                            .asg 01H, _USETIMER
     323                            .asg 020H, _TCR
     324                            .asg 00H, _TDDR
     325                            .asg 00H, _TDDRHIGH
     326                            .asg 0124f8H, _PRD
     327                            .asg 01H, _PRDHIGH
     328                            .asg 0124f8H, _COUNTSPMS
     329                            .asg 01H, _COUNTSPMSHIGH
     330                            .asg CLK_F_getshtime, _TIMEFXN
     331                            .asg HWI_F_dispatch, _HOOKFXN
     332 0000001c                   CLK_config  _INTBIT, _REGS, _TIMERNUM, _USETIMER, _TCR, _TDDR, _TDDRHIGH, _PRD, _PRDHIGH, _COU
1                           
1                                   ;
1                                   ; NOTE! BIOS and SPOX overlap still needs resolution
1                                   ;
1                                   
     333                    
     334                    ;; ======== PRD_config ========
     335                            .asg 04000H, _SCALAR
     336                            .asg _KNL_tick, _THOOKFXN
     337 0000001c                   PRD_config  _SCALAR, _THOOKFXN
1                                   ; only expand if the PRD module is configured by the user
1                                   .asg 0, PRD_swihandle
1                                   .if (PRD$ = 1)
1                                       .if (PRD$NUMOF > 0)
1                                           .if (SWI$ != 1)
1                                               .emsg "PRD objects require the configuration of SWI"
1                                               .mexit
1                                           .endif
1                                           .asg "PRD_swi", PRD_swihandle
1                                       .endif
1                                   .endif
1                                   
     338                    
     339                    ;; ======== RTDX_config ========
     340                            .asg 01H, _USERTDX
     341                            .asg 00H, _USERTEXECUTION
     342                            .asg SDRAM, _DATAMEMSEG
     343                            .asg 0408H, _BUFMEMSIZE
     344 0000001c                   RTDX_config  _USERTDX, _USERTEXECUTION, _DATAMEMSEG, _BUFMEMSIZE
1                                   .if(RTDX_USERTDX = 1)
1                                       .global _RTDX_Buffer, _RTDX_Buffer_Start, _RTDX_Buffer_End
1                           
1                                       ; reserve uninitialized space for RTDX buffer
1        00000000           _RTDX_Buffer    .usect ".rtdx_data", 0408H, STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   11

1                           
1                                       ; define _RTDX_Buffer_Start
1        00000408           _RTDX_Buffer_Start  .usect ".rtdx_data", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000001c                   .sect ".cinit"
1                                   .align STD_TARGALIGN
1        00000020 00000004          .field  1 * STD_TARGWORDMAUS
1        00000024 00000408-         .field  _RTDX_Buffer_Start
1        00000028 00000000-         .field  _RTDX_Buffer
1                                   
1                                       ; define _RTDX_Buffer_End 
1        0000040c           _RTDX_Buffer_End  .usect ".rtdx_data", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000002c                   .sect ".cinit"
1                                   .align STD_TARGALIGN
1        00000030 00000004          .field  1 * STD_TARGWORDMAUS
1        00000034 0000040C-         .field  _RTDX_Buffer_End
1        00000038 00000404-         .field  _RTDX_Buffer + 0408H - (1 * STD_TARGWORDMAUS)
1                           
1                                   .endif
     345                    
     346                    ;; ======== HST_config ========
     347                            .asg 01H, _RTDX
     348                            .asg 00H, _DSM
     349                            .asg 00H, _NONE
     350                            .asg 00H, _MAXFRAMESET
     351                            .asg 0100H, _MAXFRAMEALLOWED
     352                            .asg SDRAM, _DSMBUFSEG
     353                            .asg 0400H, _DSMMEMSIZE
     354 0000003c                   HST_config  _RTDX, _DSM, _NONE, _MAXFRAMESET, _MAXFRAMEALLOWED, _DSMBUFSEG, _DSMMEMSIZE
1                                   .asg    0, HST$hstCount
1                                   .asg    0, chanId
1                           
1                                   .if(HST$ != 0)
1        0000003c                       LNK_config _dsm, _dsmbufseg, _dsmmemsize  ; do any reqd LNK config 
2                                   .ref LNK_dspFrameRequestMask, LNK_dspFrameReadyMask
2                           
2                                   .if(00H = 1)
2                           
2                                   .global LNK_outputBuf, LNK_inputBuf
2                           
2                                   ; reserve uninitialized space for DSP output buffer
2                           LNK_outputBuf .usect ".dsm", _dsmmemsize, STD_TARGWORDMAUS
2                           
2                                   ; reserve uninitialized space for DSP input buffer
2                           LNK_inputBuf .usect ".dsm", _dsmmemsize, STD_TARGWORDMAUS
2                           
2                                   .endif
2                           
1                                   .endif
1                           
     355                    
     356                    ;; ======== HWI_config ========
     357                            .asg 00H, _ZEROTAB
     358                            .asg 00H, _GENERATE_RESET_VEC
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   12

     359                            .asg 00H, _POLARITYMASK
     360                            .asg 0250718a4H, _INTRMULTLOW
     361                            .asg 082039a3H, _INTRMULTHIGH
     362 0000003c                   HWI_config  _ZEROTAB, _GENERATE_RESET_VEC, _POLARITYMASK, _INTRMULTLOW, _INTRMULTHIGH
1                           
     363                    
     364                    ;; ======== SWI_config ========
     365                            .asg GBL_NULL, _EHOOKFXN
     366                            .asg GBL_NULL, _IHOOKFXN
     367                            .asg SWI_F_iexec, _EXECFXN
     368                            .asg SWI_F_run, _RUNFXN
     369 0000003c                   SWI_config  _EHOOKFXN, _IHOOKFXN, _EXECFXN, _RUNFXN
1                           
     370                    
     371                    ;; ======== TSK_config ========
     372                            .asg 05000H, _STACKSIZE
     373                            .asg SDRAM, _STACKSEG
     374                            .asg 01H, _PRIORITY
     375                            .asg _FXN_F_nop, _VCREATEFXN
     376                            .asg _FXN_F_nop, _VDELETEFXN
     377                            .asg _FXN_F_nop, _VEXITFXN
     378                            .asg 00H, _SWITCHFXN
     379                            .asg 00H, _READYFXN
     380                            .asg 00H, _NUM_HOOKS
     381 0000003c                   TSK_config  _STACKSIZE, _STACKSEG, _PRIORITY, _VCREATEFXN, _VDELETEFXN, _VEXITFXN, _SWITCHFXN,
1                           
1                                   ;; If MEM_gNumHeap then put in an err value in for TSK$stackseg
1                                   .if (MEM_gNumHeap == 0)
1                                           .asg    "-1", TSK$stackseg
1                                   .else 
1                                       .if ($symcmp("SDRAM", "MEM_NULL") == 0)
1                                           .asg    "-1", TSK$stackseg
1                                       .else
1                                           .asg    "SDRAM$idx", TSK$stackseg
1                                       .endif
1                                   .endif
1                           
1                                   .ref    _FXN_F_nop, _FXN_F_nop, _FXN_F_nop
1                           
1                                   .if $isname("00H")
1                                       .ref        :_switchfxn:
1                                   .endif
1                           
1                                   .if $isname("00H")
1                                       .ref :_readyfxn:
1                                   .endif
1                           
1                                   .global _TSK_exit
1                           
1                                   ;
1                                   ; Initialize counter for use in TSK_Obj
1                                   ;
1                                   .eval 0, TSK$strCount
1                           
1                                   .eval   00H, TSK$num_hooks
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   13

1                           
     382                    
     383                    ;; ======== IDL_config ========
     384                            .asg 01H, _USECLKIDLTIME
     385                            .asg IDL_F_stub, _CALIBRFXN
     386 0000003c                   IDL_config  _USECLKIDLTIME, _CALIBRFXN
1                               .asg 01H,USECLKIDLTIME    ; used by IDL_init
     387                    
     388                    ;; ======== ISRC_config ========
     389 0000003c                   ISRC_config
     390                    
     391                    ;; ======== LOG_config ========
     392                            .asg 01H, _ENABLED
     393 0000003c                   LOG_config  _ENABLED
     394                    
     395                    ;; ======== PIP_config ========
     396                            .asg 02H, _gNumEmbed
     397                            .asg 00H, _gNextId
     398 0000003c                   PIP_config  _gNumEmbed, _gNextId
     399                    
     400                    ;; ======== SEM_config ========
     401 0000003c                   SEM_config
1                           
1                                   .global __SEM_dopost
     402                    
     403                    ;; ======== MBX_config ========
     404 0000003c                   MBX_config
     405                    
     406                    ;; ======== QUE_config ========
     407 0000003c                   QUE_config
     408                    
     409                    ;; ======== LCK_config ========
     410 0000003c                   LCK_config
     411                    
     412                    ;; ======== SIO_config ========
     413 0000003c                   SIO_config
     414                    
     415                    ;; ======== STS_config ========
     416 0000003c                   STS_config
1                                   ; only expand if the STS module is configured by the user
1                                   .if (STS$ = 1)
1                                       .if (STS$NUMOF > 0)
1                                       .endif
1                                   .endif
1                                   
     417                    
     418                    ;; ======== SYS_config ========
     419                            .asg _UTL_doAbort, _ABORTFXN
     420                            .asg _UTL_doError, _ERRORFXN
     421                            .asg _UTL_halt, _EXITFXN
     422                            .asg _UTL_doPutc, _PUTCFXN
     423 0000003c                   SYS_config  _ABORTFXN, _ERRORFXN, _EXITFXN, _PUTCFXN
1                                   .global SYS$config
1                           
1        00000000           SYS$config:     .usect  ".sys",4 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   14

1                           
1        0000003c                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000040 00000010          .word   4 * STD_TARGWORDMAUS
1        00000044 00000000-         .word   SYS$config
1        00000048 00000000!         .word   _UTL_doAbort
1        0000004c 00000000!         .word   _UTL_doError
1        00000050 00000000!         .word   _UTL_halt
1        00000054 00000000!         .word   _UTL_doPutc
1                           
     424                    
     425                    ;; ======== GIO_config ========
     426                            .asg _SEM_create, _CREATEFXN
     427                            .asg _SEM_delete, _DELETEFXN
     428                            .asg _SEM_pend, _PENDFXN
     429                            .asg _SEM_post, _POSTFXN
     430 00000058                   GIO_config  _CREATEFXN, _DELETEFXN, _PENDFXN, _POSTFXN
1                                   .if (GIO$ = 1)
1                           
1                                       .global _GIO
1                                       .global GIO$config
1                           
1        00000000           GIO$config:     .usect  ".gio", 4 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000058                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1        00000058 00000010              .word       4 * STD_TARGWORDMAUS
1        0000005c 00000000-             .word       GIO$config
1        00000060 00000000!             .word   _SEM_create
1        00000064 00000000!             .word   _SEM_delete
1        00000068 00000000!             .word   _SEM_pend
1        0000006c 00000000!             .word   _SEM_post
1                           
1                           ;
1                           ;  Set up pointer to GIO configuration parameters
1                           ;
1        0000000c                       .bss    _GIO, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000070                       .sect   ".cinit"
1                                       .align  STD_TARGALIGN
1        00000070 00000004              .word   1 * STD_TARGWORDMAUS
1        00000074 0000000C-             .word   _GIO
1        00000078 00000000-             .word   GIO$config
1                           
1                                   .endif
     431                    
     432                    ;; ======== DEV_config ========
     433 0000007c                   DEV_config
1                                   .asg    0,      DEV$initCount
     434                    
     435                    ;; ======== UDEV_config ========
     436 0000007c                   UDEV_config
     437                    
     438                    ;; ======== DGN_config ========
     439 0000007c                   DGN_config
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   15

1                           
1                                   .if ($isdefed("STD_FLOATDSP") = 0)
1                           DGN_FLOATDSP    .set 0
1                                   .elseif (STD_FLOATDSP = 1)
1                           DGN_FLOATDSP    .set 1
1                                   .else
1                 00000000  DGN_FLOATDSP    .set 0
1                                   .endif
1                                   
1                                   .if (DGN_FLOATDSP == 1)
1                           
1                                   .global _DGN_fconst
1                                   .global _DGN_frand
1                                   .global _DGN_fsine
1                                   .global _DGN_user
1                           
1                                   .asg    _DGN_fconst,  DGN_CONST
1                                   .asg    _DGN_frand,  DGN_RAND
1                                   .asg    _DGN_fsine,  DGN_SINE
1                                   .asg    _DGN_user,   DGN_USER
1                           
1                                   .else
1                           
1                                   .global _DGN_iconst
1                                   .global _DGN_irand
1                                   .global _DGN_isine
1                                   .global _DGN_user
1                           
1                                   .asg    _DGN_iconst, DGN_CONST
1                                   .asg    _DGN_irand,  DGN_RAND
1                                   .asg    _DGN_isine,  DGN_SINE
1                                   .asg    _DGN_user,   DGN_USER
1                           
1                                   .endif
1                           
     440                    
     441                    ;; ======== DHL_config ========
     442                            .asg 00H, _gChannelsAvailable
     443 0000007c                   DHL_config  _gChannelsAvailable
1                           
1                                   .global _DHL_notify
1                           
1                                   .asg    0, DHL$count
1                           
     444                    
     445                    ;; ======== DPI_config ========
     446 0000007c                   DPI_config
1                                   .asg    0, DPI$devid
     447                    
     448                    ;; ======== HOOK_config ========
     449                            .asg 00H, _KNLID
     450 0000007c                   HOOK_config  _KNLID
1                           
1                                   .if (HOOK$ == 1)
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   16

1                                   .def    __HOOK_initFxnTable
1                                   .def    __HOOK_createFxnTable
1                                   .def    __HOOK_deleteFxnTable
1                                   .def    __HOOK_exitFxnTable
1                                   .def    __HOOK_readyFxnTable
1                                   .def    __HOOK_switchFxnTable
1                           
1                                   .endif
1                           
1                                   .asg    0, HOOK$index
1                                   .eval   00H, HOOK$knl_index
1                           
1                                   .def    __HOOK_knlId
1                           
1        00000010                   .bss    __HOOK_knlId, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000007c                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000080 00000004          .word   1 * STD_TARGWORDMAUS
1        00000084 00000010-         .word   __HOOK_knlId
1        00000088 00000000          .word   0
1                           
     451                    
     452                    ;; ======== DIO_config ========
     453                            .asg 00H, _STATIC
     454                            .asg 00H, _NUMTSKBASE
     455                            .asg 00H, _NUMSWIBASE
     456 0000008c                   DIO_config  _STATIC, _NUMTSKBASE, _NUMSWIBASE
1                                   .if (00H)
1                                       .if (:_numTskBase: != 0)
1                                           .global _DIO_NUMTSKSTATIC  ; Number of Static TSK DIO objects
1                                           .global _DIO_TSKTABLE      ; Table of DIO objects for TSK.
1                           
1                                           .eval DIO_OBJSIZE * :_numTskBase:, DIO_TABLESIZE
1                           
1                           ;
1                           ;  Allocate space for DIO_NUMTSKSTATIC value.
1                           ;  This value is used in Static TSK version of DIO.
1                           ;  Allocate space for TSK DIO table
1                           ;
1                           _DIO_NUMTSKSTATIC       .usect ".dio", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           _DIO_TSKTABLE           .usect ".dio", DIO_TABLESIZE * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                           ;
1                                           ;  initialize DIO_NUMTSKSTATIC.
1                                           ;
1                                           .sect ".cinit"
1                                           .align STD_TARGALIGN
1                                           .word 1 * STD_TARGWORDMAUS
1                                           .word _DIO_NUMTSKSTATIC
1                                           .word :_numTskBase:
1                                       
1                                           .eval   0, count
1                           
1                                           .loop
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   17

1                           
1                                               ;
1                                               ;  Initialize the TSK DIO table.
1                                               ;
1                                               .sect ".cinit"
1                                               .align STD_TARGALIGN
1                                               .word DIO_OBJSIZE * STD_TARGWORDMAUS
1                                               .word _DIO_TSKTABLE + DIO_OBJSIZE * :count: * STD_TARGWORDMAUS
1                                               .word 0                     ; fxns
1                                               .word 0                     ; chanp
1                                               .word dio:count:$complete   ; complete
1                                               .word 0                     ; ready
1                                               .word 0                     ; extra word for union
1                           
1                                               ;  create the complete SEM object
1                                               DIO_semObject dio:count:$complete, 0
1                           
1                                               .eval count + 1, count
1                                               .break (count == :_numTskBase:)
1                                           .endloop
1                                       .endif      ; .if (:_numTskBase: != 0)
1                           
1                                       .if (:_numSwiBase: != 0)
1                                           .global _DIO_NUMCBSTATIC  ; Number of Cb Static DIO objects.
1                                           .global _DIO_CBTABLE      ; Table of DIO objects for Callback.
1                           
1                                           .eval DIO_OBJSIZE * :_numSwiBase:, DIO_TABLESIZE
1                           
1                           ;
1                           ;  Allocate space for DIO_NUMCBSTATIC value
1                           ;  This value is used in Static Callback version of DIO.
1                           ;  Allocate space for Callback DIO Table
1                           ;
1                           _DIO_NUMCBSTATIC        .usect ".dio", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           _DIO_CBTABLE            .usect ".dio", DIO_TABLESIZE * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                           ;
1                                           ;  initialize DIO_NUMCBSTATIC.
1                                           ;
1                                           .sect ".cinit"
1                                           .align STD_TARGALIGN
1                                           .word 1 * STD_TARGWORDMAUS
1                                           .word _DIO_NUMCBSTATIC
1                                           .word :_numSwiBase:
1                                   
1                                           .eval   0, count
1                           
1                                           .loop
1                                               
1                                               ;
1                                               ;  Initialize the Callback DIO table.
1                                               ;
1                                               .sect ".cinit"
1                                               .align STD_TARGALIGN
1                                               .word DIO_OBJSIZE * STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   18

1                                               .word _DIO_CBTABLE + DIO_OBJSIZE * :count: * STD_TARGWORDMAUS
1                                               .word 0                     ; fxns
1                                               .word 0                     ; chanp
1                                               .word 0                     ; context.cb.fxn
1                                               .word 0                     ; context.cb.arg0
1                                               .word 0                     ; context.cb.arg1
1                                           
1                                               .eval count + 1, count
1                                               .break (count == :_numSwiBase:)
1                                           .endloop
1                                       .endif      ; .if (:_numSiBase: != 0)
1                                   .endif          ; .if (:_static:)
1                           
     457                    
     458                    ;; ======== UDEV_Obj VP0CAPTURE ========
     459                    ;; <add comments here>
     460                    ;;
     461                    ;; UDEV_Obj VP0CAPTURE (iFxns, driverType, iParams, deviceId, initFxn, deviceGlobalDataPtr)
     462                            .global VP0CAPTURE
     463                            .asg _VPORTCAP_Fxns, _iFxns
     464                            .asg "DEV_IOMTYPE", _driverType
     465                            .asg _EMB_vCapParamsPort, _iParams
     466                            .asg 00H, _deviceId
     467                            .asg 00H, _initFxn
     468                            .asg 00H, _deviceGlobalDataPtr
     469 0000008c                   UDEV_Obj 1, VP0CAPTURE, 0, _iFxns, _driverType, _iParams, _deviceId, _initFxn, _deviceGlobalDa
1                           
1        00000000                   .sect   ".const"
1        00000000 0000002F  UDEV_VP0CAPTURE .string "/VP0CAPTURE",0 ; Set up string "/<devName>"
         00000001 00000056 
         00000002 00000050 
         00000003 00000030 
         00000004 00000043 
         00000005 00000041 
         00000006 00000050 
         00000007 00000054 
         00000008 00000055 
         00000009 00000052 
         0000000a 00000045 
         0000000b 00000000 
1                           
1                                   ; This matches SIO_:_device:$params in sio.hti
1                                   .asg "_EMB_vCapParamsPort", SIO_VP0CAPTURE$params
1                           
1                                   ;
1                                   ; This adds an entry to the device table, DEV_devtab, and the init
1                                   ; table, DEV_devinit.
1                                   ;
1        0000000c                   DEV_addDevice UDEV_VP0CAPTURE, _VPORTCAP_Fxns, 00H, _EMB_vCapParamsPort, 00H, DEV_IOMTYPE, 00H
2                           
2                                   .global UDEV_VP0CAPTURE$obj
2                                   .global UDEV_VP0CAPTURE$device 
2        00000000           UDEV_VP0CAPTURE$obj     .usect  ".devtable", 9 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
2                           
2                 0000000C- UDEV_VP0CAPTURE$device .set UDEV_VP0CAPTURE$obj + (3 * STD_TARGWORDMAUS)
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   19

2                           
2                             ; UDEV_VP0CAPTURE$device points to begining of DEV_Device entry. Note that
2                             ; UDEV_VP0CAPTURE can't be used here because UDEV_VP0CAPTURE is a string already 
2                             ; allocated in const by Obj's that call this macro. 
2                             ; So UDEV_VP0CAPTURE cannot be redefined to point to this DEV_Device entry.
2                           
2        0000008c                   .sect   ".cinit"
2                                   .align  STD_TARGALIGN
2        00000090 00000024          .word   9 * STD_TARGWORDMAUS
2        00000094 00000000-         .word   UDEV_VP0CAPTURE$obj
2                           
2        00000098                   OBJ_Obj UDEV_VP0CAPTURE$obj, OBJ_DEV, DEV_ENTRYSIZE     ;Cinitialized 3 words 
3                           
3                           ;
3                           ;  OBJ_SEM 
3                           ;
3                           
3                                   .if OBJ_DEV == OBJ_SEM
3                           
3                                       .if SEM$NUMOF != SEM$sernum
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sem$prev
3                           
3                                       .if SEM$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sem$next
3                                       .endif
3                           
3                                       .eval       SEM$sernum+1, SEM$sernum
3                           
3                           ;
3                           ;  OBJ_SWI
3                           ;
3                            
3                                   .elseif OBJ_DEV == OBJ_SWI
3                            
3                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
3                                           ; next points to next SWI Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   20

3                                       .endif
3                                    
3                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_swi$prev
3                           
3                                       .if SWI$sernum = 1                  ; first SWI Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       SWI$sernum+1, SWI$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_TSK 
3                           ;
3                           
3                                   .elseif OBJ_DEV == OBJ_TSK
3                           
3                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
3                                           ; next points to next TSK Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_tsk$prev
3                           
3                                       .if TSK$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       TSK$sernum+1, TSK$sernum
3                           
3                           ;
3                           ;  OBJ_MBX 
3                           ;
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   21

3                                   .elseif OBJ_DEV == OBJ_MBX
3                           
3                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_mbx$prev
3                           
3                                       .if MBX$sernum = 1                  ; first MBX Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_mbx$next
3                                       .endif
3                           
3                                       .eval       MBX$sernum+1, MBX$sernum
3                           
3                           ;
3                           ;  OBJ_SIO 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_SIO
3                           
3                                       .if (SIO$NUMOF != SIO$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sio$prev
3                           
3                                       .if SIO$sernum = 1                  ; first SIO Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sio$next
3                                       .endif
3                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   22

3                                       .eval       SIO$sernum+1, SIO$sernum
3                           
3                           ;
3                           ;  OBJ_DEV 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_DEV
3                                      
3                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
3                                       ; that get created. These entries are created from UDEV, DGN, DHL
3                                       ; DPI and DIO. 
3                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
3                           
3                                       .if DEV$NUMDEVICES != 1
3                                           ; next points to next object
3        00000098 00000024-                 .word   UDEV_VP0CAPTURE$obj + 9 * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
3                                       .endif
3                           
3        0000009c 00000058-             .word       _OBJ_table + 10 * STD_TARGWORDMAUS              ; previous object or OBJ_table
3                           
3        000000a0 0000ABC5              .word       OBJ_DEV | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       ; Below assignment is different from other OBJ modules. 
3                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
3                                       ; with UDEV_VP0CAPTURE$obj$obj itself. For example 'DGN_printData$obj', Note
3                                       ; that here we can't pass 'DGN_printData' to this macro
3                                       ; Because 'DGN_printData' is a string allocated in .const section
3                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
3                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
3                                       ; not string 'DGN_printData'
3                           
3                                       .asg "UDEV_VP0CAPTURE$obj", OBJ_dev$prev
3                           
3                                       .if 1 = 1                   ; first DEV_Device Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg "UDEV_VP0CAPTURE$obj", OBJ_dev$next
3                                       .endif
3                           
3                                       .eval       1+1, DEV$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_BUF 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_BUF
3                           
3                                       .if (BUF$NUMOF != BUF$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   23

3                                       .else
3                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_buf$prev
3                           
3                                       .if BUF$sernum = 1                  ; first BUF Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_buf$next
3                                       .endif
3                                       
3                                       .eval       BUF$sernum+1, BUF$sernum
3                                   
3                                   .else
3                           
3                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
3                           
3                                   .endif
3                           
2        000000a4 00000000+         .word  UDEV_VP0CAPTURE
2        000000a8 00000000!         .word  _VPORTCAP_Fxns
2        000000ac 00000000          .word  00H
2        000000b0 00000000!         .word  _EMB_vCapParamsPort
2        000000b4 00000001          .word  DEV_IOMTYPE
2        000000b8 00000000          .word  00H
2                           
2                                   ;
2                                   ; Prevent multiple appearances of a driver Dxx_init function in the
2                                   ; _DEV_devinit table even when there are  multiple occurrences of
2                                   ; different devices for the same driver. DXX_init should be only called
2                                   ; once!
2                                   ;
2                                   ; Only add to _DEV_devinit real functions. Do not add 0's.
2                                   .if ($isname("00H") = 1)
2                                     .if ($isdefed("DEV$:_initfxn:") = 0)
2                           DEV$:00H:       .set    1
2                           
2                                       .global     :_initfxn:
2                           
2                                       .sect       ".cinit"
2                                       .align      STD_TARGALIGN
2                                       .word       STD_TARGWORDMAUS
2                                       .word       _DEV_devinit + DEV$initCount * STD_TARGWORDMAUS
2                                       .word       :_initfxn:
2                           
2                                       ;
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   24

2                                       ; increment DEV$initCount for use by the next call of this macro and
2                                       ; DEV_end. DEV$initCount keep track of the size of _DEV_devinit.
2                                       ;
2                                       .eval       DEV$initCount+1,DEV$initCount
2                           
2                                     .endif        ; endif ($isdefed(DEV$:_initfxn:) = 0)
2                                   .endif          ; endif ($isname(":_initfxn:") = 1)
2                           
1                           
     470                    
     471                    ;; ======== UDEV_Obj VP1CAPTURE ========
     472                    ;; <add comments here>
     473                    ;;
     474                    ;; UDEV_Obj VP1CAPTURE (iFxns, driverType, iParams, deviceId, initFxn, deviceGlobalDataPtr)
     475                            .global VP1CAPTURE
     476                            .asg _VPORTCAP_Fxns, _iFxns
     477                            .asg "DEV_IOMTYPE", _driverType
     478                            .asg _EMB_vCapParamsPort, _iParams
     479                            .asg 01H, _deviceId
     480                            .asg 00H, _initFxn
     481                            .asg 00H, _deviceGlobalDataPtr
     482 000000bc                   UDEV_Obj 1, VP1CAPTURE, 0, _iFxns, _driverType, _iParams, _deviceId, _initFxn, _deviceGlobalDa
1                           
1        0000000c                   .sect   ".const"
1        0000000c 0000002F  UDEV_VP1CAPTURE .string "/VP1CAPTURE",0 ; Set up string "/<devName>"
         0000000d 00000056 
         0000000e 00000050 
         0000000f 00000031 
         00000010 00000043 
         00000011 00000041 
         00000012 00000050 
         00000013 00000054 
         00000014 00000055 
         00000015 00000052 
         00000016 00000045 
         00000017 00000000 
1                           
1                                   ; This matches SIO_:_device:$params in sio.hti
1                                   .asg "_EMB_vCapParamsPort", SIO_VP1CAPTURE$params
1                           
1                                   ;
1                                   ; This adds an entry to the device table, DEV_devtab, and the init
1                                   ; table, DEV_devinit.
1                                   ;
1        00000018                   DEV_addDevice UDEV_VP1CAPTURE, _VPORTCAP_Fxns, 01H, _EMB_vCapParamsPort, 00H, DEV_IOMTYPE, 00H
2                           
2                                   .global UDEV_VP1CAPTURE$obj
2                                   .global UDEV_VP1CAPTURE$device 
2        00000024           UDEV_VP1CAPTURE$obj     .usect  ".devtable", 9 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
2                           
2                 00000030- UDEV_VP1CAPTURE$device .set UDEV_VP1CAPTURE$obj + (3 * STD_TARGWORDMAUS)
2                           
2                             ; UDEV_VP1CAPTURE$device points to begining of DEV_Device entry. Note that
2                             ; UDEV_VP1CAPTURE can't be used here because UDEV_VP1CAPTURE is a string already 
2                             ; allocated in const by Obj's that call this macro. 
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   25

2                             ; So UDEV_VP1CAPTURE cannot be redefined to point to this DEV_Device entry.
2                           
2        000000bc                   .sect   ".cinit"
2                                   .align  STD_TARGALIGN
2        000000c0 00000024          .word   9 * STD_TARGWORDMAUS
2        000000c4 00000024-         .word   UDEV_VP1CAPTURE$obj
2                           
2        000000c8                   OBJ_Obj UDEV_VP1CAPTURE$obj, OBJ_DEV, DEV_ENTRYSIZE     ;Cinitialized 3 words 
3                           
3                           ;
3                           ;  OBJ_SEM 
3                           ;
3                           
3                                   .if OBJ_DEV == OBJ_SEM
3                           
3                                       .if SEM$NUMOF != SEM$sernum
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sem$prev
3                           
3                                       .if SEM$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sem$next
3                                       .endif
3                           
3                                       .eval       SEM$sernum+1, SEM$sernum
3                           
3                           ;
3                           ;  OBJ_SWI
3                           ;
3                            
3                                   .elseif OBJ_DEV == OBJ_SWI
3                            
3                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
3                                           ; next points to next SWI Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
3                                       .endif
3                                    
3                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
3                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   26

3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_swi$prev
3                           
3                                       .if SWI$sernum = 1                  ; first SWI Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       SWI$sernum+1, SWI$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_TSK 
3                           ;
3                           
3                                   .elseif OBJ_DEV == OBJ_TSK
3                           
3                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
3                                           ; next points to next TSK Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_tsk$prev
3                           
3                                       .if TSK$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       TSK$sernum+1, TSK$sernum
3                           
3                           ;
3                           ;  OBJ_MBX 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_MBX
3                           
3                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
3                                           ; next points to next object
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   27

3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_mbx$prev
3                           
3                                       .if MBX$sernum = 1                  ; first MBX Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_mbx$next
3                                       .endif
3                           
3                                       .eval       MBX$sernum+1, MBX$sernum
3                           
3                           ;
3                           ;  OBJ_SIO 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_SIO
3                           
3                                       .if (SIO$NUMOF != SIO$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sio$prev
3                           
3                                       .if SIO$sernum = 1                  ; first SIO Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sio$next
3                                       .endif
3                           
3                                       .eval       SIO$sernum+1, SIO$sernum
3                           
3                           ;
3                           ;  OBJ_DEV 
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   28

3                           ;
3                                   .elseif OBJ_DEV == OBJ_DEV
3                                      
3                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
3                                       ; that get created. These entries are created from UDEV, DGN, DHL
3                                       ; DPI and DIO. 
3                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
3                           
3                                       .if DEV$NUMDEVICES != 2
3                                           ; next points to next object
3        000000c8 00000048-                 .word   UDEV_VP1CAPTURE$obj + 9 * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
3                                       .endif
3                           
3        000000cc 00000000-             .word       UDEV_VP0CAPTURE$obj             ; previous object or OBJ_table
3                           
3        000000d0 0000ABC5              .word       OBJ_DEV | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       ; Below assignment is different from other OBJ modules. 
3                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
3                                       ; with UDEV_VP1CAPTURE$obj$obj itself. For example 'DGN_printData$obj', Note
3                                       ; that here we can't pass 'DGN_printData' to this macro
3                                       ; Because 'DGN_printData' is a string allocated in .const section
3                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
3                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
3                                       ; not string 'DGN_printData'
3                           
3                                       .asg "UDEV_VP1CAPTURE$obj", OBJ_dev$prev
3                           
3                                       .if 2 = 1                   ; first DEV_Device Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:", OBJ_dev$next
3                                       .endif
3                           
3                                       .eval       2+1, DEV$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_BUF 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_BUF
3                           
3                                       .if (BUF$NUMOF != BUF$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
3                                       .endif
3                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   29

3                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_buf$prev
3                           
3                                       .if BUF$sernum = 1                  ; first BUF Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_buf$next
3                                       .endif
3                                       
3                                       .eval       BUF$sernum+1, BUF$sernum
3                                   
3                                   .else
3                           
3                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
3                           
3                                   .endif
3                           
2        000000d4 0000000C+         .word  UDEV_VP1CAPTURE
2        000000d8 00000000!         .word  _VPORTCAP_Fxns
2        000000dc 00000001          .word  01H
2        000000e0 00000000!         .word  _EMB_vCapParamsPort
2        000000e4 00000001          .word  DEV_IOMTYPE
2        000000e8 00000000          .word  00H
2                           
2                                   ;
2                                   ; Prevent multiple appearances of a driver Dxx_init function in the
2                                   ; _DEV_devinit table even when there are  multiple occurrences of
2                                   ; different devices for the same driver. DXX_init should be only called
2                                   ; once!
2                                   ;
2                                   ; Only add to _DEV_devinit real functions. Do not add 0's.
2                                   .if ($isname("00H") = 1)
2                                     .if ($isdefed("DEV$:_initfxn:") = 0)
2                           DEV$:00H:       .set    1
2                           
2                                       .global     :_initfxn:
2                           
2                                       .sect       ".cinit"
2                                       .align      STD_TARGALIGN
2                                       .word       STD_TARGWORDMAUS
2                                       .word       _DEV_devinit + DEV$initCount * STD_TARGWORDMAUS
2                                       .word       :_initfxn:
2                           
2                                       ;
2                                       ; increment DEV$initCount for use by the next call of this macro and
2                                       ; DEV_end. DEV$initCount keep track of the size of _DEV_devinit.
2                                       ;
2                                       .eval       DEV$initCount+1,DEV$initCount
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   30

2                           
2                                     .endif        ; endif ($isdefed(DEV$:_initfxn:) = 0)
2                                   .endif          ; endif ($isname(":_initfxn:") = 1)
2                           
1                           
     483                    
     484                    ;; ======== UDEV_Obj VP2DISPLAY ========
     485                    ;; <add comments here>
     486                    ;;
     487                    ;; UDEV_Obj VP2DISPLAY (iFxns, driverType, iParams, deviceId, initFxn, deviceGlobalDataPtr)
     488                            .global VP2DISPLAY
     489                            .asg _VPORTDIS_Fxns, _iFxns
     490                            .asg "DEV_IOMTYPE", _driverType
     491                            .asg _EMB_vDisParamsPort, _iParams
     492                            .asg 02H, _deviceId
     493                            .asg 00H, _initFxn
     494                            .asg 00H, _deviceGlobalDataPtr
     495 000000ec                   UDEV_Obj 1, VP2DISPLAY, 0, _iFxns, _driverType, _iParams, _deviceId, _initFxn, _deviceGlobalDa
1                           
1        00000018                   .sect   ".const"
1        00000018 0000002F  UDEV_VP2DISPLAY .string "/VP2DISPLAY",0 ; Set up string "/<devName>"
         00000019 00000056 
         0000001a 00000050 
         0000001b 00000032 
         0000001c 00000044 
         0000001d 00000049 
         0000001e 00000053 
         0000001f 00000050 
         00000020 0000004C 
         00000021 00000041 
         00000022 00000059 
         00000023 00000000 
1                           
1                                   ; This matches SIO_:_device:$params in sio.hti
1                                   .asg "_EMB_vDisParamsPort", SIO_VP2DISPLAY$params
1                           
1                                   ;
1                                   ; This adds an entry to the device table, DEV_devtab, and the init
1                                   ; table, DEV_devinit.
1                                   ;
1        00000024                   DEV_addDevice UDEV_VP2DISPLAY, _VPORTDIS_Fxns, 02H, _EMB_vDisParamsPort, 00H, DEV_IOMTYPE, 00H
2                           
2                                   .global UDEV_VP2DISPLAY$obj
2                                   .global UDEV_VP2DISPLAY$device 
2        00000048           UDEV_VP2DISPLAY$obj     .usect  ".devtable", 9 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
2                           
2                 00000054- UDEV_VP2DISPLAY$device .set UDEV_VP2DISPLAY$obj + (3 * STD_TARGWORDMAUS)
2                           
2                             ; UDEV_VP2DISPLAY$device points to begining of DEV_Device entry. Note that
2                             ; UDEV_VP2DISPLAY can't be used here because UDEV_VP2DISPLAY is a string already 
2                             ; allocated in const by Obj's that call this macro. 
2                             ; So UDEV_VP2DISPLAY cannot be redefined to point to this DEV_Device entry.
2                           
2        000000ec                   .sect   ".cinit"
2                                   .align  STD_TARGALIGN
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   31

2        000000f0 00000024          .word   9 * STD_TARGWORDMAUS
2        000000f4 00000048-         .word   UDEV_VP2DISPLAY$obj
2                           
2        000000f8                   OBJ_Obj UDEV_VP2DISPLAY$obj, OBJ_DEV, DEV_ENTRYSIZE     ;Cinitialized 3 words 
3                           
3                           ;
3                           ;  OBJ_SEM 
3                           ;
3                           
3                                   .if OBJ_DEV == OBJ_SEM
3                           
3                                       .if SEM$NUMOF != SEM$sernum
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sem$prev
3                           
3                                       .if SEM$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sem$next
3                                       .endif
3                           
3                                       .eval       SEM$sernum+1, SEM$sernum
3                           
3                           ;
3                           ;  OBJ_SWI
3                           ;
3                            
3                                   .elseif OBJ_DEV == OBJ_SWI
3                            
3                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
3                                           ; next points to next SWI Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
3                                       .endif
3                                    
3                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   32

3                                       ;
3                                       .asg        ":name:$obj", OBJ_swi$prev
3                           
3                                       .if SWI$sernum = 1                  ; first SWI Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       SWI$sernum+1, SWI$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_TSK 
3                           ;
3                           
3                                   .elseif OBJ_DEV == OBJ_TSK
3                           
3                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
3                                           ; next points to next TSK Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_tsk$prev
3                           
3                                       .if TSK$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       TSK$sernum+1, TSK$sernum
3                           
3                           ;
3                           ;  OBJ_MBX 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_MBX
3                           
3                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
3                                       .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   33

3                                   
3                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_mbx$prev
3                           
3                                       .if MBX$sernum = 1                  ; first MBX Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_mbx$next
3                                       .endif
3                           
3                                       .eval       MBX$sernum+1, MBX$sernum
3                           
3                           ;
3                           ;  OBJ_SIO 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_SIO
3                           
3                                       .if (SIO$NUMOF != SIO$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sio$prev
3                           
3                                       .if SIO$sernum = 1                  ; first SIO Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sio$next
3                                       .endif
3                           
3                                       .eval       SIO$sernum+1, SIO$sernum
3                           
3                           ;
3                           ;  OBJ_DEV 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_DEV
3                                      
3                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   34

3                                       ; that get created. These entries are created from UDEV, DGN, DHL
3                                       ; DPI and DIO. 
3                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
3                           
3                                       .if DEV$NUMDEVICES != 3
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3        000000f8 00000058-                 .word   _OBJ_table + 10 * STD_TARGWORDMAUS              ; next points back to OBJ_tabl
3                                       .endif
3                           
3        000000fc 00000024-             .word       UDEV_VP1CAPTURE$obj             ; previous object or OBJ_table
3                           
3        00000100 0000ABC5              .word       OBJ_DEV | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       ; Below assignment is different from other OBJ modules. 
3                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
3                                       ; with UDEV_VP2DISPLAY$obj$obj itself. For example 'DGN_printData$obj', Note
3                                       ; that here we can't pass 'DGN_printData' to this macro
3                                       ; Because 'DGN_printData' is a string allocated in .const section
3                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
3                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
3                                       ; not string 'DGN_printData'
3                           
3                                       .asg "UDEV_VP2DISPLAY$obj", OBJ_dev$prev
3                           
3                                       .if 3 = 1                   ; first DEV_Device Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:", OBJ_dev$next
3                                       .endif
3                           
3                                       .eval       3+1, DEV$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_BUF 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_BUF
3                           
3                                       .if (BUF$NUMOF != BUF$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   35

3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_buf$prev
3                           
3                                       .if BUF$sernum = 1                  ; first BUF Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_buf$next
3                                       .endif
3                                       
3                                       .eval       BUF$sernum+1, BUF$sernum
3                                   
3                                   .else
3                           
3                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
3                           
3                                   .endif
3                           
2        00000104 00000018+         .word  UDEV_VP2DISPLAY
2        00000108 00000000!         .word  _VPORTDIS_Fxns
2        0000010c 00000002          .word  02H
2        00000110 00000000!         .word  _EMB_vDisParamsPort
2        00000114 00000001          .word  DEV_IOMTYPE
2        00000118 00000000          .word  00H
2                           
2                                   ;
2                                   ; Prevent multiple appearances of a driver Dxx_init function in the
2                                   ; _DEV_devinit table even when there are  multiple occurrences of
2                                   ; different devices for the same driver. DXX_init should be only called
2                                   ; once!
2                                   ;
2                                   ; Only add to _DEV_devinit real functions. Do not add 0's.
2                                   .if ($isname("00H") = 1)
2                                     .if ($isdefed("DEV$:_initfxn:") = 0)
2                           DEV$:00H:       .set    1
2                           
2                                       .global     :_initfxn:
2                           
2                                       .sect       ".cinit"
2                                       .align      STD_TARGALIGN
2                                       .word       STD_TARGWORDMAUS
2                                       .word       _DEV_devinit + DEV$initCount * STD_TARGWORDMAUS
2                                       .word       :_initfxn:
2                           
2                                       ;
2                                       ; increment DEV$initCount for use by the next call of this macro and
2                                       ; DEV_end. DEV$initCount keep track of the size of _DEV_devinit.
2                                       ;
2                                       .eval       DEV$initCount+1,DEV$initCount
2                           
2                                     .endif        ; endif ($isdefed(DEV$:_initfxn:) = 0)
2                                   .endif          ; endif ($isname(":_initfxn:") = 1)
2                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   36

1                           
     496                    
     497                    ;; ======== MEM_Obj ISRAM ========
     498                    ;; This object defines space for the DSP's on-chip memory
     499                    ;;
     500                    ;; MEM_Obj ISRAM (len, iAllocHeap, iSegZero, iHeapId)
     501                            .global ISRAM
     502                            .asg 02f300H, _len
     503                            .asg 00H, _iAllocHeap
     504                            .asg SDRAM, _iSegZero
     505                            .asg segment_name, _iHeapId
     506 0000011c                   MEM_Obj 1, ISRAM, 0, _len, _iAllocHeap, _iSegZero, _iHeapId
1                           
1                               .if 1 == 1
1                           
1                                   .asg -1, idxVal    ; default index value
1                               
1                                 .if    02f300H
1                           
1                                   .if 00H
1                           
1                                       .global :name:$B    ; heap base address
1                                       .global :name:$L    ; heap length
1                           
1                                       ;
1                                       ; Define an entry in _MEM_memtab[] (allocated out of bss in
1                                       ; MEM_config.
1                                       ; The following block must match the MEM_Segment structure
1                                       ; in mem.h.
1                                       ;
1                                       .sect ".cinit"
1                                       .align STD_TARGALIGN
1                                       .if    $symcmp(":name:", ":_iSegZero:") == 0
1                                             .word 3 * STD_TARGWORDMAUS
1                                             .word _MEM_memtab   
1                                             .eval 0, idxVal
1                                       .else
1                                             .word 3 * STD_TARGWORDMAUS
1                                             .word _MEM_memtab + MEM_tabIdx *3 * STD_TARGWORDMAUS
1                                             ; assign meaningful index value
1                                             .eval MEM_tabIdx, idxVal
1                           
1                                             ; post-increment macro variable for next pass
1                                             .eval    MEM_tabIdx + 1, MEM_tabIdx
1                                       .endif
1                                             .word :name:$B
1                                             .word :name:$L
1                                             .word 1
1                           
1                                             ; create array index variable (using the segment's name)
1                                             .bss :name:, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                             .sect ".cinit"
1                                             .align STD_TARGALIGN
1                                             .word 1 * STD_TARGWORDMAUS
1                                             .word :name:   
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   37

1                                             .word idxVal
1                           
1                                            ; create array index variable (using the segment's name)
1                                           .if $symcmp(":_iHeapId:", "segment_name") != 0
1                                               .global :_iHeapId:
1                           :_iHeapId:          .set :name:
1                                           .endif
1                           
1                           
1                           :name:$idx .set    idxVal    ; used by MEM_config
1                           
1                                   .else
1                 FFFFFFFF  ISRAM .set -1        ; To satisfy assignment of C alias in *cfg.cmd file.
1                           
1                                   .endif            ; .if :iHeap:
1                           
1                                 .endif            ; .if 02f300H
1                           
1                               .endif                ; .if 1 == 1
1                           
     507                    
     508                    ;; ======== MEM_Obj SDRAM ========
     509                    ;; This object defines space for the DSP's off-chip memory
     510                    ;;
     511                    ;; MEM_Obj SDRAM (len, iAllocHeap, iSegZero, iHeapId)
     512                            .global SDRAM
     513                            .asg 0b80000H, _len
     514                            .asg 01H, _iAllocHeap
     515                            .asg SDRAM, _iSegZero
     516                            .asg _extHeap, _iHeapId
     517 0000011c                   MEM_Obj 1, SDRAM, 0, _len, _iAllocHeap, _iSegZero, _iHeapId
1                           
1                               .if 1 == 1
1                           
1                                   .asg -1, idxVal    ; default index value
1                               
1                                 .if    0b80000H
1                           
1                                   .if 01H
1                           
1                                       .global SDRAM$B    ; heap base address
1                                       .global SDRAM$L    ; heap length
1                           
1                                       ;
1                                       ; Define an entry in _MEM_memtab[] (allocated out of bss in
1                                       ; MEM_config.
1                                       ; The following block must match the MEM_Segment structure
1                                       ; in mem.h.
1                                       ;
1        0000011c                       .sect ".cinit"
1                                       .align STD_TARGALIGN
1                                       .if    $symcmp("SDRAM", "SDRAM") == 0
1        00000120 0000000C                    .word 3 * STD_TARGWORDMAUS
1        00000124 00000000-                   .word _MEM_memtab   
1                                             .eval 0, idxVal
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   38

1                                       .else
1                                             .word 3 * STD_TARGWORDMAUS
1                                             .word _MEM_memtab + MEM_tabIdx *3 * STD_TARGWORDMAUS
1                                             ; assign meaningful index value
1                                             .eval MEM_tabIdx, idxVal
1                           
1                                             ; post-increment macro variable for next pass
1                                             .eval    MEM_tabIdx + 1, MEM_tabIdx
1                                       .endif
1        00000128 00000000!                   .word SDRAM$B
1        0000012c 00000000!                   .word SDRAM$L
1        00000130 00000001                    .word 1
1                           
1                                             ; create array index variable (using the segment's name)
1        00000014                             .bss SDRAM, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        00000134                             .sect ".cinit"
1                                             .align STD_TARGALIGN
1        00000138 00000004                    .word 1 * STD_TARGWORDMAUS
1        0000013c 00000014-                   .word SDRAM   
1        00000140 00000000                    .word 0
1                           
1                                            ; create array index variable (using the segment's name)
1                                           .if $symcmp("_extHeap", "segment_name") != 0
1                                               .global _extHeap
1                 00000014- _extHeap            .set SDRAM
1                                           .endif
1                           
1                           
1                 00000000  SDRAM$idx .set    0    ; used by MEM_config
1                           
1                                   .else
1                           :name: .set -1        ; To satisfy assignment of C alias in *cfg.cmd file.
1                           
1                                   .endif            ; .if :iHeap:
1                           
1                                 .endif            ; .if 0b80000H
1                           
1                               .endif                ; .if 1 == 1
1                           
     518                    
     519                    ;; ======== BUF_Obj BUF_imgPool ========
     520                    ;; grabbed image pool
     521                    ;;
     522                    ;; BUF_Obj BUF_imgPool (bufseg, bufcount, size, align, postalignsize)
     523                            .global BUF_imgPool
     524                            .asg SDRAM, _bufseg
     525                            .asg 02H, _bufcount
     526                            .asg 04b000H, _size
     527                            .asg 04H, _align
     528                            .asg 04b000H, _postalignsize
     529 00000144                   BUF_Obj 1, BUF_imgPool, 0, _bufseg, _bufcount, _size, _align, _postalignsize
1                           
1                                   .global BUF_imgPool
1                                   .global BUF_imgPool$databeg
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   39

1                           
1        00000000           BUF_imgPool$obj .usect ".buf", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000000c           BUF_imgPool             .usect ".buf", 7 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000144                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000148 00000028          .word   10 * STD_TARGWORDMAUS
1        0000014c 00000000-         .word   BUF_imgPool$obj
1                           
1                                   ; A label for this object, "BUF_imgPool", will be set in OBJ_Obj
1        00000150                   OBJ_Obj BUF_imgPool, OBJ_BUF, BUF_CORESIZE
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_BUF == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_BUF == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   40

2                                       .endif
2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_BUF == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_tsk$prev
2                           
2                                       .if TSK$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       TSK$sernum+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   41

2                                   .elseif OBJ_BUF == OBJ_MBX
2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   42

2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != 1)
2                                           ; next points to next object
2        00000150 00000028-                 .word   BUF_imgPool + 7 * STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   43

2                                       .else
2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
2                                       .endif
2                           
2        00000154 00000060-             .word       _OBJ_table + 12 * STD_TARGWORDMAUS              ; previous object or OBJ_table
2                           
2        00000158 0000ABC6              .word       OBJ_BUF | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg "BUF_imgPool$obj", OBJ_buf$prev
2                           
2                                       .if 1 = 1                   ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg "BUF_imgPool$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       1+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        0000015c 00000000!         .word   BUF_imgPool$databeg  ; This filed is defined in linker command file
1        00000160 0004B000          .word   04b000H          ; original buffer size before alignment
1        00000164 0004B000          .word   04b000H ; size after alignment
1        00000168 00000000!         .word   BUF_imgPool$databeg  ; Address of first free buffer
1        0000016c 00000002          .word   02H       ; Total number of buffers in pool
1        00000170 00000002          .word   02H       ; Number of free buffers in pool
1        00000174 00000014-         .word   SDRAM          ; Memory segment of buffer pool
1                           
1                           
     530                    
     531                    ;; ======== BUF_Obj BUF_copyPool ========
     532                    ;; copy image pool
     533                    ;;
     534                    ;; BUF_Obj BUF_copyPool (bufseg, bufcount, size, align, postalignsize)
     535                            .global BUF_copyPool
     536                            .asg SDRAM, _bufseg
     537                            .asg 02H, _bufcount
     538                            .asg 04b44cH, _size
     539                            .asg 04H, _align
     540                            .asg 04b44cH, _postalignsize
     541 00000178                   BUF_Obj 1, BUF_copyPool, 0, _bufseg, _bufcount, _size, _align, _postalignsize
1                           
1                                   .global BUF_copyPool
1                                   .global BUF_copyPool$databeg
1                           
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   44

1        00000028           BUF_copyPool$obj        .usect ".buf", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000034           BUF_copyPool            .usect ".buf", 7 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000178                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000178 00000028          .word   10 * STD_TARGWORDMAUS
1        0000017c 00000028-         .word   BUF_copyPool$obj
1                           
1                                   ; A label for this object, "BUF_copyPool", will be set in OBJ_Obj
1        00000180                   OBJ_Obj BUF_copyPool, OBJ_BUF, BUF_CORESIZE
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_BUF == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_BUF == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
2                                       .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   45

2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_BUF == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_tsk$prev
2                           
2                                       .if TSK$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       TSK$sernum+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_MBX
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   46

2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
2                                       .eval       SIO$sernum+1, SIO$sernum
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   47

2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != 2)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   48

2        00000180 00000060-                 .word   _OBJ_table + 12 * STD_TARGWORDMAUS              ; next points back to OBJ_tabl
2                                       .endif
2                           
2        00000184 00000000-             .word       BUF_imgPool$obj         ; previous object or OBJ_table
2                           
2        00000188 0000ABC6              .word       OBJ_BUF | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg "BUF_copyPool$obj", OBJ_buf$prev
2                           
2                                       .if 2 = 1                   ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       2+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        0000018c 00000000!         .word   BUF_copyPool$databeg  ; This filed is defined in linker command file
1        00000190 0004B44C          .word   04b44cH          ; original buffer size before alignment
1        00000194 0004B44C          .word   04b44cH ; size after alignment
1        00000198 00000000!         .word   BUF_copyPool$databeg  ; Address of first free buffer
1        0000019c 00000002          .word   02H       ; Total number of buffers in pool
1        000001a0 00000002          .word   02H       ; Number of free buffers in pool
1        000001a4 00000014-         .word   SDRAM          ; Memory segment of buffer pool
1                           
1                           
     542                    
     543                    ;; ======== CLK_Obj PRD_clock ========
     544                    ;; This clock function calls PRD_tick from within the on-chip timer ISR
     545                    ;;
     546                    ;; CLK_Obj PRD_clock (function)
     547                            .global PRD_clock
     548                            .asg PRD_F_tick, _function
     549 000001a8                   CLK_Obj 1, PRD_clock, 0, _function
1        000001a8                   CHK_nargs "CLK_Obj", fxn
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "CLK_OBJ parameter error."
1                                   .endif
1                           
1                                   .var fxnlen
1                                   .eval $symlen("PRD_F_tick"),fxnlen
1                           
1                                   .if (1 = 0)
1                                       .mexit
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   49

1                                   .endif
1                           
1                                   .global PRD_clock
1                           
1                                   .if ($symcmp("PRD_F_tick", "0") != 0)
1                                   .global PRD_F_tick
1                                   .endif
1                           
1                           PRD_clock  .tag    CLK_Obj         ; declare name as having type CLK_Obj
1                           
1                           ; allocate all CLK objs contiguously in ".clk"
1        00000000           PRD_clock       .usect ".clk", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        000001a8                   .sect ".cinit"
1                           
1                                   .align  8
1                           
1        000001a8 00000004          .field  STD_TARGWORDMAUS * 1
1                           
1        000001ac 00000000-         .field  PRD_clock    
1                           
1        000001b0 00000000!         .field  PRD_F_tick           ; fxn
1                           
     550                    
     551                    ;; ======== HST_Obj RTA_fromHost ========
     552                    ;; Used to access LOG and STS data
     553                    ;;
     554                    ;; HST_Obj RTA_fromHost (mode, buf, framesize, numframes, stsflg, notify, arg0, arg1, lnk, bufFrameAli
     555                            .global RTA_fromHost
     556                            .asg "input", _mode
     557                            .asg "<NULL>", _buf
     558                            .asg 04H, _framesize
     559                            .asg 01H, _numframes
     560                            .asg 00H, _stsflg
     561                            .asg _FXN_F_nop, _notify
     562                            .asg 00H, _arg0
     563                            .asg 00H, _arg1
     564                            .asg "RTDX", _lnk
     565                            .asg 04H, _bufFrameAlign
     566 000001b4                   HST_Obj 1, RTA_fromHost, 1, _mode, _buf, _framesize, _numframes, _stsflg, _notify, _arg0, _arg
1                           
1                                   .if (1 = 0)
1                                       .mexit
1                                   .endif
1                            
1        000001b4                   CHK_nargs "HST_Obj", lnktype 
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "HST_Obj lnktype error"
1                                   .endif
1                            
1        000001b4                   CHK_domain HST_Obj, mode, "output,input", "output"
2                           
1                                   .asg "input", mode
1                                   .if ($symcmp("input", "error") = 0)
1                                       .emsg "HST_Obj mode error"
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   50

1                                   .endif
1                            
1                                   .global RTA_fromHost, RTA_fromHost$buf, RTA_fromHost$rtdx
1                            
1                                   .if ($symcmp("<NULL>", "<NULL>") = 0)
1        000001b4                       GBL_Obj RTA_fromHost$buf, 04H*01H, .hst1
2        000001b4                   CHK_domain "GBL_Obj", alignFlag, "noalign,align", "noalign"
3                                       .mexit
3                                           
3                           
3                           
2                                   .if ($symcmp("noalign", "error") = 0)
2                                       .emsg "GBL_Obj align parameter error."
2                                   .endif
2                                   .asg "noalign", alignFlag
2                           
2        000001b4                   CHK_nargs "GBL_Obj", size
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "GBL_Obj size parameter error."
2                                   .endif
2                           
2                                   .if ($symlen(section) = 0)
2                                       .asg ".bss", section
2                                   .endif
2                           
2                                   .if ($symlen(fillValue) != 0)
2                                       .sect ".gblinit"
2                                       .word :size:
2                                       .word :name:
2                                       .word :fillValue:
2                                   .endif
2                           
2                                   .if (($symcmp(section, ".data") = 0) | ($symcmp(alignFlag, "align") = 0))
2                                       .sect ":section:"
2                                       .if ($symcmp(alignFlag, "align") = 0)
2                                           .align  :alignValue:
2                                       .endif
2                           :name::
2                                       ;
2                                       ; Can't use .space directive here because it reserves
2                                       ; bits for some processors and bytes for others.
2                                       ;
2                                       .loop       :size:
2                                           .word 0
2                                       .endloop
2                           
2                                   .elseif ($symcmp(".hst1", ".bss") = 0)
2                                       .bss :name:, :size: * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS / STD_TARGC
2                                   .else
2        00000000           RTA_fromHost$buf:     .usect ".hst1", 04H*01H * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMA
2                                   .endif
2                           
1                                       .asg    RTA_fromHost$buf, buf
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   51

1                                   .if (00H == 0)
1                                       .asg "none",stsType
1                                   .else
1                                       .if ($symcmp(":mode:","input") == 0)
1                                           .asg "reader",stsType
1                                       .else
1                                           .asg "writer",stsType
1                                       .endif
1                                   .endif
1                            
1                                   ; set first word of HST_Obj table to size of individual HST objects
1                           
1                                   .asg    0, chanId
1                           
1                                   .if 0 = 0
1                           
1        00000000           RTA_fromHost$objsize    .usect ".hst", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS 
1                           
1        000001b4                       .sect ".cinit"
1                           
1                                       .align 8
1                           
1        000001b8 00000004              .field STD_TARGWORDMAUS * 1
1                           
1        000001bc 00000000-             .field RTA_fromHost$objsize   
1                           
1                                       .if ($symcmp("RTDX","RTDX") == 0)
1        000001c0 00000014                  .field 5 * STD_TARGWORDMAUS
1                                       .else
1                                           .field 2 * STD_TARGWORDMAUS
1                                       .endif
1                           
1                                   .endif
1                           
1        00000004           RTA_fromHost    .usect ".hst", STD_TARGWORDMAUS * 2, STD_TARGWORDMAUS 
1                            
1        000001c4                   .sect ".cinit"
1                           
1                                   .align  8
1        000001c8 00000008          .field  STD_TARGWORDMAUS * 2
1        000001cc 00000004-         .field  RTA_fromHost    
1        000001d0 00000001          .field  1<<0    ; mask 
1        000001d4 00000000-         .field  RTA_fromHost$pipe       ; pipe
1                           
1                                   .if ($symcmp("RTDX","RTDX") == 0)
1                           
1                                       ; allocate RTDX_channel
1        0000000c           RTA_fromHost$rtdx .usect ".hst", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS 
1                           
1        000001d8                       .sect ".cinit"
1                           
1                                       .align 8
1                           
1        000001d8 0000000C              .field STD_TARGWORDMAUS * 3
1        000001dc 0000000C-             .field RTA_fromHost$rtdx    
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   52

1        000001e0 00000000              .field 0                    ; enabled = 0
1        000001e4 00000000              .field 0                    ; count = 0
1        000001e8 00000000              .field 0                    ; busy = 0
1                           
1                                   .endif
1                           
1                                   .if ($symcmp("input","output") == 0)
1                                           PIP_Obj 1, :name:$pipe, -1, :name:$buf, framesize, numframes, :stsType:, fxn, arg0, ar
1                                   .endif
1                            
1                                   .if ($symcmp("input","input") == 0)
1        000001ec                           PIP_Obj 1, RTA_fromHost$pipe, -1, RTA_fromHost$buf, framesize, numframes, none, RTA_F_
2                           
2                                   .global RTA_fromHost$pipe, RTA_fromHost$pipe$rd, RTA_fromHost$pipe$wr, RTA_fromHost$pipe$dtab
2                                   .global RTA_fromHost$pipe$aaa, RTA_fromHost$pipe$bbb
2                                   .asg   0,bufAlloc
2                                   .eval 0, newframesize
2                           
2                                   .eval 04H * (STD_TARGWORDMAUS/STD_TARGCHARMAUS), newframesize
2                                   ; Convert framesize to bytes which is needed since align value is
2                                   ; already in bytes.
2                           
2                                   .eval (16 + (04H - 1)) & ( ~(04H - 1)), newframesize
2                                   ; 16 is equal to multiple of 04H. This is needed
2                                   ; for all the frames to start at 'align'ed boundary from the start
2                                   ; of pip frames section. Note that pip frames section will also
2                                   ; start from 'align'ed boundary.
2                           
2                                   .if (1 = 0)
2                                       .mexit
2                                   .endif
2                           
2                                   .if ($symcmp("RTA_fromHost$buf", "<NULL>") = 0)
2                                       .eval       0, count
2                                       .asg        :name:$buf:count:, buf
2                                       .loop
2                                           .break (count == :numframes: - 1 )
2                                           .global :name:$buf:count:
2                           :name:$buf:count:       .usect ".pip:id:", :newframesize: 
2                                           .asg    :name:$buf:count:, buf:count:
2                                           .eval   count + 1, count
2                                       .endloop
2                                   
2                                       ; Last frame in the PIP buffers should start at align boundary
2                                       ; but the size of last PIP buffer need not be multiple of
2                                       ; :align:. Because there are no more frames left to start at align
2                                       ; boundary. Hence last frame is usect'd with the default
2                                       ; framesize.
2                                       .global     :name:$buf:count:
2                           :name:$buf:count:       .usect ".pip:id:", :framesize: * (STD_TARGWORDMAUS/STD_TARGCHARMAUS) 
2                                       .asg        :name:$buf:count:, buf:count:
2                           
2                                       .eval       1, bufAlloc
2                                   .endif
2                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   53

2        00000000           RTA_fromHost$pipe       .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        000001ec                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        000001f0 00000004          .field  STD_TARGWORDMAUS * 1
2        000001f4 00000000-         .field  RTA_fromHost$pipe
2        000001f8 00000004          .field  04H             ; thresh
2                           
2        00000004           RTA_fromHost$pipe$rd .usect ".pip", STD_TARGWORDMAUS * 8, STD_TARGWORDMAUS
2                           
2        000001fc                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000200 00000020          .field  STD_TARGWORDMAUS * 8
2        00000204 00000004-         .field RTA_fromHost$pipe$rd
2        00000208 00000000          .field  0                       ; reader take-probe
2        0000020c 00000000          .field  0                       ; reader addr
2        00000210 00000004          .field  04H             ; reader size
2        00000214 00000018-         .field  RTA_fromHost$pipe$dtab             ; reader curdesc
2        00000218 00000054-         .field  RTA_fromHost$pipe$wr+PIP_O_FXNOBJ  ; reader pfxnobj
2        0000021c 00000000          .field  0                       ; reader numframes
2        00000220 00000000          .field  0                       ; reader give-probe
2        00000224 00000048-         .field  RTA_fromHost$pipe$wr+PIP_O_NUMFRAMES       ; reader pnumframes
2                           
2        00000228                   FXN_Obj RTA_fromHost$pipe$rdfxn, RTA_F_or, LNK_dspFrameRequestMask, 1<<0, ".pip"
3        00000228               CHK_nargs "FXN_Obj", section
3                               .if ($symcmp("", "error") = 0)
3                                   .emsg "FXN_Obj parameter error"
3                               .endif
3                           
3                           RTA_fromHost$pipe$rdfxn  .tag    FXN_Obj
3                           
3        00000024           RTA_fromHost$pipe$rdfxn .usect ".pip", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
3                           
3        00000228                   .sect ".cinit"
3                           
3                                   .align 8
3        00000228 0000000C          .field  STD_TARGWORDMAUS * 3
3        0000022c 00000024-         .field RTA_fromHost$pipe$rdfxn
3        00000230 00000000!         .field  RTA_F_or          ; fxn
3        00000234 00000001          .field  1<<0         ; arg1
3        00000238 00000000!         .field  LNK_dspFrameRequestMask         ; arg0
3                           
2                           
2        00000030           RTA_fromHost$pipe$aaa .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000023c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000240 00000004          .field  STD_TARGWORDMAUS * 1
2        00000244 00000030-         .field RTA_fromHost$pipe$aaa
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   54

2                                   .if ($symcmp("none", "reader") = 0)
2                                       .field :name:$sts
2                                   .else
2        00000248 00000000              .field 0
2                                   .endif
2                           
2        00000034           RTA_fromHost$pipe$wr .usect ".pip", STD_TARGWORDMAUS * 8, STD_TARGWORDMAUS
2                           
2        0000024c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000250 00000020          .field  STD_TARGWORDMAUS * 8
2        00000254 00000034-         .field RTA_fromHost$pipe$wr
2        00000258 00000000          .field  0                       ; writer take-probe
2        0000025c 00000000          .field  0                       ; writer addr
2        00000260 00000004          .field  04H             ; writer size
2        00000264 00000018-         .field  RTA_fromHost$pipe$dtab             ; writer curdesc
2        00000268 00000024-         .field  RTA_fromHost$pipe$rd+PIP_O_FXNOBJ  ; writer pfxnobj
2        0000026c 00000001          .field  01H             ; writer numframes
2        00000270 00000000          .field  0                       ; writer give-probe
2        00000274 00000018-         .field  RTA_fromHost$pipe$rd+PIP_O_NUMFRAMES       ; writer pnumframes
2                           
2        00000278                   FXN_Obj RTA_fromHost$pipe$wrfxn, _FXN_F_nop, 00H, 00H, ".pip"
3        00000278               CHK_nargs "FXN_Obj", section
3                               .if ($symcmp("", "error") = 0)
3                                   .emsg "FXN_Obj parameter error"
3                               .endif
3                           
3                           RTA_fromHost$pipe$wrfxn  .tag    FXN_Obj
3                           
3        00000054           RTA_fromHost$pipe$wrfxn .usect ".pip", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
3                           
3        00000278                   .sect ".cinit"
3                           
3                                   .align 8
3        00000278 0000000C          .field  STD_TARGWORDMAUS * 3
3        0000027c 00000054-         .field RTA_fromHost$pipe$wrfxn
3        00000280 00000000!         .field  _FXN_F_nop          ; fxn
3        00000284 00000000          .field  00H         ; arg1
3        00000288 00000000          .field  00H         ; arg0
3                           
2                           
2        00000060           RTA_fromHost$pipe$bbb .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000028c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000290 00000004          .field  STD_TARGWORDMAUS * 1
2        00000294 00000060-         .field RTA_fromHost$pipe$bbb
2                                   .if ($symcmp("none", "writer") = 0)
2                                       .field      :name:$sts
2                                   .else
2        00000298 00000000              .field      0
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   55

2                                   .endif
2                           
2                                   ;
2                                   ; put PIP descriptors into .bss section
2                                   ;
2                                   ;   addr[i]
2                                   ;   size[i]
2                                   ;   next[i]
2                                   ;
2                                   .global RTA_fromHost$pipe$dtab
2                           
2        00000018                   .bss RTA_fromHost$pipe$dtab, (3 * STD_TARGWORDMAUS * 01H), STD_TARGWORDMAUS
2                           
2        0000029c                   .sect ".cinit"
2                           
2                                   .var    temp0, temp1, boff
2                                   .eval   0, temp0
2                                   .eval   0, temp1
2                                   .eval   0, boff
2                                   .eval   01H * (3 * STD_TARGWORDMAUS), temp0
2                           
2                                   .align 8
2                           
2        000002a0 0000000C          .field  12
2                           
2        000002a4 00000018-         .field RTA_fromHost$pipe$dtab
2                           
2                                   .eval   3 * STD_TARGWORDMAUS, temp1
2                           
2                                   .eval   0, count
2                                   .loop   01H-1
2                                       .field :buf:+:boff:                 ; addr[i]
2                                       .field :framesize:                  ; size[i]
2                                       .field :name:$dtab + :temp1:        ; next[i]
2                           
2                                       .if :bufAlloc:
2                                           .eval count + 1, count
2                                           .asg  buf:count:, buf
2                                       .else
2                                           .eval :boff:+(:framesize: * (STD_TARGWORDMAUS)), boff
2                                       .endif
2                                       .eval :temp1: + (3 * STD_TARGWORDMAUS), temp1
2                                   .endloop
2                                       
2        000002a8 00000000-         .field RTA_fromHost$buf+0       ; addr[n]
2        000002ac 00000004          .field 04H      ; size[n]
2        000002b0 00000018-         .field RTA_fromHost$pipe$dtab   ; next[n]
2                           
2                                   .if ($symcmp("none", "reader") = 0)
2                                           STS_Obj 1, :name:$sts, 0, 0, 0
2                                   .endif
2                           
2                                   .if ($symcmp("none", "writer") = 0)
2                                           STS_Obj 1, :name:$sts, 0, 0, 0
2                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   56

2                           
1                                   .endif
1                           
1                                   .eval 0 + 1, HST$hstCount
1                           
     567                    
     568                    ;; ======== HST_Obj RTA_toHost ========
     569                    ;; Used to access LOG and STS data
     570                    ;;
     571                    ;; HST_Obj RTA_toHost (mode, buf, framesize, numframes, stsflg, notify, arg0, arg1, lnk, bufFrameAlign
     572                            .global RTA_toHost
     573                            .asg "output", _mode
     574                            .asg "<NULL>", _buf
     575                            .asg 040H, _framesize
     576                            .asg 01H, _numframes
     577                            .asg 00H, _stsflg
     578                            .asg _FXN_F_nop, _notify
     579                            .asg 00H, _arg0
     580                            .asg 00H, _arg1
     581                            .asg "RTDX", _lnk
     582                            .asg 04H, _bufFrameAlign
     583 000002b4                   HST_Obj 1, RTA_toHost, 0, _mode, _buf, _framesize, _numframes, _stsflg, _notify, _arg0, _arg1,
1                           
1                                   .if (1 = 0)
1                                       .mexit
1                                   .endif
1                            
1        000002b4                   CHK_nargs "HST_Obj", lnktype 
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "HST_Obj lnktype error"
1                                   .endif
1                            
1        000002b4                   CHK_domain HST_Obj, mode, "output,input", "output"
2                           
1                                   .asg "output", mode
1                                   .if ($symcmp("output", "error") = 0)
1                                       .emsg "HST_Obj mode error"
1                                   .endif
1                            
1                                   .global RTA_toHost, RTA_toHost$buf, RTA_toHost$rtdx
1                            
1                                   .if ($symcmp("<NULL>", "<NULL>") = 0)
1        000002b4                       GBL_Obj RTA_toHost$buf, 040H*01H, .hst0
2        000002b4                   CHK_domain "GBL_Obj", alignFlag, "noalign,align", "noalign"
3                                       .mexit
3                                           
3                           
3                           
2                                   .if ($symcmp("noalign", "error") = 0)
2                                       .emsg "GBL_Obj align parameter error."
2                                   .endif
2                                   .asg "noalign", alignFlag
2                           
2        000002b4                   CHK_nargs "GBL_Obj", size
2                                   .if ($symcmp("", "error") = 0)
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   57

2                                       .emsg "GBL_Obj size parameter error."
2                                   .endif
2                           
2                                   .if ($symlen(section) = 0)
2                                       .asg ".bss", section
2                                   .endif
2                           
2                                   .if ($symlen(fillValue) != 0)
2                                       .sect ".gblinit"
2                                       .word :size:
2                                       .word :name:
2                                       .word :fillValue:
2                                   .endif
2                           
2                                   .if (($symcmp(section, ".data") = 0) | ($symcmp(alignFlag, "align") = 0))
2                                       .sect ":section:"
2                                       .if ($symcmp(alignFlag, "align") = 0)
2                                           .align  :alignValue:
2                                       .endif
2                           :name::
2                                       ;
2                                       ; Can't use .space directive here because it reserves
2                                       ; bits for some processors and bytes for others.
2                                       ;
2                                       .loop       :size:
2                                           .word 0
2                                       .endloop
2                           
2                                   .elseif ($symcmp(".hst0", ".bss") = 0)
2                                       .bss :name:, :size: * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS / STD_TARGC
2                                   .else
2        00000000           RTA_toHost$buf:     .usect ".hst0", 040H*01H * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAU
2                                   .endif
2                           
1                                       .asg    RTA_toHost$buf, buf
1                                   .endif
1                           
1                                   .if (00H == 0)
1                                       .asg "none",stsType
1                                   .else
1                                       .if ($symcmp(":mode:","input") == 0)
1                                           .asg "reader",stsType
1                                       .else
1                                           .asg "writer",stsType
1                                       .endif
1                                   .endif
1                            
1                                   ; set first word of HST_Obj table to size of individual HST objects
1                           
1                                   .asg    1, chanId
1                           
1                                   .if 1 = 0
1                           
1                           :name:$objsize  .usect ".hst", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS 
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   58

1                                       .sect ".cinit"
1                           
1                                       .align 8
1                           
1                                       .field STD_TARGWORDMAUS * 1
1                           
1                                       .field :name:$objsize   
1                           
1                                       .if ($symcmp(":lnktype:","RTDX") == 0)
1                                           .field 5 * STD_TARGWORDMAUS
1                                       .else
1                                           .field 2 * STD_TARGWORDMAUS
1                                       .endif
1                           
1                                   .endif
1                           
1        00000018           RTA_toHost      .usect ".hst", STD_TARGWORDMAUS * 2, STD_TARGWORDMAUS 
1                            
1        000002b4                   .sect ".cinit"
1                           
1                                   .align  8
1        000002b8 00000008          .field  STD_TARGWORDMAUS * 2
1        000002bc 00000018-         .field  RTA_toHost    
1        000002c0 00000002          .field  1<<1    ; mask 
1        000002c4 00000064-         .field  RTA_toHost$pipe         ; pipe
1                           
1                                   .if ($symcmp("RTDX","RTDX") == 0)
1                           
1                                       ; allocate RTDX_channel
1        00000020           RTA_toHost$rtdx .usect ".hst", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS 
1                           
1        000002c8                       .sect ".cinit"
1                           
1                                       .align 8
1                           
1        000002c8 0000000C              .field STD_TARGWORDMAUS * 3
1        000002cc 00000020-             .field RTA_toHost$rtdx    
1        000002d0 00000000              .field 0                    ; enabled = 0
1        000002d4 00000000              .field 0                    ; count = 0
1        000002d8 00000000              .field 0                    ; busy = 0
1                           
1                                   .endif
1                           
1                                   .if ($symcmp("output","output") == 0)
1        000002dc                           PIP_Obj 1, RTA_toHost$pipe, -1, RTA_toHost$buf, framesize, numframes, none, fxn, arg0,
2                           
2                                   .global RTA_toHost$pipe, RTA_toHost$pipe$rd, RTA_toHost$pipe$wr, RTA_toHost$pipe$dtab
2                                   .global RTA_toHost$pipe$aaa, RTA_toHost$pipe$bbb
2                                   .asg   0,bufAlloc
2                                   .eval 0, newframesize
2                           
2                                   .eval 040H * (STD_TARGWORDMAUS/STD_TARGCHARMAUS), newframesize
2                                   ; Convert framesize to bytes which is needed since align value is
2                                   ; already in bytes.
2                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   59

2                                   .eval (256 + (04H - 1)) & ( ~(04H - 1)), newframesize
2                                   ; 256 is equal to multiple of 04H. This is needed
2                                   ; for all the frames to start at 'align'ed boundary from the start
2                                   ; of pip frames section. Note that pip frames section will also
2                                   ; start from 'align'ed boundary.
2                           
2                                   .if (1 = 0)
2                                       .mexit
2                                   .endif
2                           
2                                   .if ($symcmp("RTA_toHost$buf", "<NULL>") = 0)
2                                       .eval       0, count
2                                       .asg        :name:$buf:count:, buf
2                                       .loop
2                                           .break (count == :numframes: - 1 )
2                                           .global :name:$buf:count:
2                           :name:$buf:count:       .usect ".pip:id:", :newframesize: 
2                                           .asg    :name:$buf:count:, buf:count:
2                                           .eval   count + 1, count
2                                       .endloop
2                                   
2                                       ; Last frame in the PIP buffers should start at align boundary
2                                       ; but the size of last PIP buffer need not be multiple of
2                                       ; :align:. Because there are no more frames left to start at align
2                                       ; boundary. Hence last frame is usect'd with the default
2                                       ; framesize.
2                                       .global     :name:$buf:count:
2                           :name:$buf:count:       .usect ".pip:id:", :framesize: * (STD_TARGWORDMAUS/STD_TARGCHARMAUS) 
2                                       .asg        :name:$buf:count:, buf:count:
2                           
2                                       .eval       1, bufAlloc
2                                   .endif
2                           
2        00000064           RTA_toHost$pipe .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        000002dc                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        000002e0 00000004          .field  STD_TARGWORDMAUS * 1
2        000002e4 00000064-         .field  RTA_toHost$pipe
2        000002e8 00000040          .field  040H             ; thresh
2                           
2        00000068           RTA_toHost$pipe$rd .usect ".pip", STD_TARGWORDMAUS * 8, STD_TARGWORDMAUS
2                           
2        000002ec                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        000002f0 00000020          .field  STD_TARGWORDMAUS * 8
2        000002f4 00000068-         .field RTA_toHost$pipe$rd
2        000002f8 00000000          .field  0                       ; reader take-probe
2        000002fc 00000000          .field  0                       ; reader addr
2        00000300 00000040          .field  040H             ; reader size
2        00000304 00000024-         .field  RTA_toHost$pipe$dtab             ; reader curdesc
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   60

2        00000308 000000B8-         .field  RTA_toHost$pipe$wr+PIP_O_FXNOBJ  ; reader pfxnobj
2        0000030c 00000000          .field  0                       ; reader numframes
2        00000310 00000000          .field  0                       ; reader give-probe
2        00000314 000000AC-         .field  RTA_toHost$pipe$wr+PIP_O_NUMFRAMES       ; reader pnumframes
2                           
2        00000318                   FXN_Obj RTA_toHost$pipe$rdfxn, _FXN_F_nop, 00H, 00H, ".pip"
3        00000318               CHK_nargs "FXN_Obj", section
3                               .if ($symcmp("", "error") = 0)
3                                   .emsg "FXN_Obj parameter error"
3                               .endif
3                           
3                           RTA_toHost$pipe$rdfxn  .tag    FXN_Obj
3                           
3        00000088           RTA_toHost$pipe$rdfxn   .usect ".pip", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
3                           
3        00000318                   .sect ".cinit"
3                           
3                                   .align 8
3        00000318 0000000C          .field  STD_TARGWORDMAUS * 3
3        0000031c 00000088-         .field RTA_toHost$pipe$rdfxn
3        00000320 00000000!         .field  _FXN_F_nop          ; fxn
3        00000324 00000000          .field  00H         ; arg1
3        00000328 00000000          .field  00H         ; arg0
3                           
2                           
2        00000094           RTA_toHost$pipe$aaa .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000032c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000330 00000004          .field  STD_TARGWORDMAUS * 1
2        00000334 00000094-         .field RTA_toHost$pipe$aaa
2                                   .if ($symcmp("none", "reader") = 0)
2                                       .field :name:$sts
2                                   .else
2        00000338 00000000              .field 0
2                                   .endif
2                           
2        00000098           RTA_toHost$pipe$wr .usect ".pip", STD_TARGWORDMAUS * 8, STD_TARGWORDMAUS
2                           
2        0000033c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000340 00000020          .field  STD_TARGWORDMAUS * 8
2        00000344 00000098-         .field RTA_toHost$pipe$wr
2        00000348 00000000          .field  0                       ; writer take-probe
2        0000034c 00000000          .field  0                       ; writer addr
2        00000350 00000040          .field  040H             ; writer size
2        00000354 00000024-         .field  RTA_toHost$pipe$dtab             ; writer curdesc
2        00000358 00000088-         .field  RTA_toHost$pipe$rd+PIP_O_FXNOBJ  ; writer pfxnobj
2        0000035c 00000001          .field  01H             ; writer numframes
2        00000360 00000000          .field  0                       ; writer give-probe
2        00000364 0000007C-         .field  RTA_toHost$pipe$rd+PIP_O_NUMFRAMES       ; writer pnumframes
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   61

2                           
2        00000368                   FXN_Obj RTA_toHost$pipe$wrfxn, RTA_F_or, LNK_dspFrameReadyMask, 1<<1, ".pip"
3        00000368               CHK_nargs "FXN_Obj", section
3                               .if ($symcmp("", "error") = 0)
3                                   .emsg "FXN_Obj parameter error"
3                               .endif
3                           
3                           RTA_toHost$pipe$wrfxn  .tag    FXN_Obj
3                           
3        000000b8           RTA_toHost$pipe$wrfxn   .usect ".pip", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
3                           
3        00000368                   .sect ".cinit"
3                           
3                                   .align 8
3        00000368 0000000C          .field  STD_TARGWORDMAUS * 3
3        0000036c 000000B8-         .field RTA_toHost$pipe$wrfxn
3        00000370 00000000!         .field  RTA_F_or          ; fxn
3        00000374 00000002          .field  1<<1         ; arg1
3        00000378 00000000!         .field  LNK_dspFrameReadyMask         ; arg0
3                           
2                           
2        000000c4           RTA_toHost$pipe$bbb .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000037c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000380 00000004          .field  STD_TARGWORDMAUS * 1
2        00000384 000000C4-         .field RTA_toHost$pipe$bbb
2                                   .if ($symcmp("none", "writer") = 0)
2                                       .field      :name:$sts
2                                   .else
2        00000388 00000000              .field      0
2                                   .endif
2                           
2                                   ;
2                                   ; put PIP descriptors into .bss section
2                                   ;
2                                   ;   addr[i]
2                                   ;   size[i]
2                                   ;   next[i]
2                                   ;
2                                   .global RTA_toHost$pipe$dtab
2                           
2        00000024                   .bss RTA_toHost$pipe$dtab, (3 * STD_TARGWORDMAUS * 01H), STD_TARGWORDMAUS
2                           
2        0000038c                   .sect ".cinit"
2                           
2                                   .var    temp0, temp1, boff
2                                   .eval   0, temp0
2                                   .eval   0, temp1
2                                   .eval   0, boff
2                                   .eval   01H * (3 * STD_TARGWORDMAUS), temp0
2                           
2                                   .align 8
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   62

2                           
2        00000390 0000000C          .field  12
2                           
2        00000394 00000024-         .field RTA_toHost$pipe$dtab
2                           
2                                   .eval   3 * STD_TARGWORDMAUS, temp1
2                           
2                                   .eval   0, count
2                                   .loop   01H-1
2                                       .field :buf:+:boff:                 ; addr[i]
2                                       .field :framesize:                  ; size[i]
2                                       .field :name:$dtab + :temp1:        ; next[i]
2                           
2                                       .if :bufAlloc:
2                                           .eval count + 1, count
2                                           .asg  buf:count:, buf
2                                       .else
2                                           .eval :boff:+(:framesize: * (STD_TARGWORDMAUS)), boff
2                                       .endif
2                                       .eval :temp1: + (3 * STD_TARGWORDMAUS), temp1
2                                   .endloop
2                                       
2        00000398 00000000-         .field RTA_toHost$buf+0 ; addr[n]
2        0000039c 00000040          .field 040H     ; size[n]
2        000003a0 00000024-         .field RTA_toHost$pipe$dtab     ; next[n]
2                           
2                                   .if ($symcmp("none", "reader") = 0)
2                                           STS_Obj 1, :name:$sts, 0, 0, 0
2                                   .endif
2                           
2                                   .if ($symcmp("none", "writer") = 0)
2                                           STS_Obj 1, :name:$sts, 0, 0, 0
2                                   .endif
2                           
1                                   .endif
1                            
1                                   .if ($symcmp("output","input") == 0)
1                                           PIP_Obj 1, :name:$pipe, -1, :name:$buf, framesize, numframes, :stsType:, RTA_F_or, LNK
1                                   .endif
1                           
1                                   .eval 1 + 1, HST$hstCount
1                           
     584                    
     585                    ;; ======== HWI_Obj HWI_RESET ========
     586                    ;; defines function for the RESET ISR
     587                    ;;
     588                    ;; HWI_Obj HWI_RESET (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     589                            .global HWI_RESET
     590                            .asg _c_int00, _function
     591                            .asg "Nothing", _monitor
     592                            .asg 00H, _addr
     593                            .asg "signed", _dataType
     594                            .asg "STS_add(*addr)", _operation
     595                            .asg "USER", _client
     596                            .asg 00H, _iUseDispatcher
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   63

     597                            .asg 00H, _iArg
     598                            .asg 01H, _IntrMask
     599                            .asg 01H, _iCCBitMask
     600 000003a4                   HWI_Obj 1, HWI_RESET, 0, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDisp
1        000003a4                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_RESET, _c_int00
1                           
1                                   .if (1 != 0)
1                 00000000  HWI_RESET               .set    0
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi0, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (0 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    _c_int00, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("_c_int00", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (0 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg _c_int00, vector    ; vector = user specified fxn
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   64

1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000000                   .sect ".hwi_vec"
1                                   .global hwi0
1                           hwi0:
1                                   .if ((0 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1        00000000 0000002A!             mvkl _c_int00,b0    ; load destination function address to b0
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   65

1        00000004 0000006A!             mvkh _c_int00,b0
1        00000008 00000362              b b0                ; start branch to destination function  
1        0000000c 0000A35A              zero b0             ; disable interrupts by clearing 'IER'
1        00000010 020003A2              mvc b0,ier
1        00000014 00000000              nop                 ; fill delay slot, pad packet
1        00000018 00000000              nop                 ; fill delay slot, pad packet
1        0000001c 00000000              nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (0 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   66

1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   67

1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     601                    
     602                    ;; ======== HWI_Obj HWI_NMI ========
     603                    ;; defines function for the NMI ISR
     604                    ;;
     605                    ;; HWI_Obj HWI_NMI (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrMa
     606                            .global HWI_NMI
     607                            .asg HWI_unused, _function
     608                            .asg "Nothing", _monitor
     609                            .asg 00H, _addr
     610                            .asg "signed", _dataType
     611                            .asg "STS_add(*addr)", _operation
     612                            .asg "USER", _client
     613                            .asg 00H, _iUseDispatcher
     614                            .asg 00H, _iArg
     615                            .asg 02H, _IntrMask
     616                            .asg 01H, _iCCBitMask
     617 00000020                   HWI_Obj 1, HWI_NMI, 1, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispat
1        00000020                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_NMI, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000001  HWI_NMI         .set    1
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi1, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   68

1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (1 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   69

1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000020                   .sect ".hwi_vec"
1                                   .global hwi1
1                           hwi1:
1                                   .if ((1 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (1 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   70

1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000020           spin?
1        00000020 00000012              b spin?             ; nested branches to block interrupts
1        00000024 00006000              nop 4
1        00000028 00000012              b spin?
1        0000002c 00000000              nop
1        00000030 00000000              nop
1        00000034 00000000              nop
1        00000038 00000000              nop
1        0000003c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   71

1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     618                    
     619                    ;; ======== HWI_Obj HWI_RESERVED0 ========
     620                    ;; RESERVED for RTDX
     621                    ;;
     622                    ;; HWI_Obj HWI_RESERVED0 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, 
     623                            .global HWI_RESERVED0
     624                            .asg RESERVED, _function
     625                            .asg "Nothing", _monitor
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   72

     626                            .asg 00H, _addr
     627                            .asg "signed", _dataType
     628                            .asg "STS_add(*addr)", _operation
     629                            .asg "RTDX", _client
     630                            .asg 00H, _iUseDispatcher
     631                            .asg 00H, _iArg
     632                            .asg 04H, _IntrMask
     633                            .asg 01H, _iCCBitMask
     634 00000040                   HWI_Obj 1, HWI_RESERVED0, 2, _function, _monitor, _addr, _dataType, _operation, _client, _iUse
1        00000040                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_RESERVED0, RESERVED
1                           
1                                   .if (1 != 0)
1                 00000002  HWI_RESERVED0           .set    2
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi2, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (RTDX$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (2 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    RESERVED, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("RESERVED", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (1 = 1))
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   73

1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg RESERVED, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000040                   .sect ".hwi_vec"
1                                   .global hwi2
1                           hwi2:
1                                   .if ((2 == 0))
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   74

1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (2 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1        00000040           spin?
1        00000040 00000012                  b spin?         ; nested branches to block interrupts
1        00000044 00006000                  nop 4
1        00000048 00000012                  b spin?
1        0000004c 00000000                  nop
1        00000050 00000000                  nop
1        00000054 00000000                  nop
1        00000058 00000000                  nop
1        0000005c 00000000                  nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   75

1                                       nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   76

1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     635                    
     636                    ;; ======== HWI_Obj HWI_RESERVED1 ========
     637                    ;; RESERVED for RTDX
     638                    ;;
     639                    ;; HWI_Obj HWI_RESERVED1 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, 
     640                            .global HWI_RESERVED1
     641                            .asg _RTDX_Poll, _function
     642                            .asg "Nothing", _monitor
     643                            .asg 00H, _addr
     644                            .asg "signed", _dataType
     645                            .asg "STS_add(*addr)", _operation
     646                            .asg "RTDX", _client
     647                            .asg 01H, _iUseDispatcher
     648                            .asg 00H, _iArg
     649                            .asg 08H, _IntrMask
     650                            .asg 01H, _iCCBitMask
     651 00000060                   HWI_Obj 1, HWI_RESERVED1, 3, _function, _monitor, _addr, _dataType, _operation, _client, _iUse
1        00000060                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_RESERVED1, _RTDX_Poll
1                           
1                                   .if (1 != 0)
1                 00000003  HWI_RESERVED1           .set    3
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi3, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   77

1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (RTDX$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (3 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    01H, local_dispatch
1                                   .asg    _RTDX_Poll, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("_RTDX_Poll", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (1 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg _RTDX_Poll, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   78

1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000060                   .sect ".hwi_vec"
1                                   .global hwi3
1                           hwi3:
1                                   .if ((3 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (3 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   79

1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!01H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
1                                   .else
1                                       .if ( 01H )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp("_RTDX_Poll", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   80

1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        _RTDX_Poll, dispatch_fxn
1                           
1                                           .endif
1                                           
1        00000060 003C54F6                  stw     b0, *b15--[2]
1        00000064 000CA35A                  mvk     3, b0
1        00000068 003C22F6                  stw     b0, *+b15[1]
1        0000006c 0000002A!                 mvkl    HWI_F_dispatch, b0
1        00000070 0000006A!                 mvkh    HWI_F_dispatch, b0
1        00000074 00000362                  b       b0
1        00000078 003C42E6                  ldw     *+b15[2], b0
1        0000007c 00006000                  nop     4
1                           
1        000003a4                           .sect   ".cinit"
1                                           .align  8
1        000003a8 00000010                  .field  4 * STD_TARGWORDMAUS
1        000003ac 00000030!                 .field  _HWI_dispatchTab + (4 * 3 * STD_TARGWORDMAUS)
1        000003b0 00000000!                 .field  _RTDX_Poll
1        000003b4 00000008                  .field  08H
1        000003b8 00000001                  .field  01H
1        000003bc 00000000                  .field  00H
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     652                    
     653                    ;; ======== HWI_Obj HWI_INT4 ========
     654                    ;; defines the INT4 Interrupt
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   81

     655                    ;;
     656                    ;; HWI_Obj HWI_INT4 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     657                            .global HWI_INT4
     658                            .asg HWI_unused, _function
     659                            .asg "Nothing", _monitor
     660                            .asg 00H, _addr
     661                            .asg "signed", _dataType
     662                            .asg "STS_add(*addr)", _operation
     663                            .asg "USER", _client
     664                            .asg 00H, _iUseDispatcher
     665                            .asg 00H, _iArg
     666                            .asg 010H, _IntrMask
     667                            .asg 01H, _iCCBitMask
     668 000003c0                   HWI_Obj 1, HWI_INT4, 4, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        000003c0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT4, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000004  HWI_INT4                .set    4
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi4, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (4 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   82

1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   83

1        00000080                   .sect ".hwi_vec"
1                                   .global hwi4
1                           hwi4:
1                                   .if ((4 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (4 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000080           spin?
1        00000080 00000012              b spin?             ; nested branches to block interrupts
1        00000084 00006000              nop 4
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   84

1        00000088 00000012              b spin?
1        0000008c 00000000              nop
1        00000090 00000000              nop
1        00000094 00000000              nop
1        00000098 00000000              nop
1        0000009c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   85

1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     669                    
     670                    ;; ======== HWI_Obj HWI_INT5 ========
     671                    ;; defines the INT5 Interrupt
     672                    ;;
     673                    ;; HWI_Obj HWI_INT5 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     674                            .global HWI_INT5
     675                            .asg HWI_unused, _function
     676                            .asg "Nothing", _monitor
     677                            .asg 00H, _addr
     678                            .asg "signed", _dataType
     679                            .asg "STS_add(*addr)", _operation
     680                            .asg "USER", _client
     681                            .asg 00H, _iUseDispatcher
     682                            .asg 00H, _iArg
     683                            .asg 020H, _IntrMask
     684                            .asg 01H, _iCCBitMask
     685 000000a0                   HWI_Obj 1, HWI_INT5, 5, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        000000a0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT5, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000005  HWI_INT5                .set    5
1                                   .endif
1                                   
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   86

1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi5, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (5 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   87

1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000000a0                   .sect ".hwi_vec"
1                                   .global hwi5
1                           hwi5:
1                                   .if ((5 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (5 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   88

1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000000a0           spin?
1        000000a0 00000012              b spin?             ; nested branches to block interrupts
1        000000a4 00006000              nop 4
1        000000a8 00000012              b spin?
1        000000ac 00000000              nop
1        000000b0 00000000              nop
1        000000b4 00000000              nop
1        000000b8 00000000              nop
1        000000bc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   89

1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   90

1                                   .endif
1                                   
     686                    
     687                    ;; ======== HWI_Obj HWI_INT6 ========
     688                    ;; defines the INT6 Interrupt
     689                    ;;
     690                    ;; HWI_Obj HWI_INT6 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     691                            .global HWI_INT6
     692                            .asg HWI_unused, _function
     693                            .asg "Nothing", _monitor
     694                            .asg 00H, _addr
     695                            .asg "signed", _dataType
     696                            .asg "STS_add(*addr)", _operation
     697                            .asg "USER", _client
     698                            .asg 00H, _iUseDispatcher
     699                            .asg 00H, _iArg
     700                            .asg 040H, _IntrMask
     701                            .asg 01H, _iCCBitMask
     702 000000c0                   HWI_Obj 1, HWI_INT6, 6, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        000000c0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT6, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000006  HWI_INT6                .set    6
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi6, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (6 > 15)
1                                       .mexit
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   91

1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   92

1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000000c0                   .sect ".hwi_vec"
1                                   .global hwi6
1                           hwi6:
1                                   .if ((6 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (6 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   93

1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000000c0           spin?
1        000000c0 00000012              b spin?             ; nested branches to block interrupts
1        000000c4 00006000              nop 4
1        000000c8 00000012              b spin?
1        000000cc 00000000              nop
1        000000d0 00000000              nop
1        000000d4 00000000              nop
1        000000d8 00000000              nop
1        000000dc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   94

1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     703                    
     704                    ;; ======== HWI_Obj HWI_INT7 ========
     705                    ;; defines the INT7 Interrupt
     706                    ;;
     707                    ;; HWI_Obj HWI_INT7 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     708                            .global HWI_INT7
     709                            .asg HWI_unused, _function
     710                            .asg "Nothing", _monitor
     711                            .asg 00H, _addr
     712                            .asg "signed", _dataType
     713                            .asg "STS_add(*addr)", _operation
     714                            .asg "USER", _client
     715                            .asg 00H, _iUseDispatcher
     716                            .asg 00H, _iArg
     717                            .asg 080H, _IntrMask
     718                            .asg 01H, _iCCBitMask
     719 000000e0                   HWI_Obj 1, HWI_INT7, 7, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        000000e0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT7, HWI_unused
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   95

1                           
1                                   .if (1 != 0)
1                 00000007  HWI_INT7                .set    7
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi7, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (7 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   96

1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000000e0                   .sect ".hwi_vec"
1                                   .global hwi7
1                           hwi7:
1                                   .if ((7 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (7 == 2)
1                                       .if (RTDX_USERTEXECUTION)
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   97

1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000000e0           spin?
1        000000e0 00000012              b spin?             ; nested branches to block interrupts
1        000000e4 00006000              nop 4
1        000000e8 00000012              b spin?
1        000000ec 00000000              nop
1        000000f0 00000000              nop
1        000000f4 00000000              nop
1        000000f8 00000000              nop
1        000000fc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   98

1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   99

1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     720                    
     721                    ;; ======== HWI_Obj HWI_INT8 ========
     722                    ;; defines the INT8 Interrupt
     723                    ;;
     724                    ;; HWI_Obj HWI_INT8 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     725                            .global HWI_INT8
     726                            .asg HWI_unused, _function
     727                            .asg "Nothing", _monitor
     728                            .asg 00H, _addr
     729                            .asg "signed", _dataType
     730                            .asg "STS_add(*addr)", _operation
     731                            .asg "USER", _client
     732                            .asg 00H, _iUseDispatcher
     733                            .asg 00H, _iArg
     734                            .asg 0100H, _IntrMask
     735                            .asg 01H, _iCCBitMask
     736 00000100                   HWI_Obj 1, HWI_INT8, 8, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        00000100                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT8, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000008  HWI_INT8                .set    8
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi8, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  100

1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (8 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  101

1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000100                   .sect ".hwi_vec"
1                                   .global hwi8
1                           hwi8:
1                                   .if ((8 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (8 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  102

1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000100           spin?
1        00000100 00000012              b spin?             ; nested branches to block interrupts
1        00000104 00006000              nop 4
1        00000108 00000012              b spin?
1        0000010c 00000000              nop
1        00000110 00000000              nop
1        00000114 00000000              nop
1        00000118 00000000              nop
1        0000011c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  103

1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     737                    
     738                    ;; ======== HWI_Obj HWI_INT9 ========
     739                    ;; defines the INT9 Interrupt
     740                    ;;
     741                    ;; HWI_Obj HWI_INT9 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     742                            .global HWI_INT9
     743                            .asg _RTDX_Poll, _function
     744                            .asg "Nothing", _monitor
     745                            .asg 00H, _addr
     746                            .asg "signed", _dataType
     747                            .asg "STS_add(*addr)", _operation
     748                            .asg "RTDX", _client
     749                            .asg 01H, _iUseDispatcher
     750                            .asg 00H, _iArg
     751                            .asg 0208H, _IntrMask
     752                            .asg 01H, _iCCBitMask
     753 00000120                   HWI_Obj 1, HWI_INT9, 9, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        00000120                   CHK_nargs "HWI_Obj", client
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  104

1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT9, _RTDX_Poll
1                           
1                                   .if (1 != 0)
1                 00000009  HWI_INT9                .set    9
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi9, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (RTDX$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (9 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    01H, local_dispatch
1                                   .asg    _RTDX_Poll, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("_RTDX_Poll", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (1 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg _RTDX_Poll, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  105

1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000120                   .sect ".hwi_vec"
1                                   .global hwi9
1                           hwi9:
1                                   .if ((9 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  106

1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (9 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!01H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
1                                   .else
1                                       .if ( 01H )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp("_RTDX_Poll", "CLK_F_isr") = 0 )
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  107

1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        _RTDX_Poll, dispatch_fxn
1                           
1                                           .endif
1                                           
1        00000120 003C54F6                  stw     b0, *b15--[2]
1        00000124 0024A35A                  mvk     9, b0
1        00000128 003C22F6                  stw     b0, *+b15[1]
1        0000012c 0000002A!                 mvkl    HWI_F_dispatch, b0
1        00000130 0000006A!                 mvkh    HWI_F_dispatch, b0
1        00000134 00000362                  b       b0
1        00000138 003C42E6                  ldw     *+b15[2], b0
1        0000013c 00006000                  nop     4
1                           
1        000003c0                           .sect   ".cinit"
1                                           .align  8
1        000003c0 00000010                  .field  4 * STD_TARGWORDMAUS
1        000003c4 00000090!                 .field  _HWI_dispatchTab + (4 * 9 * STD_TARGWORDMAUS)
1        000003c8 00000000!                 .field  _RTDX_Poll
1        000003cc 00000208                  .field  0208H
1        000003d0 00000001                  .field  01H
1        000003d4 00000000                  .field  00H
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  108

1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     754                    
     755                    ;; ======== HWI_Obj HWI_INT10 ========
     756                    ;; defines the INT10 Interrupt
     757                    ;;
     758                    ;; HWI_Obj HWI_INT10 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     759                            .global HWI_INT10
     760                            .asg HWI_unused, _function
     761                            .asg "Nothing", _monitor
     762                            .asg 00H, _addr
     763                            .asg "signed", _dataType
     764                            .asg "STS_add(*addr)", _operation
     765                            .asg "USER", _client
     766                            .asg 00H, _iUseDispatcher
     767                            .asg 00H, _iArg
     768                            .asg 0400H, _IntrMask
     769                            .asg 01H, _iCCBitMask
     770 000003d8                   HWI_Obj 1, HWI_INT10, 10, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        000003d8                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT10, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000A  HWI_INT10               .set    10
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi10, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  109

1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (10 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  110

1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000140                   .sect ".hwi_vec"
1                                   .global hwi10
1                           hwi10:
1                                   .if ((10 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (10 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  111

1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000140           spin?
1        00000140 00000012              b spin?             ; nested branches to block interrupts
1        00000144 00006000              nop 4
1        00000148 00000012              b spin?
1        0000014c 00000000              nop
1        00000150 00000000              nop
1        00000154 00000000              nop
1        00000158 00000000              nop
1        0000015c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  112

1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     771                    
     772                    ;; ======== HWI_Obj HWI_INT11 ========
     773                    ;; defines the INT11 Interrupt
     774                    ;;
     775                    ;; HWI_Obj HWI_INT11 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     776                            .global HWI_INT11
     777                            .asg HWI_unused, _function
     778                            .asg "Nothing", _monitor
     779                            .asg 00H, _addr
     780                            .asg "signed", _dataType
     781                            .asg "STS_add(*addr)", _operation
     782                            .asg "USER", _client
     783                            .asg 00H, _iUseDispatcher
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  113

     784                            .asg 00H, _iArg
     785                            .asg 0800H, _IntrMask
     786                            .asg 01H, _iCCBitMask
     787 00000160                   HWI_Obj 1, HWI_INT11, 11, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        00000160                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT11, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000B  HWI_INT11               .set    11
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi11, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (11 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  114

1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000160                   .sect ".hwi_vec"
1                                   .global hwi11
1                           hwi11:
1                                   .if ((11 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  115

1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (11 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000160           spin?
1        00000160 00000012              b spin?             ; nested branches to block interrupts
1        00000164 00006000              nop 4
1        00000168 00000012              b spin?
1        0000016c 00000000              nop
1        00000170 00000000              nop
1        00000174 00000000              nop
1        00000178 00000000              nop
1        0000017c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  116

1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  117

1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     788                    
     789                    ;; ======== HWI_Obj HWI_INT12 ========
     790                    ;; defines the INT12 Interrupt
     791                    ;;
     792                    ;; HWI_Obj HWI_INT12 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     793                            .global HWI_INT12
     794                            .asg HWI_unused, _function
     795                            .asg "Nothing", _monitor
     796                            .asg 00H, _addr
     797                            .asg "signed", _dataType
     798                            .asg "STS_add(*addr)", _operation
     799                            .asg "USER", _client
     800                            .asg 00H, _iUseDispatcher
     801                            .asg 00H, _iArg
     802                            .asg 01000H, _IntrMask
     803                            .asg 01H, _iCCBitMask
     804 00000180                   HWI_Obj 1, HWI_INT12, 12, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        00000180                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT12, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000C  HWI_INT12               .set    12
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi12, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  118

1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (12 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  119

1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000180                   .sect ".hwi_vec"
1                                   .global hwi12
1                           hwi12:
1                                   .if ((12 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (12 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  120

1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000180           spin?
1        00000180 00000012              b spin?             ; nested branches to block interrupts
1        00000184 00006000              nop 4
1        00000188 00000012              b spin?
1        0000018c 00000000              nop
1        00000190 00000000              nop
1        00000194 00000000              nop
1        00000198 00000000              nop
1        0000019c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  121

1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     805                    
     806                    ;; ======== HWI_Obj HWI_INT13 ========
     807                    ;; defines the INT13 Interrupt
     808                    ;;
     809                    ;; HWI_Obj HWI_INT13 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     810                            .global HWI_INT13
     811                            .asg HWI_unused, _function
     812                            .asg "Nothing", _monitor
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  122

     813                            .asg 00H, _addr
     814                            .asg "signed", _dataType
     815                            .asg "STS_add(*addr)", _operation
     816                            .asg "USER", _client
     817                            .asg 00H, _iUseDispatcher
     818                            .asg 00H, _iArg
     819                            .asg 02000H, _IntrMask
     820                            .asg 01H, _iCCBitMask
     821 000001a0                   HWI_Obj 1, HWI_INT13, 13, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        000001a0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT13, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000D  HWI_INT13               .set    13
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi13, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (13 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  123

1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000001a0                   .sect ".hwi_vec"
1                                   .global hwi13
1                           hwi13:
1                                   .if ((13 == 0))
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  124

1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (13 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000001a0           spin?
1        000001a0 00000012              b spin?             ; nested branches to block interrupts
1        000001a4 00006000              nop 4
1        000001a8 00000012              b spin?
1        000001ac 00000000              nop
1        000001b0 00000000              nop
1        000001b4 00000000              nop
1        000001b8 00000000              nop
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  125

1        000001bc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  126

1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     822                    
     823                    ;; ======== HWI_Obj HWI_INT14 ========
     824                    ;; defines the INT14 Interrupt
     825                    ;;
     826                    ;; HWI_Obj HWI_INT14 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     827                            .global HWI_INT14
     828                            .asg CLK_F_isr, _function
     829                            .asg "Nothing", _monitor
     830                            .asg 00H, _addr
     831                            .asg "signed", _dataType
     832                            .asg "STS_add(*addr)", _operation
     833                            .asg "CLK", _client
     834                            .asg 01H, _iUseDispatcher
     835                            .asg CLK_A_TABBEG, _iArg
     836                            .asg 04000H, _IntrMask
     837                            .asg 01H, _iCCBitMask
     838 000001c0                   HWI_Obj 1, HWI_INT14, 14, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        000001c0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT14, CLK_F_isr
1                           
1                                   .if (1 != 0)
1                 0000000E  HWI_INT14               .set    14
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi14, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  127

1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (CLK$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (14 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    01H, local_dispatch
1                                   .asg    CLK_F_isr, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("CLK_F_isr", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (1 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg CLK_F_isr, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  128

1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000001c0                   .sect ".hwi_vec"
1                                   .global hwi14
1                           hwi14:
1                                   .if ((14 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (14 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  129

1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!01H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
1                                   .else
1                                       .if ( 01H )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp("CLK_F_isr", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  130

1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1        000001c0 003C54F6                  stw     b0, *b15--[2]
1        000001c4 0038A35A                  mvk     14, b0
1        000001c8 003C22F6                  stw     b0, *+b15[1]
1        000001cc 0000002A!                 mvkl    CLK_F_isr, b0
1        000001d0 0000006A!                 mvkh    CLK_F_isr, b0
1        000001d4 00000362                  b       b0
1        000001d8 003C42E6                  ldw     *+b15[2], b0
1        000001dc 00006000                  nop     4
1                           
1        000003d8                           .sect   ".cinit"
1                                           .align  8
1        000003d8 00000010                  .field  4 * STD_TARGWORDMAUS
1        000003dc 000000E0!                 .field  _HWI_dispatchTab + (4 * 14 * STD_TARGWORDMAUS)
1        000003e0 00000000!                 .field  FXN_F_run
1        000003e4 00004000                  .field  04000H
1        000003e8 00000001                  .field  01H
1        000003ec 00000000!                 .field  CLK_A_TABBEG
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     839                    
     840                    ;; ======== HWI_Obj HWI_INT15 ========
     841                    ;; defines the INT15 Interrupt
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  131

     842                    ;;
     843                    ;; HWI_Obj HWI_INT15 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     844                            .global HWI_INT15
     845                            .asg HWI_unused, _function
     846                            .asg "Nothing", _monitor
     847                            .asg 00H, _addr
     848                            .asg "signed", _dataType
     849                            .asg "STS_add(*addr)", _operation
     850                            .asg "USER", _client
     851                            .asg 00H, _iUseDispatcher
     852                            .asg 00H, _iArg
     853                            .asg 08000H, _IntrMask
     854                            .asg 01H, _iCCBitMask
     855 000003f0                   HWI_Obj 1, HWI_INT15, 15, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        000003f0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT15, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000F  HWI_INT15               .set    15
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi15, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (15 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  132

1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  133

1        000001e0                   .sect ".hwi_vec"
1                                   .global hwi15
1                           hwi15:
1                                   .if ((15 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (15 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000001e0           spin?
1        000001e0 00000012              b spin?             ; nested branches to block interrupts
1        000001e4 00006000              nop 4
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  134

1        000001e8 00000012              b spin?
1        000001ec 00000000              nop
1        000001f0 00000000              nop
1        000001f4 00000000              nop
1        000001f8 00000000              nop
1        000001fc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  135

1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     856                    
     857                    ;; ======== SWI_Obj KNL_swi ========
     858                    ;; This Software Interrupt calls the TSK scheduler
     859                    ;;
     860                    ;; SWI_Obj KNL_swi (function, pri, mailbox, arg0, arg1, dorta)
     861                            .global KNL_swi
     862                            .asg _KNL_run, _function
     863                            .asg 00H, _pri
     864                            .asg 00H, _mailbox
     865                            .asg 00H, _arg0
     866                            .asg 00H, _arg1
     867                            .asg 01H, _dorta
     868 00000200                   SWI_Obj 1, KNL_swi, 0, _function, _pri, _mailbox, _arg0, _arg1, _dorta
1        00000200                   CHK_nargs "SWI_Obj", fxn
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   ;
1                                   ; pri, mailbox, arg0 and arg1 are optional -- defaults if necessary
1                                   ;
1                                   .if ($symlen("00H") = 0)
1                                       .asg        "0", pri
1                                       .asg        "0", mailbox
1                                       .asg        "0", arg0
1                                       .asg        "0", arg1
1                                   .elseif ($symlen("00H") = 0)
1                                       .asg        "0", mailbox
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  136

1                                       .asg        "0", arg0
1                                       .asg        "0", arg1
1                                   .elseif ($symlen("00H") = 0)
1                                       .asg        "0", arg0
1                                       .asg        "0", arg1
1                                   .elseif ($symlen("00H") = 0)
1                                       .asg        "0", arg1
1                                   .else
1        00000200                       CHK_nargs "SWI_Obj", arg1
1                                       .if ($symcmp("", "error") = 0)
1                                           .mexit
1                                       .endif
1                                   .endif
1                           
1                                   .if (1 = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global KNL_swi, _KNL_run
1                           
1                           KNL_swi  .tag    SWI_Obj
1                           
1        00000000           KNL_swi .usect ".swi", STD_TARGWORDMAUS * 6, STD_TARGWORDMAUS
1                           
1        000003f0                   .sect ".cinit"
1                           
1                                   .align 8
1                           
1        000003f0 00000018          .field  STD_TARGWORDMAUS * 6
1        000003f4 00000000-         .field KNL_swi
1        000003f8 FFFFFFFF          .field  -1                      ; lock (not posted)
1        000003fc 00000004!         .field  SWI_D_rdytab+(00H*2+1)*STD_TARGWORDMAUS; ready
1        00000400 00000001          .field  1 << 00H              ; mask
1        00000404 00000000          .field  0                       ; link
1        00000408 00000000          .field  00H               ; initkey
1        0000040c 00000000          .field  00H               ; mailbox
1                           
1        00000410                   FXN_Obj KNL_swi$fxn, _KNL_run, 00H, 00H, ".swi"
2        00000410               CHK_nargs "FXN_Obj", section
2                               .if ($symcmp("", "error") = 0)
2                                   .emsg "FXN_Obj parameter error"
2                               .endif
2                           
2                           KNL_swi$fxn  .tag    FXN_Obj
2                           
2        00000018           KNL_swi$fxn     .usect ".swi", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
2                           
2        00000410                   .sect ".cinit"
2                           
2                                   .align 8
2        00000410 0000000C          .field  STD_TARGWORDMAUS * 3
2        00000414 00000018-         .field KNL_swi$fxn
2        00000418 00000000!         .field  _KNL_run          ; fxn
2        0000041c 00000000          .field  00H         ; arg1
2        00000420 00000000          .field  00H         ; arg0
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  137

2                           
1                           
1        00000024           KNL_swi$aaa .usect ".swi", STD_TARGWORDMAUS * 2, STD_TARGWORDMAUS
1                           
1        00000424                   .sect ".cinit"
1                           
1                                   .align 8
1                           
1        00000428 00000008          .field  STD_TARGWORDMAUS * 2
1        0000042c 00000024-         .field KNL_swi$aaa
1        00000430 FFFFFFFF          .field  -1                      ; stslock
1                                   .if 01H
1        00000434 00000004+             .field  KNL_swi$sts          ; pointer to STS_Obj
1                                   .else
1                                       .field 0
1                                   .endif
1                           
1                                   ; only allocate STS object if 'Do RTA' is TRUE
1                                   .if 01H
1        00000438                       STS_Obj 1, KNL_swi$sts, 0, 0, 0
2                           
2        00000438                   CHK_nargs "STS_Obj", prevl
2                           
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "STS_Obj parameter error."
2                                   .endif
2                           
2                                   .if (1 = 0)                  ; if this object is not
2                                                                      ; really to be allocated
2                                       .mexit                         ; exit quietly now
2                                   .endif
2                           
2                                   .global KNL_swi$sts, KNL_swi$sts$stsobj     
2                           
2        00000000                   .sect ".sts"                       ; allocate STS_Obj 
2                                                                      ; (in section ".sts")
2                           KNL_swi$sts  .tag    STS_Obj                    ; declare name as having 
2                                                                      ; type STS_Obj
2        00000000           KNL_swi$sts$stsobj:
2                                                                     ; NOTE: on 32-bit targets
2                                                                     ; only prevh is used
2        00000000 00000000          .long   0                         ; allocate space for previous
2                                                                     ; 32-bit value
2        00000004           KNL_swi$sts                                   
2        00000004 00000000          .long   0                         ; num
2        00000008 00000000          .long   0                         ; acc
2        0000000c 80000000          .long   80000000h                 ; max
2                           
2        00000438                   .sect    ".cinit"
2                                   .align    8
2        00000438 00000010          .field    STD_TARGWORDMAUS * 4
2        0000043c 00000000+         .field    KNL_swi$sts$stsobj                    
2        00000440 00000000          .field    0                  ; allocate space for history   
2        00000444 00000000          .field    0                        ; num
2        00000448 00000000          .field    0                        ; acc
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  138

2        0000044c 80000000          .field    80000000h                ; max
2                           
2        00000010                   .sect    ".sts"
2                           
1                                   .endif
1                           
     869                    
     870                    ;; ======== TSK_Obj TSK_idle ========
     871                    ;; This is the idle task; it only runs when no other task is ready
     872                    ;;
     873                    ;; TSK_Obj TSK_idle (iFXN, iARG0, iARG1, iARG2, iARG3, iARG4, iARG5, iARG6, iARG7, iAUTOSTK, iMANSTK, 
     874                            .global TSK_idle
     875                            .asg IDL_F_loop, _iFXN
     876                            .asg 00H, _iARG0
     877                            .asg 00H, _iARG1
     878                            .asg 00H, _iARG2
     879                            .asg 00H, _iARG3
     880                            .asg 00H, _iARG4
     881                            .asg 00H, _iARG5
     882                            .asg 00H, _iARG6
     883                            .asg 00H, _iARG7
     884                            .asg 01H, _iAUTOSTK
     885                            .asg null, _iMANSTK
     886                            .asg 0400H, _iSTKSZ
     887                            .asg SDRAM, _iSTKSEG
     888                            .asg 00H, _iPRI
     889                            .asg 00H, _iENV
     890                            .asg 01H, _iEXITFLAG
     891                            .asg 00H, _iUSETSKNAME
     892                            .asg 00H, _iSTATREG
     893 00000010                   TSK_Obj 1, TSK_idle, 0, _iFXN, _iARG0, _iARG1, _iARG2, _iARG3, _iARG4, _iARG5, _iARG6, _iARG7,
1                           
1                                   .global IDL_F_loop
1                                   .global TSK_idle
1                           
1                                   .if 00H
1                                           .sect   ".const"
1                           TSK$:TSK_idle:  .string ":name:",0      ; null-terminated name string
1                                   .endif
1                           
1        00000000           TSK_idle$obj    .usect  ".tsk", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        0000000c           TSK_idle                .usect  ".tsk", 21 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .if     0 > 0
1                           :name:$env      .usect  ".tsk", TSK$num_hooks * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .endif
1                           
1                 00000400  TSK_idle$stklen .set    0400H
1                           
1                                   .if     01H
1                                       ;
1                                       ; Reserve space for automatically allocated stack
1                                       ;
1        00000000           TSK_idle$stack  .usect ".TSK_idle$stk", 0400H, STD_TARGALIGN
1                                           .global TSK_idle$stack, TSK_idle$stackname
1                                           .asg    "TSK_idle$stack", TSK_idle$stackname
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  139

1                                   .else
1                                       .if ($symcmp(":manstack:", "null") == 0)
1                                           .emsg "TSK :name: manually allocated stack cannot be null"
1                                       .else
1                                           .asg    ":manstack:", :name:$stackname
1                                       .endif
1                                   .endif
1                           
1                                   ;
1                                   ; stkptr for the idle stack is used by the IDL_F_stub function
1                                   ;
1                                   .global TSK_idle$stkptr
1                           
1                                   .if 01H
1                 00000398- TSK_idle$stkptr .set TSK_idle$stack + 0400H - STD_TARGALIGN - (24 * STD_TARGWORDMAUS)
1                                   .else
1                                           .asg "(:name:$stackname + :stacksize: - STD_TARGALIGN - (TSK_USEDSTACK * STD_TARGWORDM
1                                   .endif
1                           
1        00000450                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000450 00000060          .word   24 * STD_TARGWORDMAUS, TSK_idle$obj
         00000454 00000000-
1                           
1        00000458                   OBJ_Obj TSK_idle, OBJ_TSK, (TSK_CORESIZE + TSK$num_hooks)       ; allocates 3 words
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_TSK == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  140

2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_TSK == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
2                                       .endif
2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_TSK == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != 1          ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2        00000458 00000060-                 .word   TSK_idle + (21 + 0) * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2        0000045c 00000040-             .word       _OBJ_table + 4 * STD_TARGWORDMAUS               ; previous object or OBJ_table
2                           
2        00000460 0000ABC2              .word       OBJ_TSK | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        "TSK_idle$obj", OBJ_tsk$prev
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  141

2                           
2                                       .if 1 = 1                   ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg "TSK_idle$obj", OBJ_tsk$next       ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       1+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_MBX
2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  142

2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  143

2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != BUF$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_buf$prev
2                           
2                                       .if BUF$sernum = 1                  ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       BUF$sernum+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        00000464 0000000C-         .word   TSK_idle, TSK_idle                      ; kobj.ready
         00000468 0000000C-
1        0000046c 00000014-         .word   TSK_idle+2*STD_TARGWORDMAUS, TSK_idle+2*STD_TARGWORDMAUS        ; kobj.alarm
         00000470 00000014-
1        00000474 0000001C-         .word   TSK_idle+4*STD_TARGWORDMAUS, TSK_idle+4*STD_TARGWORDMAUS        ; kobj.setpri
         00000478 0000001C-
1                           
1                                   ;
1                                   ; GCONF gives priority of 0ffffffffh for -1, so we need to translate
1                                   ; since the assembler treats 0ffffffffh as unsigned
1                                   ;
1                                   .if 00H = 0ffffffffh
1                                       .eval       -1, local_priority
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  144

1                                   .else
1                                       .eval       00H, local_priority
1                                   .endif
1                           
1                                   .if 0 < 0
1                                       ;
1                                       ;  KNL_queues[3] is _KNL_inactive queue. All terminated and
1                                       ;  negative priority tasks go here.
1                                       ;
1                                       .word       _KNL_queues+3*2*STD_TARGWORDMAUS        ; kobj.queue = _KNL_inactive
1                                       .word       local_priority          ; kobj.priority
1                                       .word       0                       ; kobj.mask
1                                   .else
1                                       ;
1                                       ; KNL_priority[priority]
1                                       ;
1        0000047c 00000020!             .word       _KNL_queues+(0+4)*2*STD_TARGWORDMAUS
1                           
1        00000480 00000000              .word       0               ; kobj.priority
1        00000484 00000001              .word       1<<0    ; kobj.mask
1                                   .endif
1                           
1        00000488 00000398-         .word   TSK_idle$stkptr         ; kobj.sp
1                           
1        0000048c 00000000          .word   0                       ; kobj.timeout
1        00000490 00000000          .word   0                       ; kobj.mode
1                           
1                                   .if GBL_ENABLEINST
1        00000494 00000014+             .word       TSK_idle$sts    ; kobj.sts
1                                   .else
1                                       .word       0
1                                   .endif
1                           
1        00000498 00000000          .short  0                       ; kobj.signalled
1                                   .align  STD_TARGWORDMAUS
1                           
1                                   ;
1                                   ;  stack - This field is only used by TSK_checkstacks to
1                                   ;  verify that the task stack is still valid.  It always
1                                   ;  points to the top (lowest address) of the task's stack.
1                                   ;
1        0000049c 00000000-         .word   TSK_idle$stack
1        000004a0 00000400          .word   0400H
1        000004a4 00000014-         .word   SDRAM           
1                           
1                           
1                                   ;
1                                   ;  Set up pointer to task's name or NULL
1                                   ;
1                                   .if     00H
1                                           .word   TSK$:name:              ; name
1                                   .else
1        000004a8 00000000                  .word   0
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  145

1                                   .if     0 == 0
1        000004ac 00000000              .word       00H                     ; environ
1                                   .else
1                                       .word       :name:$env
1                                   .endif
1                           
1        000004b0 00000000          .word   0                       ; errno
1        000004b4 00000001          .short  01H
1                                   .align  STD_TARGWORDMAUS                        ; short followed by word could misalign
1                           
1                                   ; End of TSK_Obj structure;
1                           
1                                   .if GBL_ENABLEINST
1        000004b8                       STS_Obj     1, TSK_idle$sts, 0, 0, 0
2                           
2        000004b8                   CHK_nargs "STS_Obj", prevl
2                           
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "STS_Obj parameter error."
2                                   .endif
2                           
2                                   .if (1 = 0)                  ; if this object is not
2                                                                      ; really to be allocated
2                                       .mexit                         ; exit quietly now
2                                   .endif
2                           
2                                   .global TSK_idle$sts, TSK_idle$sts$stsobj     
2                           
2        00000010                   .sect ".sts"                       ; allocate STS_Obj 
2                                                                      ; (in section ".sts")
2                           TSK_idle$sts  .tag    STS_Obj                    ; declare name as having 
2                                                                      ; type STS_Obj
2        00000010           TSK_idle$sts$stsobj:
2                                                                     ; NOTE: on 32-bit targets
2                                                                     ; only prevh is used
2        00000010 00000000          .long   0                         ; allocate space for previous
2                                                                     ; 32-bit value
2        00000014           TSK_idle$sts                                   
2        00000014 00000000          .long   0                         ; num
2        00000018 00000000          .long   0                         ; acc
2        0000001c 80000000          .long   80000000h                 ; max
2                           
2        000004b8                   .sect    ".cinit"
2                                   .align    8
2        000004b8 00000010          .field    STD_TARGWORDMAUS * 4
2        000004bc 00000010+         .field    TSK_idle$sts$stsobj                    
2        000004c0 00000000          .field    0                  ; allocate space for history   
2        000004c4 00000000          .field    0                        ; num
2        000004c8 00000000          .field    0                        ; acc
2        000004cc 80000000          .field    80000000h                ; max
2                           
2        00000020                   .sect    ".sts"
2                           
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  146

1                                   .if $symcmp("IDL_F_loop", "_SYS_nop") = 0
1                                       .wmsg "Task :name: is being created to run :fxn:"
1                                   .endif
1                           
1                                   .if     0 > 0
1                                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1                                       .word       1 * STD_TARGWORDMAUS
1                                       .word       :name:$env + (HOOK$knl_index * (1 * STD_TARGWORDMAUS))
1                                       .word       :envp:
1                                   .endif
1                           
1                           
1                                   ;
1                                   ; generate a cinit record that will initialize the tasks's stack
1                                   ;
1        000004d0                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1                           
1                                   ;
1                                   ; TSK_idle$stkptr points one word *below* stack frame, so add 1 word
1                                   ; to the base address of the cinit record
1                                   ;
1        000004d0 00000060          .word   24 * STD_TARGWORDMAUS, TSK_idle$stkptr + (1 * STD_TARGWORDMAUS)
         000004d4 0000039C-
1                           
1        000004d8 00000000          .word   0
1        000004dc 00000000          .word   00H
1        000004e0 00000000!         .word   _KNL_exit
1        000004e4 00000000          .word   0
1        000004e8 00000000!         .word   KNL_glue
1                                   ;
1                                   ; TSK_USEDSTACK is the total number of words in the startup
1                                   ; stack.  There are 15 words that are set explicitly, leaving
1                                   ; TSK_USEDSTACK - 15 words for which we need to leave space here.
1                                   ;
1                           
1                                   ; The .space directive for the C6x indicates bytes
1                           
1        000004ec                   .space  (24 - 15) * STD_TARGWORDMAUS    ; 4 bytes per word
1                           
1                                   .eval   0, strCount$save
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000510 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  147

1                                   .else
1        00000514 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000518 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        0000051c 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000520 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000524 00000000              .word 00H
1                                   .endif
1                           
1                           ;
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           ;
1                           ;  Be careful with this little island of non-arg code!
1                           
1        00000528 00000000!         .word   IDL_F_loop
1        0000052c 00000000!         .word   _TSK_exit
1                           
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000530 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  148

1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000534 00000000              .word 00H
1                                   .endif
1                           
1                                   ;
1                                   ; Create a record to fill unused portion of stack with stackstamp
1                                   ; Format: sequence of 3 words; <count, address, fill-value>
1                                   ;
1        0000000c                   .sect ".gblinit"
1        0000000c 000000E7          .word   ((TSK_idle$stkptr - TSK_idle$stack) / STD_TARGWORDMAUS) + 1     ; count
1        00000010 00000000-         .word   TSK_idle$stack
1        00000014 BEBEBEBE          .word   0xbebebebe 
1                           
1                           
1                                   ;
1                                   ; Finally, let TSK_idle point to the right location
1                                   ;
1                                   .asg "TSK_idle$base + OBJ_HDRSIZE * STD_TARGWORDMAUS", TSK_idle
1                           
1                                   ;
1                                   ; Conditionally set up strings for arguments
1                                   ;
1                                   .eval   0, TSK$strCount
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg0(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg1(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg2(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg3(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  149

1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg4(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg5(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg6(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg7(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
     894                    
     895                    ;; ======== TSK_Obj TSK_image ========
     896                    ;; video input
     897                    ;;
     898                    ;; TSK_Obj TSK_image (iFXN, iARG0, iARG1, iARG2, iARG3, iARG4, iARG5, iARG6, iARG7, iAUTOSTK, iMANSTK,
     899                            .global TSK_image
     900                            .asg _tskVideoInput, _iFXN
     901                            .asg 00H, _iARG0
     902                            .asg 00H, _iARG1
     903                            .asg 00H, _iARG2
     904                            .asg 00H, _iARG3
     905                            .asg 00H, _iARG4
     906                            .asg 00H, _iARG5
     907                            .asg 00H, _iARG6
     908                            .asg 00H, _iARG7
     909                            .asg 01H, _iAUTOSTK
     910                            .asg null, _iMANSTK
     911                            .asg 05000H, _iSTKSZ
     912                            .asg SDRAM, _iSTKSEG
     913                            .asg 05H, _iPRI
     914                            .asg 00H, _iENV
     915                            .asg 01H, _iEXITFLAG
     916                            .asg 00H, _iUSETSKNAME
     917                            .asg 00H, _iSTATREG
     918 00000018                   TSK_Obj 1, TSK_image, 0, _iFXN, _iARG0, _iARG1, _iARG2, _iARG3, _iARG4, _iARG5, _iARG6, _iARG7
1                           
1                                   .global _tskVideoInput
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  150

1                                   .global TSK_image
1                           
1                                   .if 00H
1                                           .sect   ".const"
1                           TSK$:TSK_image: .string ":name:",0      ; null-terminated name string
1                                   .endif
1                           
1        00000060           TSK_image$obj   .usect  ".tsk", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        0000006c           TSK_image               .usect  ".tsk", 21 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .if     0 > 0
1                           :name:$env      .usect  ".tsk", TSK$num_hooks * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .endif
1                           
1                 00005000  TSK_image$stklen        .set    05000H
1                           
1                                   .if     01H
1                                       ;
1                                       ; Reserve space for automatically allocated stack
1                                       ;
1        00000000           TSK_image$stack .usect ".TSK_image$stk", 05000H, STD_TARGALIGN
1                                           .global TSK_image$stack, TSK_image$stackname
1                                           .asg    "TSK_image$stack", TSK_image$stackname
1                                   .else
1                                       .if ($symcmp(":manstack:", "null") == 0)
1                                           .emsg "TSK :name: manually allocated stack cannot be null"
1                                       .else
1                                           .asg    ":manstack:", :name:$stackname
1                                       .endif
1                                   .endif
1                           
1                                   ;
1                                   ; stkptr for the idle stack is used by the IDL_F_stub function
1                                   ;
1                                   .global TSK_image$stkptr
1                           
1                                   .if 01H
1                 00004F98- TSK_image$stkptr        .set TSK_image$stack + 05000H - STD_TARGALIGN - (24 * STD_TARGWORDMAUS)
1                                   .else
1                                           .asg "(:name:$stackname + :stacksize: - STD_TARGALIGN - (TSK_USEDSTACK * STD_TARGWORDM
1                                   .endif
1                           
1        00000538                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000538 00000060          .word   24 * STD_TARGWORDMAUS, TSK_image$obj
         0000053c 00000060-
1                           
1        00000540                   OBJ_Obj TSK_image, OBJ_TSK, (TSK_CORESIZE + TSK$num_hooks)      ; allocates 3 words
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_TSK == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  151

2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_TSK == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
2                                       .endif
2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  152

2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_TSK == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != 2          ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2        00000540 00000040-                 .word   _OBJ_table + 4 * STD_TARGWORDMAUS               ; next points back to OBJ_tabl
2                                       .endif
2                                   
2        00000544 00000000-             .word       TSK_idle$obj            ; previous object or OBJ_table
2                           
2        00000548 0000ABC2              .word       OBJ_TSK | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        "TSK_image$obj", OBJ_tsk$prev
2                           
2                                       .if 2 = 1                   ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       2+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_MBX
2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  153

2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  154

2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != BUF$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_buf$prev
2                           
2                                       .if BUF$sernum = 1                  ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  155

2                                       .eval       BUF$sernum+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        0000054c 0000006C-         .word   TSK_image, TSK_image                    ; kobj.ready
         00000550 0000006C-
1        00000554 00000074-         .word   TSK_image+2*STD_TARGWORDMAUS, TSK_image+2*STD_TARGWORDMAUS      ; kobj.alarm
         00000558 00000074-
1        0000055c 0000007C-         .word   TSK_image+4*STD_TARGWORDMAUS, TSK_image+4*STD_TARGWORDMAUS      ; kobj.setpri
         00000560 0000007C-
1                           
1                                   ;
1                                   ; GCONF gives priority of 0ffffffffh for -1, so we need to translate
1                                   ; since the assembler treats 0ffffffffh as unsigned
1                                   ;
1                                   .if 05H = 0ffffffffh
1                                       .eval       -1, local_priority
1                                   .else
1                                       .eval       05H, local_priority
1                                   .endif
1                           
1                                   .if 5 < 0
1                                       ;
1                                       ;  KNL_queues[3] is _KNL_inactive queue. All terminated and
1                                       ;  negative priority tasks go here.
1                                       ;
1                                       .word       _KNL_queues+3*2*STD_TARGWORDMAUS        ; kobj.queue = _KNL_inactive
1                                       .word       local_priority          ; kobj.priority
1                                       .word       0                       ; kobj.mask
1                                   .else
1                                       ;
1                                       ; KNL_priority[priority]
1                                       ;
1        00000564 00000048!             .word       _KNL_queues+(5+4)*2*STD_TARGWORDMAUS
1                           
1        00000568 00000005              .word       5               ; kobj.priority
1        0000056c 00000020              .word       1<<5    ; kobj.mask
1                                   .endif
1                           
1        00000570 00004F98-         .word   TSK_image$stkptr                ; kobj.sp
1                           
1        00000574 00000000          .word   0                       ; kobj.timeout
1        00000578 00000000          .word   0                       ; kobj.mode
1                           
1                                   .if GBL_ENABLEINST
1        0000057c 00000024+             .word       TSK_image$sts   ; kobj.sts
1                                   .else
1                                       .word       0
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  156

1        00000580 00000000          .short  0                       ; kobj.signalled
1                                   .align  STD_TARGWORDMAUS
1                           
1                                   ;
1                                   ;  stack - This field is only used by TSK_checkstacks to
1                                   ;  verify that the task stack is still valid.  It always
1                                   ;  points to the top (lowest address) of the task's stack.
1                                   ;
1        00000584 00000000-         .word   TSK_image$stack
1        00000588 00005000          .word   05000H
1        0000058c 00000014-         .word   SDRAM           
1                           
1                           
1                                   ;
1                                   ;  Set up pointer to task's name or NULL
1                                   ;
1                                   .if     00H
1                                           .word   TSK$:name:              ; name
1                                   .else
1        00000590 00000000                  .word   0
1                                   .endif
1                           
1                                   .if     0 == 0
1        00000594 00000000              .word       00H                     ; environ
1                                   .else
1                                       .word       :name:$env
1                                   .endif
1                           
1        00000598 00000000          .word   0                       ; errno
1        0000059c 00000001          .short  01H
1                                   .align  STD_TARGWORDMAUS                        ; short followed by word could misalign
1                           
1                                   ; End of TSK_Obj structure;
1                           
1                                   .if GBL_ENABLEINST
1        000005a0                       STS_Obj     1, TSK_image$sts, 0, 0, 0
2                           
2        000005a0                   CHK_nargs "STS_Obj", prevl
2                           
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "STS_Obj parameter error."
2                                   .endif
2                           
2                                   .if (1 = 0)                  ; if this object is not
2                                                                      ; really to be allocated
2                                       .mexit                         ; exit quietly now
2                                   .endif
2                           
2                                   .global TSK_image$sts, TSK_image$sts$stsobj     
2                           
2        00000020                   .sect ".sts"                       ; allocate STS_Obj 
2                                                                      ; (in section ".sts")
2                           TSK_image$sts  .tag    STS_Obj                    ; declare name as having 
2                                                                      ; type STS_Obj
2        00000020           TSK_image$sts$stsobj:
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  157

2                                                                     ; NOTE: on 32-bit targets
2                                                                     ; only prevh is used
2        00000020 00000000          .long   0                         ; allocate space for previous
2                                                                     ; 32-bit value
2        00000024           TSK_image$sts                                   
2        00000024 00000000          .long   0                         ; num
2        00000028 00000000          .long   0                         ; acc
2        0000002c 80000000          .long   80000000h                 ; max
2                           
2        000005a0                   .sect    ".cinit"
2                                   .align    8
2        000005a0 00000010          .field    STD_TARGWORDMAUS * 4
2        000005a4 00000020+         .field    TSK_image$sts$stsobj                    
2        000005a8 00000000          .field    0                  ; allocate space for history   
2        000005ac 00000000          .field    0                        ; num
2        000005b0 00000000          .field    0                        ; acc
2        000005b4 80000000          .field    80000000h                ; max
2                           
2        00000030                   .sect    ".sts"
2                           
1                                   .endif
1                           
1                                   .if $symcmp("_tskVideoInput", "_SYS_nop") = 0
1                                       .wmsg "Task :name: is being created to run :fxn:"
1                                   .endif
1                           
1                                   .if     0 > 0
1                                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1                                       .word       1 * STD_TARGWORDMAUS
1                                       .word       :name:$env + (HOOK$knl_index * (1 * STD_TARGWORDMAUS))
1                                       .word       :envp:
1                                   .endif
1                           
1                           
1                                   ;
1                                   ; generate a cinit record that will initialize the tasks's stack
1                                   ;
1        000005b8                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1                           
1                                   ;
1                                   ; TSK_image$stkptr points one word *below* stack frame, so add 1 word
1                                   ; to the base address of the cinit record
1                                   ;
1        000005b8 00000060          .word   24 * STD_TARGWORDMAUS, TSK_image$stkptr + (1 * STD_TARGWORDMAUS)
         000005bc 00004F9C-
1                           
1        000005c0 00000000          .word   0
1        000005c4 00000000          .word   00H
1        000005c8 00000000!         .word   _KNL_exit
1        000005cc 00000000          .word   0
1        000005d0 00000000!         .word   KNL_glue
1                                   ;
1                                   ; TSK_USEDSTACK is the total number of words in the startup
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  158

1                                   ; stack.  There are 15 words that are set explicitly, leaving
1                                   ; TSK_USEDSTACK - 15 words for which we need to leave space here.
1                                   ;
1                           
1                                   ; The .space directive for the C6x indicates bytes
1                           
1        000005d4                   .space  (24 - 15) * STD_TARGWORDMAUS    ; 4 bytes per word
1                           
1                                   .eval   0, strCount$save
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        000005f8 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        000005fc 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000600 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000604 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000608 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  159

1        0000060c 00000000              .word 00H
1                                   .endif
1                           
1                           ;
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           ;
1                           ;  Be careful with this little island of non-arg code!
1                           
1        00000610 00000000!         .word   _tskVideoInput
1        00000614 00000000!         .word   _TSK_exit
1                           
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000618 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        0000061c 00000000              .word 00H
1                                   .endif
1                           
1                                   ;
1                                   ; Create a record to fill unused portion of stack with stackstamp
1                                   ; Format: sequence of 3 words; <count, address, fill-value>
1                                   ;
1        00000018                   .sect ".gblinit"
1        00000018 000013E7          .word   ((TSK_image$stkptr - TSK_image$stack) / STD_TARGWORDMAUS) + 1   ; count
1        0000001c 00000000-         .word   TSK_image$stack
1        00000020 BEBEBEBE          .word   0xbebebebe 
1                           
1                           
1                                   ;
1                                   ; Finally, let TSK_image point to the right location
1                                   ;
1                                   .asg "TSK_image$base + OBJ_HDRSIZE * STD_TARGWORDMAUS", TSK_image
1                           
1                                   ;
1                                   ; Conditionally set up strings for arguments
1                                   ;
1                                   .eval   0, TSK$strCount
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg0(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  160

1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg1(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg2(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg3(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg4(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg5(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg6(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg7(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
     919                    
     920                    ;; ======== IDL_Obj LNK_dataPump ========
     921                    ;; This object cannot be deleted
     922                    ;;
     923                    ;; IDL_Obj LNK_dataPump (function, calibration)
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  161

     924                            .global LNK_dataPump
     925                            .asg LNK_F_dataPump, _function
     926                            .asg 01H, _calibration
     927 00000024                   IDL_Obj 1, LNK_dataPump, 0, _function, _calibration
1        00000024                   CHK_nargs "IDL_Obj", calibration
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                               .var fxnlen
1                               .eval $symlen("LNK_F_dataPump"),fxnlen
1                           
1                                   .if (1 = 0)   ; if this object is not really to be allocated
1                                       .mexit      ; exit quietly now
1                                   .endif
1                           
1                                   .global LNK_dataPump$
1                                   .global LNK_dataPump
1                           
1                                   .if ($symcmp("LNK_F_dataPump", "0") != 0)
1                               .global LNK_F_dataPump
1                                   .endif
1                           
1                           LNK_dataPump$ .tag    IDL_Obj         ; declare name$ as having type IDL_Obj
1                           
1        00000000           LNK_dataPump$ .usect ".idlcal", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        00000620                   .sect ".cinit"
1                           
1                               .align  8
1        00000620 00000004      .field  STD_TARGWORDMAUS * 1
1        00000624 00000000-     .field  LNK_dataPump$    
1                                   .if (01H != 0) ; if to be included in IDL calibration
1        00000628 00000000!             .field  LNK_F_dataPump             ; fxn
1                               .else
1                                       .field  FXN_F_nop    ; else use FXN_F_nop
1                                   .endif
1                           
1                           LNK_dataPump  .tag    IDL_Obj         ; declare name as having type IDL_Obj
1                           
1        00000000           LNK_dataPump  .usect ".idl", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        0000062c                   .sect ".cinit"
1                           
1                               .align  8
1        00000630 00000004      .field  STD_TARGWORDMAUS * 1
1        00000634 00000000-     .field  LNK_dataPump    
1        00000638 00000000!     .field  LNK_F_dataPump           ; fxn
1                           
     928                    
     929                    ;; ======== IDL_Obj RTA_dispatcher ========
     930                    ;; This object cannot be deleted
     931                    ;;
     932                    ;; IDL_Obj RTA_dispatcher (function, calibration)
     933                            .global RTA_dispatcher
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  162

     934                            .asg RTA_F_dispatch, _function
     935                            .asg 01H, _calibration
     936 0000063c                   IDL_Obj 1, RTA_dispatcher, 0, _function, _calibration
1        0000063c                   CHK_nargs "IDL_Obj", calibration
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                               .var fxnlen
1                               .eval $symlen("RTA_F_dispatch"),fxnlen
1                           
1                                   .if (1 = 0)   ; if this object is not really to be allocated
1                                       .mexit      ; exit quietly now
1                                   .endif
1                           
1                                   .global RTA_dispatcher$
1                                   .global RTA_dispatcher
1                           
1                                   .if ($symcmp("RTA_F_dispatch", "0") != 0)
1                               .global RTA_F_dispatch
1                                   .endif
1                           
1                           RTA_dispatcher$ .tag    IDL_Obj         ; declare name$ as having type IDL_Obj
1                           
1        00000004           RTA_dispatcher$ .usect ".idlcal", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        0000063c                   .sect ".cinit"
1                           
1                               .align  8
1        00000640 00000004      .field  STD_TARGWORDMAUS * 1
1        00000644 00000004-     .field  RTA_dispatcher$    
1                                   .if (01H != 0) ; if to be included in IDL calibration
1        00000648 00000000!             .field  RTA_F_dispatch             ; fxn
1                               .else
1                                       .field  FXN_F_nop    ; else use FXN_F_nop
1                                   .endif
1                           
1                           RTA_dispatcher  .tag    IDL_Obj         ; declare name as having type IDL_Obj
1                           
1        00000004           RTA_dispatcher  .usect ".idl", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        0000064c                   .sect ".cinit"
1                           
1                               .align  8
1        00000650 00000004      .field  STD_TARGWORDMAUS * 1
1        00000654 00000004-     .field  RTA_dispatcher    
1        00000658 00000000!     .field  RTA_F_dispatch           ; fxn
1                           
     937                    
     938                    ;; ======== IDL_Obj IDL_cpuLoad ========
     939                    ;; This object is required by the system to acquire CPU load data
     940                    ;;
     941                    ;; IDL_Obj IDL_cpuLoad (function, calibration)
     942                            .global IDL_cpuLoad
     943                            .asg IDL_F_busy, _function
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  163

     944                            .asg 01H, _calibration
     945 0000065c                   IDL_Obj 1, IDL_cpuLoad, 0, _function, _calibration
1        0000065c                   CHK_nargs "IDL_Obj", calibration
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                               .var fxnlen
1                               .eval $symlen("IDL_F_busy"),fxnlen
1                           
1                                   .if (1 = 0)   ; if this object is not really to be allocated
1                                       .mexit      ; exit quietly now
1                                   .endif
1                           
1                                   .global IDL_cpuLoad$
1                                   .global IDL_cpuLoad
1                           
1                                   .if ($symcmp("IDL_F_busy", "0") != 0)
1                               .global IDL_F_busy
1                                   .endif
1                           
1                           IDL_cpuLoad$ .tag    IDL_Obj         ; declare name$ as having type IDL_Obj
1                           
1        00000008           IDL_cpuLoad$ .usect ".idlcal", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        0000065c                   .sect ".cinit"
1                           
1                               .align  8
1        00000660 00000004      .field  STD_TARGWORDMAUS * 1
1        00000664 00000008-     .field  IDL_cpuLoad$    
1                                   .if (01H != 0) ; if to be included in IDL calibration
1        00000668 00000000!             .field  IDL_F_busy             ; fxn
1                               .else
1                                       .field  FXN_F_nop    ; else use FXN_F_nop
1                                   .endif
1                           
1                           IDL_cpuLoad  .tag    IDL_Obj         ; declare name as having type IDL_Obj
1                           
1        00000008           IDL_cpuLoad  .usect ".idl", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        0000066c                   .sect ".cinit"
1                           
1                               .align  8
1        00000670 00000004      .field  STD_TARGWORDMAUS * 1
1        00000674 00000008-     .field  IDL_cpuLoad    
1        00000678 00000000!     .field  IDL_F_busy           ; fxn
1                           
     946                    
     947                    ;; ======== LOG_Obj LOG_system ========
     948                    ;; This object is required by the system to accumulate execution trace information
     949                    ;;
     950                    ;; LOG_Obj LOG_system (bufseg, buflen, logtype)
     951                            .global LOG_system
     952                            .asg SDRAM, _bufseg
     953                            .asg 0400H, _buflen
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  164

     954                            .asg "circular", _logtype
     955 0000067c                   LOG_Obj 1, LOG_system, 0, _bufseg, _buflen, _logtype
1        0000067c                   CHK_domain LOG_Obj, mode, "circular,fixed", "circular"
2                           
1                                   .asg "circular", mode
1                                   .if ($isdefed("LOG_NOOP") = 1)
1                                       .mexit
1                               .elseif ($symcmp("circular", "error") = 0)
1                                   .emsg "LOG_Obj mode error."
1                                   .endif
1                           
1                                   .global LOG_system$buf
1                                   .global LOG_system$size
1                           
1                                   .var    bufbeg
1                                   .var    flag
1                                   .if ((1 != 0) & (0400H > 0))
1                                       .if (((0400H - 1) & 0400H) != 0)
1                                           .emsg   "The LOG :name: buffer size must be a power of 2"
1                                       .endif
1                           
1                                       .asg        0, flag         ; enable LOG
1                                       .asg        "LOG_system$buf", bufbeg
1                           
1                                                                  ;
1                                                                  ; place log buffers into 
1                                                                                                      ; .log0, .log1, etc. sectio
1                                       
1        0000067c                       GBL_Obj     LOG_system$buf, buflen, ".LOG_system$buf", "noalign", -1, 1
2        0000067c                   CHK_domain "GBL_Obj", alignFlag, "noalign,align", "noalign"
3                           
2                                   .if ($symcmp("noalign", "error") = 0)
2                                       .emsg "GBL_Obj align parameter error."
2                                   .endif
2                                   .asg "noalign", alignFlag
2                           
2        0000067c                   CHK_nargs "GBL_Obj", size
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "GBL_Obj size parameter error."
2                                   .endif
2                           
2                                   .if ($symlen(section) = 0)
2                                       .asg ".bss", section
2                                   .endif
2                           
2                                   .if ($symlen(fillValue) != 0)
2        00000024                       .sect ".gblinit"
2        00000024 00000400              .word 0400H
2        00000028 00000000-             .word LOG_system$buf
2        0000002c FFFFFFFF              .word -1
2                                   .endif
2                           
2                                   .if (($symcmp(section, ".data") = 0) | ($symcmp(alignFlag, "align") = 0))
2                                       .sect ":section:"
2                                       .if ($symcmp(alignFlag, "align") = 0)
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  165

2                                           .align  :alignValue:
2                                       .endif
2                           :name::
2                                       ;
2                                       ; Can't use .space directive here because it reserves
2                                       ; bits for some processors and bytes for others.
2                                       ;
2                                       .loop       :size:
2                                           .word 0
2                                       .endloop
2                           
2                                   .elseif ($symcmp(".LOG_system$buf", ".bss") = 0)
2                                       .bss :name:, :size: * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS / STD_TARGC
2                                   .else
2        00000000           LOG_system$buf:     .usect ".LOG_system$buf", 0400H * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARG
2                                   .endif
2                           
1                           
1                 00000400  LOG_system$size .set        0400H
1                           
1                                   .else
1                                       .asg        1, flag         ; disable LOG
1                                       .asg        0, bufbeg
1                           :name:$buf  .set        0
1                           :name:$size .set        0
1                                   .endif
1                           
1        00000000                   .sect ".log"                    ; place all LOG objects in
1                                                                   ; ".log"
1                                   .global LOG_system                  ; make name globally visable
1                           LOG_system  .tag    LOG_Obj                 ; declare name as having type
1                                                                   ; LOG_Obj
1                           
1        00000000           LOG_system                                  ; allocate and initialize 
1                                                                   ; LOG_Obj (in current section)
1                           
1        00000000 00000000          .word    0                      ; bufend 
1        00000004 00000000          .word    0                      ; flag
1        00000008 00000000          .word    0                      ; seqnum 
1        0000000c 00000000          .word    0                      ; curptr
1        00000010 00000000          .word    0                      ; lenmask 
1        00000014 00000000          .word    0                      ; bufbeg
1                           
1        0000067c                   .sect ".cinit"
1                                   .align  8
1        00000680 00000018          .field  STD_TARGWORDMAUS * 6
1        00000684 00000000+         .field  LOG_system    
1                               .if ($symcmp("circular", "fixed") = 0)    ; if (mode == "fixed")
1                                   .field  :bufbeg:+(:buflen: * STD_TARGWORDMAUS)-1 ; bufend = bufbeg+buflen-1
1                               .else                               ; else
1        00000688 00000000          .field  0                       ;    bufend = 0
1                               .endif
1        0000068c 00000000          .field  0                  ; flag
1        00000690 00000000          .field  0                       ; seqnum = 0
1        00000694 00000000-         .field  LOG_system$buf                ; curptr
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  166

1                                                                   ; lenmask (= buflen-1)
1        00000698 00000FFF          .field  (0400H * STD_TARGWORDMAUS)-1
1        0000069c 00000000-         .field  LOG_system$buf                ; bufbeg
1        00000018               .sect    ".log"
1                           
     956                    
     957                    ;; ======== LOG_Obj trace ========
     958                    ;; <add comments here>
     959                    ;;
     960                    ;; LOG_Obj trace (bufseg, buflen, logtype)
     961                            .global trace
     962                            .asg SDRAM, _bufseg
     963                            .asg 0400H, _buflen
     964                            .asg "circular", _logtype
     965 00000018                   LOG_Obj 1, trace, 0, _bufseg, _buflen, _logtype
1        00000018                   CHK_domain LOG_Obj, mode, "circular,fixed", "circular"
2                           
1                                   .asg "circular", mode
1                                   .if ($isdefed("LOG_NOOP") = 1)
1                                       .mexit
1                               .elseif ($symcmp("circular", "error") = 0)
1                                   .emsg "LOG_Obj mode error."
1                                   .endif
1                           
1                                   .global trace$buf
1                                   .global trace$size
1                           
1                                   .var    bufbeg
1                                   .var    flag
1                                   .if ((1 != 0) & (0400H > 0))
1                                       .if (((0400H - 1) & 0400H) != 0)
1                                           .emsg   "The LOG :name: buffer size must be a power of 2"
1                                       .endif
1                           
1                                       .asg        0, flag         ; enable LOG
1                                       .asg        "trace$buf", bufbeg
1                           
1                                                                  ;
1                                                                  ; place log buffers into 
1                                                                                                      ; .log0, .log1, etc. sectio
1                                       
1        00000018                       GBL_Obj     trace$buf, buflen, ".trace$buf", "noalign", -1, 1
2        00000018                   CHK_domain "GBL_Obj", alignFlag, "noalign,align", "noalign"
3                           
2                                   .if ($symcmp("noalign", "error") = 0)
2                                       .emsg "GBL_Obj align parameter error."
2                                   .endif
2                                   .asg "noalign", alignFlag
2                           
2        00000018                   CHK_nargs "GBL_Obj", size
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "GBL_Obj size parameter error."
2                                   .endif
2                           
2                                   .if ($symlen(section) = 0)
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  167

2                                       .asg ".bss", section
2                                   .endif
2                           
2                                   .if ($symlen(fillValue) != 0)
2        00000030                       .sect ".gblinit"
2        00000030 00000400              .word 0400H
2        00000034 00000000-             .word trace$buf
2        00000038 FFFFFFFF              .word -1
2                                   .endif
2                           
2                                   .if (($symcmp(section, ".data") = 0) | ($symcmp(alignFlag, "align") = 0))
2                                       .sect ":section:"
2                                       .if ($symcmp(alignFlag, "align") = 0)
2                                           .align  :alignValue:
2                                       .endif
2                           :name::
2                                       ;
2                                       ; Can't use .space directive here because it reserves
2                                       ; bits for some processors and bytes for others.
2                                       ;
2                                       .loop       :size:
2                                           .word 0
2                                       .endloop
2                           
2                                   .elseif ($symcmp(".trace$buf", ".bss") = 0)
2                                       .bss :name:, :size: * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS / STD_TARGC
2                                   .else
2        00000000           trace$buf:     .usect ".trace$buf", 0400H * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS /
2                                   .endif
2                           
1                           
1                 00000400  trace$size .set        0400H
1                           
1                                   .else
1                                       .asg        1, flag         ; disable LOG
1                                       .asg        0, bufbeg
1                           :name:$buf  .set        0
1                           :name:$size .set        0
1                                   .endif
1                           
1        00000018                   .sect ".log"                    ; place all LOG objects in
1                                                                   ; ".log"
1                                   .global trace                  ; make name globally visable
1                           trace  .tag    LOG_Obj                 ; declare name as having type
1                                                                   ; LOG_Obj
1                           
1        00000018           trace                                  ; allocate and initialize 
1                                                                   ; LOG_Obj (in current section)
1                           
1        00000018 00000000          .word    0                      ; bufend 
1        0000001c 00000000          .word    0                      ; flag
1        00000020 00000000          .word    0                      ; seqnum 
1        00000024 00000000          .word    0                      ; curptr
1        00000028 00000000          .word    0                      ; lenmask 
1        0000002c 00000000          .word    0                      ; bufbeg
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  168

1                           
1        000006a0                   .sect ".cinit"
1                                   .align  8
1        000006a0 00000018          .field  STD_TARGWORDMAUS * 6
1        000006a4 00000018+         .field  trace    
1                               .if ($symcmp("circular", "fixed") = 0)    ; if (mode == "fixed")
1                                   .field  :bufbeg:+(:buflen: * STD_TARGWORDMAUS)-1 ; bufend = bufbeg+buflen-1
1                               .else                               ; else
1        000006a8 00000000          .field  0                       ;    bufend = 0
1                               .endif
1        000006ac 00000000          .field  0                  ; flag
1        000006b0 00000000          .field  0                       ; seqnum = 0
1        000006b4 00000000-         .field  trace$buf                ; curptr
1                                                                   ; lenmask (= buflen-1)
1        000006b8 00000FFF          .field  (0400H * STD_TARGWORDMAUS)-1
1        000006bc 00000000-         .field  trace$buf                ; bufbeg
1        00000030               .sect    ".log"
1                           
     966                    
     967                    ;; ======== STS_Obj IDL_busyObj ========
     968                    ;; This object is required by the system to accumulate CPU load statistics
     969                    ;;
     970                    ;; STS_Obj IDL_busyObj (prev, prevlow)
     971                            .global IDL_busyObj
     972                            .asg 00H, _prev
     973                            .asg 00H, _prevlow
     974 00000030                   STS_Obj 1, IDL_busyObj, 0, _prev, _prevlow
1                           
1        00000030                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global IDL_busyObj, IDL_busyObj$stsobj     
1                           
1        00000030                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           IDL_busyObj  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000030           IDL_busyObj$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000030 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000034           IDL_busyObj                                   
1        00000034 00000000          .long   0                         ; num
1        00000038 00000000          .long   0                         ; acc
1        0000003c 80000000          .long   80000000h                 ; max
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  169

1        000006c0                   .sect    ".cinit"
1                                   .align    8
1        000006c0 00000010          .field    STD_TARGWORDMAUS * 4
1        000006c4 00000030+         .field    IDL_busyObj$stsobj                    
1        000006c8 00000000          .field    00H                  ; allocate space for history   
1        000006cc 00000000          .field    0                        ; num
1        000006d0 00000000          .field    0                        ; acc
1        000006d4 80000000          .field    80000000h                ; max
1                           
1        00000040                   .sect    ".sts"
1                           
     975                    
     976                    ;; ======== STS_Obj stsCycleTime ========
     977                    ;; <add comments here>
     978                    ;;
     979                    ;; STS_Obj stsCycleTime (prev, prevlow)
     980                            .global stsCycleTime
     981                            .asg 00H, _prev
     982                            .asg 00H, _prevlow
     983 00000040                   STS_Obj 1, stsCycleTime, 0, _prev, _prevlow
1                           
1        00000040                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsCycleTime, stsCycleTime$stsobj     
1                           
1        00000040                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsCycleTime  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000040           stsCycleTime$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000040 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000044           stsCycleTime                                   
1        00000044 00000000          .long   0                         ; num
1        00000048 00000000          .long   0                         ; acc
1        0000004c 80000000          .long   80000000h                 ; max
1                           
1        000006d8                   .sect    ".cinit"
1                                   .align    8
1        000006d8 00000010          .field    STD_TARGWORDMAUS * 4
1        000006dc 00000040+         .field    stsCycleTime$stsobj                    
1        000006e0 00000000          .field    00H                  ; allocate space for history   
1        000006e4 00000000          .field    0                        ; num
1        000006e8 00000000          .field    0                        ; acc
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  170

1        000006ec 80000000          .field    80000000h                ; max
1                           
1        00000050                   .sect    ".sts"
1                           
     984                    
     985                    ;; ======== STS_Obj stsDispTime ========
     986                    ;; <add comments here>
     987                    ;;
     988                    ;; STS_Obj stsDispTime (prev, prevlow)
     989                            .global stsDispTime
     990                            .asg 00H, _prev
     991                            .asg 00H, _prevlow
     992 00000050                   STS_Obj 1, stsDispTime, 0, _prev, _prevlow
1                           
1        00000050                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsDispTime, stsDispTime$stsobj     
1                           
1        00000050                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsDispTime  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000050           stsDispTime$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000050 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000054           stsDispTime                                   
1        00000054 00000000          .long   0                         ; num
1        00000058 00000000          .long   0                         ; acc
1        0000005c 80000000          .long   80000000h                 ; max
1                           
1        000006f0                   .sect    ".cinit"
1                                   .align    8
1        000006f0 00000010          .field    STD_TARGWORDMAUS * 4
1        000006f4 00000050+         .field    stsDispTime$stsobj                    
1        000006f8 00000000          .field    00H                  ; allocate space for history   
1        000006fc 00000000          .field    0                        ; num
1        00000700 00000000          .field    0                        ; acc
1        00000704 80000000          .field    80000000h                ; max
1                           
1        00000060                   .sect    ".sts"
1                           
     993                    
     994                    ;; ======== STS_Obj stsExeTimeChJpegDec ========
     995                    ;; <add comments here>
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  171

     996                    ;;
     997                    ;; STS_Obj stsExeTimeChJpegDec (prev, prevlow)
     998                            .global stsExeTimeChJpegDec
     999                            .asg 00H, _prev
    1000                            .asg 00H, _prevlow
    1001 00000060                   STS_Obj 1, stsExeTimeChJpegDec, 0, _prev, _prevlow
1                           
1        00000060                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsExeTimeChJpegDec, stsExeTimeChJpegDec$stsobj     
1                           
1        00000060                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsExeTimeChJpegDec  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000060           stsExeTimeChJpegDec$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000060 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000064           stsExeTimeChJpegDec                                   
1        00000064 00000000          .long   0                         ; num
1        00000068 00000000          .long   0                         ; acc
1        0000006c 80000000          .long   80000000h                 ; max
1                           
1        00000708                   .sect    ".cinit"
1                                   .align    8
1        00000708 00000010          .field    STD_TARGWORDMAUS * 4
1        0000070c 00000060+         .field    stsExeTimeChJpegDec$stsobj                    
1        00000710 00000000          .field    00H                  ; allocate space for history   
1        00000714 00000000          .field    0                        ; num
1        00000718 00000000          .field    0                        ; acc
1        0000071c 80000000          .field    80000000h                ; max
1                           
1        00000070                   .sect    ".sts"
1                           
    1002                    
    1003                    ;; ======== STS_Obj stsExeTimeChJpegEnc ========
    1004                    ;; <add comments here>
    1005                    ;;
    1006                    ;; STS_Obj stsExeTimeChJpegEnc (prev, prevlow)
    1007                            .global stsExeTimeChJpegEnc
    1008                            .asg 00H, _prev
    1009                            .asg 00H, _prevlow
    1010 00000070                   STS_Obj 1, stsExeTimeChJpegEnc, 0, _prev, _prevlow
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  172

1        00000070                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsExeTimeChJpegEnc, stsExeTimeChJpegEnc$stsobj     
1                           
1        00000070                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsExeTimeChJpegEnc  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000070           stsExeTimeChJpegEnc$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000070 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000074           stsExeTimeChJpegEnc                                   
1        00000074 00000000          .long   0                         ; num
1        00000078 00000000          .long   0                         ; acc
1        0000007c 80000000          .long   80000000h                 ; max
1                           
1        00000720                   .sect    ".cinit"
1                                   .align    8
1        00000720 00000010          .field    STD_TARGWORDMAUS * 4
1        00000724 00000070+         .field    stsExeTimeChJpegEnc$stsobj                    
1        00000728 00000000          .field    00H                  ; allocate space for history   
1        0000072c 00000000          .field    0                        ; num
1        00000730 00000000          .field    0                        ; acc
1        00000734 80000000          .field    80000000h                ; max
1                           
1        00000080                   .sect    ".sts"
1                           
    1011                    
    1012                    ;; ======== STS_Obj stsCapTime ========
    1013                    ;; <add comments here>
    1014                    ;;
    1015                    ;; STS_Obj stsCapTime (prev, prevlow)
    1016                            .global stsCapTime
    1017                            .asg 00H, _prev
    1018                            .asg 00H, _prevlow
    1019 00000080                   STS_Obj 1, stsCapTime, 0, _prev, _prevlow
1                           
1        00000080                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  173

1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsCapTime, stsCapTime$stsobj     
1                           
1        00000080                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsCapTime  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000080           stsCapTime$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000080 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000084           stsCapTime                                   
1        00000084 00000000          .long   0                         ; num
1        00000088 00000000          .long   0                         ; acc
1        0000008c 80000000          .long   80000000h                 ; max
1                           
1        00000738                   .sect    ".cinit"
1                                   .align    8
1        00000738 00000010          .field    STD_TARGWORDMAUS * 4
1        0000073c 00000080+         .field    stsCapTime$stsobj                    
1        00000740 00000000          .field    00H                  ; allocate space for history   
1        00000744 00000000          .field    0                        ; num
1        00000748 00000000          .field    0                        ; acc
1        0000074c 80000000          .field    80000000h                ; max
1                           
1        00000090                   .sect    ".sts"
1                           
    1020                    
    1021                    ;; MODULE INITIALIZATION
    1022 00000000                   .sect ".sysinit"
    1023                            .global BIOS_init, _BIOS_init
    1024 00000000           BIOS_init:
    1025 00000000           _BIOS_init:
    1026 00000000                   GBL_preamble
1        00000000 01BC54F6          stw     b3, *b15--[2]
1                           
    1027 00000004                   GBL_init
1                           
1                                   ; call GBL_F_version
1        00000004 0180002A!         mvkl    GBL_F_version, b3
1        00000008 0180006A!         mvkh    GBL_F_version, b3
1        0000000c 000C0362          b b3
1        00000010 01800E2A+         mvkl versret?,b3
1        00000014 0180006A+         mvkh versret?,b3
1        00000018 00004000          nop 3 
1        0000001c           versret?:
1        0000001c 00824828          mvkl    GBL_A_VERSION, a1
1        00000020 00800068          mvkh    GBL_A_VERSION, a1
1                            
1        00000024 009028C0          sub a4,a1,a1
1        00000028 00840A58          cmpeq a1,0,a1
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  174

1                           
1        0000002c           selfspin? 
1                           
1        0000002c 90000192   [!a1]  b selfspin? 
1                           
1                                   ; only call user init function if non-zero
1                                   .if (GBL_USERINIT != 0)
1                                   ; USERINITFXN below is defined in GBL_config
1        00000030 0180002A!             mvkl _dm642_init, b3
1        00000034 0180006A!             mvkh _dm642_init, b3
1        00000038 000C0362              b b3
1        0000003c 0180242A+             mvkl ginit?, b3
1        00000040 0180006A+             mvkh ginit?, b3
1        00000044 00004000              nop 3
1                           ginit?:
1                                   .endif
1                           
1                                   .global HWI_A_VECS
1                           
1        00000048 00000028!         mvkl HWI_A_VECS,a0
1        0000004c 00000068!         mvkh HWI_A_VECS,a0
1        00000050 028013A2          mvc a0,istp                 ; load interrupt service table pointer
1                           
1        00000054 00000028          mvkl HWI_REGS,a0            ; load addr of Interrupt Selector Regs
1        00000058 0000CE68          mvkh HWI_REGS,a0
1                           
1        0000005c 009CD1AA          mvkl HWI_INTRMULTHIGH,b1    ; Value for Interrupt Multiplexer High
1        00000060 0084106A          mvkh HWI_INTRMULTHIGH,b1
1        00000064 00803676          stw b1,*a0++                ; Store into Interrupt Multiplexer High
1                           
1        00000068 008C522A          mvkl HWI_INTRMULTLOW,b1     ; Value for Interrupt Multiplexer Low
1        0000006c 009283EA          mvkh HWI_INTRMULTLOW,b1
1        00000070 00803676          stw b1,*a0++                ; Store into Interrupt Multiplexer Low
1                           
1        00000074 0080002A          mvkl HWI_POLARITYMASK,b1    ; Value for External Interrupt Polarity
1        00000078 0080006A          mvkh HWI_POLARITYMASK,b1
1        0000007c 00800276          stw b1,*a0                  ; Store into External Interrupt Polarity
1                           
1        00000080 00008000          nop 5                       ; allow settling for possible spurious
1        00000084 00008000          nop 5                       ; interrupts (10 cycles, per TI)
1                           
1        00000088 00FCA35A          mvk 0xffffffff,b1           ; clear any bits in IFR using ICR
1        0000008c 018403A2          mvc b1,icr
1                           
1        00000090 009003E2          mvc ier,b1
1        00000094 008448F2          or 2,b1,b1
1        00000098 020403A2          mvc b1,ier                  ; set NMIE bit (required to enable ISRs)
1                           
1                                   .if GBL_SUPPORTCSL
1                                       .ref    _GBL_cslInit
1                           
1        0000009c 0000002A!             mvkl    _GBL_cslInit, b0
1        000000a0 0000006A!             mvkh    _GBL_cslInit, b0
1        000000a4 00000362              b       b0
1        000000a8 01805A2A+             mvkl    hwi_init_ret?, b3
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  175

1        000000ac 0180006A+             mvkh    hwi_init_ret?, b3
1        000000b0 00004000              nop 3
1                           
1                           hwi_init_ret?:
1                                       .if GBL_CALLCSLCFGINIT
1                                           .ref        _CSL_cfgInit
1                           
1        000000b4 0080002A!                 mvkl        _CSL_cfgInit, b1
1        000000b8 0080006A!                 mvkh        _CSL_cfgInit, b1
1        000000bc 00040362                  b b1
1        000000c0 0180662A+                 mvkl        hwi_cslcfg_init_ret?, b3
1        000000c4 0180006A+                 mvkh        hwi_cslcfg_init_ret?, b3
1        000000c8 00004000                  nop 3
1                                       .endif
1                           hwi_cslcfg_init_ret?:
1                           
1                                   .endif
1                           
1                                   ; 
1                                   ; L2 CACHE initialization
1                                   ;
1                                   
1                                   .if (GBL_L2CONFIGURE != 0)
1                                       .ref  _GBL_cslCacheInit
1                           
1                                       mvkl  _GBL_cslCacheInit, b0
1                                       mvkh  _GBL_cslCacheInit, b0
1                           
1                                       .if .TMS320C6400
1                                           mvkl GBL_L2MODE, a4
1                           ||              mvkl GBL_C641XL2PRIORITY, b4
1                                           mvkh GBL_L2MODE, a4
1                           ||              mvkh GBL_C641XL2PRIORITY, b4
1                                           mvkl GBL_L2MARMASK1, a6
1                           ||              mvkl GBL_L2MARMASK2, b6
1                                           mvkh GBL_L2MARMASK1, a6
1                           ||              mvkh GBL_L2MARMASK2, b6
1                                           mvkl GBL_L2MARMASK3, a8
1                           ||              mvkl GBL_L2MARMASK4, b8
1                                           b       b0
1                                           mvkh GBL_L2MARMASK3, a8
1                           ||              mvkh GBL_L2MARMASK4, b8
1                                           mvkl GBL_L2MARMASK5, a10
1                           ||              mvkl GBL_L2CONFIGALLOC, b10
1                                           mvkh GBL_L2MARMASK5, a10
1                           ||              mvkh GBL_L2CONFIGALLOC, b10
1                                           mvkl GBL_L2ALLOC, a12
1                           ||              mvkl  gbl_cslcacheinit_ret?, b3
1                                           mvkh GBL_L2ALLOC, a12
1                           ||              mvkh  gbl_cslcacheinit_ret?, b3
1                                       .else
1                                           b       b0
1                                           mvkl  GBL_L2MODE, a4
1                           ||              mvkl  GBL_L2MARMASK, b4
1                                           mvkh  GBL_L2MODE, a4
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  176

1                           ||              mvkh  GBL_L2MARMASK, b4
1                                           mvkl  gbl_cslcacheinit_ret?, b3
1                                           mvkh  gbl_cslcacheinit_ret?, b3
1                                           nop 2
1                                       .endif
1                           
1                                   
1                                   .endif  ; GBL_L2CONFIGURE
1                           
1        000000cc           gbl_cslcacheinit_ret?:
1                           
1                                   ;
1                                   ; CACHE initialization
1                                   ;
1                           
1        000000cc 000403E2          mvc     csr, b0                 ; get CSR
1                           
1        000000d0 0100A35A          mvk     GBL_CACHE, b2           ; get cache bits from configuration
1                           
1        000000d4 00807E2A          mvk     C62_CCFIELDS, b1
1        000000d8 008029B2          and     b1, b0, b1              ; extract pcc+dcc fields of csr
1        000000dc 00002BB2          xor     b1, b0, b0              ; clear pcc+dcc fields of csr
1        000000e0 000048B2          or      b2, b0, b0              ; change pcc and dcc fields
1                           
1        000000e4 008003A2          mvc     b0, csr                 ; save CSR with new cache state
1                           
1                                   ;
1                                   ;  Calling TRC_init from here until there is at trc.cdb file.
1                                   ;
1        000000e8                   TRC_init
2                                   ; TRC is always configured, so until we have a trc.cdb
2                                   ; file, don't check if module is configured.
2        000000e8 02000028+         mvkl TRC_cinit, a4
2        000000ec 02000068+         mvkh TRC_cinit, a4
2        000000f0 02100264          ldw *a4, a4
2        000000f4 01000228+         mvkl TRC_R_mask, a2
2        000000f8 01000068+         mvkh TRC_R_mask, a2
2        000000fc 00002000          nop 2
2        00000100 02080274          stw a4, *a2
2                           
1                           
1                                   ;
1                                   ;  fill memory using triples (nwords, addr, value) from 
1                                   ;  gblinit table.
1                                   ;
1        00000104 02000028+         mvkl    gblinit, a4
1        00000108 02000068+         mvkh    gblinit, a4
1                           
1        0000010c           loop0?:
1        0000010c 00103666          ldw     *a4++[1], b0            ; nwords
1        00000110 00103664          ldw     *a4++[1], a0            ; address
1        00000114 01103666          ldw     *a4++[1], b2            ; value
1        00000118 00004000          nop     3
1        0000011c 30000812   [!b0]  b       done?
1        00000120 00008000          nop     5
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  177

1                           
1        00000124           loop1?:
1        00000124 01003676          stw     b2, *a0++[1]
1        0000012c 000029C2          sub     b0, 1, b0
1        00000130 20000092   [b0]   b       loop1?
1        00000134 00008000          nop     5
1                           
1        00000138 0FFFFD92          b       loop0?
1        0000013c 00008000          nop     5
1        00000140           done?:
1        00000140 0104A359          mvk     1, a2
1        00000144 0100042A+  ||     mvkl    GBL_initdone, b2
1        00000148 0100006A+         mvkh    GBL_initdone, b2
1        0000014c 010802F4          stw     a2, *b2
1                           
    1028 00000150                   SEM_init
1                           
1                                   ; only expand if the SEM module is configured
1                                   .if (SEM$ = 1)
1                                   .endif
1                           
    1029 00000150                   MEM_init
1                           
1                                   ; only expand if dyanmic memory heaps on configured by the user
1                                   .if (MEM_gNumHeap > 0)
1                                           .global _MEM_init
1                           
1        00000150 02000028!                 mvkl    _MEM_init, a4
1        00000154 02000068!                 mvkh    _MEM_init, a4
1        00000158 00101362                  b       a4
1        0000015c 0180B42A+                 mvkl    meminit?, b3
1        00000160 0180006A+                 mvkh    meminit?, b3
1        00000164 00004000                  nop     3
1                           meminit?:
1                           
1                                   .endif              
1                           
    1030 00000168                   OBJ_init
    1031 00000168                   BUF_init
1                           
1                                   ; only expand if the BUF module is configured
1                                   .if (BUF$ = 1)
1                                      .ref __BUF_init
1                            
1        00000168 02000028!            mvkl   __BUF_init,a4
1        0000016c 02000068!            mvkh   __BUF_init,a4
1        00000170 00101362             b      a4
1        00000174 0180C02A+            mvkl   bufstart?, b3
1        00000178 0180006A+            mvkh   bufstart?, b3
1        0000017c 00004000             nop 3
1                           bufstart?:
1                           
1                                   .endif
1                           
    1032 00000180                   CLK_init
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  178

1                           
1                                   ; only expand if the CLK module is configured by the user and he/she/it
1                                   ; asks to use the timer
1                                   .if ((CLK$ = 1) & (CLK_USETIMER = 1))
1                                   .endif
1                           
    1033 00000180                   PRD_init
1                           
1                                   ; only expand if the PRD module is configured by the user 
1                                   .if (PRD$ = 1) 
1                                   .endif
1                           
    1034 00000180                   RTDX_init
    1035 00000180                   IDL_init
1                           
1                               ; only expand if the IDL module is configured by the user
1                               .if (IDL$ = 1)
1                                   .if (01H)         ; defined in IDL_config
1                           
1                                       .def BIOS$$CLKON, BIOS$$CLKOFF
1                           
1        00000180           BIOS$$CLKON:
1                                   ; BIOS$$CLKON signals to the C6x fast simulators to switch into 
1                                   ; cycle-accurate mode.
1                                   ; This is to make the calibration of the IDL loop accurate, so that
1                                   ; CPU load, which is based on this calibration, will also be accurate.
1                                   ; The bookend label to this is BIOS$$CLKOFF.
1                           
1                                   ; Perform calibration twice; first time fills cache (6211), and 
1                                   ; second time yields the accurate calibration value. 
1        00000180 0080006C!         ldw *+b14(IDL_D_calibrate),a1
1        00000184 0180CC2A+         mvkl idlinit1?,b3
1        00000188 0180006A+         mvkh idlinit1?,b3
1        0000018c 00002000          nop 2
1        00000190 00041362          b a1
1        00000194 00008000          nop 5
1        00000198           idlinit1?:
1        00000198 0080006C!         ldw *+b14(IDL_D_calibrate),a1
1        0000019c 0180D82A+         mvkl idlinit2?,b3
1        000001a0 0180006A+         mvkh idlinit2?,b3
1        000001a4 00002000          nop 2
1        000001a8 00041362          b a1
1        000001ac 00008000          nop 5
1                           
1        000001b0           BIOS$$CLKOFF:
1                                   ; BIOS$$CLKOFF signals to the C6x fast simulators to switch out of 
1                                   ; cycle-accurate mode. This is the bookend label to BIOS$$CLKON.
1                           
1                                   ; Reset the IDL_busyObj values, and clear the "prev" value so the
1                                   ; first pass through the real IDL loop won't produce a garbage
1                                   ; value. The STS_reset API is not being used because the prev
1                                   ; value is not cleared in STS_reset, so doing it this way uses
1                                   ; less than half as many instructions as using the APIs. dsg-2/9/01
1        000001b0           idlinit2?:
1        000001b0 0200006C!         ldw *+b14(IDL_D_busyObj),a4  ; load IDL_busyObj address to a4
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  179

1        000001b4 0080A358          zero a1
1        000001b8 00004000          nop 3
1        000001bc 00902074          stw a1,*-a4(4)      ; clear prev
1        000001c0 00900274              stw a1,*+a4(0)              ; clear num
1        000001c4 00902274              stw a1,*+a4(4)              ; clear acc
1        000001c8 00C00068              mvklh 8000h, a1             ; form largest negative number
1        000001cc 00904274              stw a1,*+a4(8)              ; set max
1                                   .endif
1                               .endif
1                           
    1036 000001d0                   LCK_init
1                           
1                                   ; only expand if the LCK module is configured
1                                   .if (LCK$ = 1)
1                                   .endif
1                           
    1037 000001d0                   LOG_init
1                                   ; only expand if the LOG module is configured by the user
1                                   .if (LOG$ = 1)
1                                   .endif
1                           
    1038 000001d0                   MBX_init
1                           
1                                   ; only expand if the MBX module is configured
1                                   .if (MBX$ = 1)
1                                   .endif
1                           
    1039 000001d0                   PIP_init
    1040 000001d0                   QUE_init
    1041 000001d0                   STS_init
1                           
1                                   ; only expand if the STS module is configured
1                                   .if (STS$ = 1)
1                                   .endif
1                           
    1042 000001d0                   SYS_init
1                           
1                                   ; only expand if the SYS module is configured
1                                   .if (SYS$ = 1)
1                                   .endif
1                           
    1043 000001d0                   HWI_init
    1044 000001d0                   HST_init
1                                   ; only expand if the HST module is configured by the user
1                                   .if(HST$ != 0)
1        000001d0                       LNK_init    ; do any required LNK initialization
2                                   ;
2                                   ; no need to call LNK_F_init when it's an empty function
2                                   ;
1                                   .endif
    1045 000001d0                   DEV_init
1                                   .if DEV$NUMDEVICES != 0
1                           
1                                       .global     _DEV_init
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  180

1        000001d0 02000028!             mvkl        _DEV_init, a4
1        000001d4 02000068!             mvkh        _DEV_init, a4
1        000001d8 00101362              b           a4
1        000001dc 0180F42A+             mvkl        devinit?, b3
1        000001e0 0180006A+             mvkh        devinit?, b3
1        000001e4 00004000              nop 3
1                           devinit?:
1                           
1                                   .endif
1                           
    1046 000001e8                   UDEV_init
    1047 000001e8                   DGN_init
    1048 000001e8                   DHL_init
    1049 000001e8                   DPI_init
    1050 000001e8                   SIO_init
1                           
1                                   .if SIO$NUMOF != 0
1                           
1                                       .global     _SIO_init
1                           
1                                       mvkl        _SIO_init, a4
1                                       mvkh        _SIO_init, a4
1                                       b           a4
1                                       mvkl        siostart?, b3
1                                       mvkh        siostart?, b3
1                                       nop 3
1                           siostart?:
1                           
1                                   .endif
1                           
    1051 000001e8                   SWI_init
1                                   ; only expand if the SWI module is configured by the user
1                                   .if (SWI$ = 1)
1                                   .endif
1                           
    1052 000001e8                   HOOK_init
1                           
1                                   ; only expand if the HOOK module is configured
1                                   .if (HOOK$ = 1)
1                           
1                                   .ref    __HOOK_doInit
1                           
1                                   mvkl    __HOOK_doInit, a0
1                                   mvkh    __HOOK_doInit, a0
1                                   b       a0
1                                   mvkl    init_ret, b3
1                                   mvkh    init_ret, b3
1                                   nop     3
1                           init_ret:
1                           
1                                   .endif
1                           
    1053 000001e8                   TSK_init
1                           
1                                   ; only expand if the TSK module is configured
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  181

1                                   .if (TSK$ = 1)
1                           
1                                       .global _TSK_init
1                                       .global _TSK_setup
1                           
1        000001e8 02000028!             mvkl        _TSK_init, a4
1        000001ec 02000068!             mvkh        _TSK_init, a4
1        000001f0 00101362              b           a4
1        000001f4 0181002A+             mvkl        tskinit?, b3
1        000001f8 0180006A+             mvkh        tskinit?, b3
1        000001fc 00004000              nop         3
1                           
1                           tskinit?:
1                                       .if TSK$NUMOF != 0
1                           
1        00000200 02000028!                 mvkl    _TSK_setup, a4
1        00000204 02000068!                 mvkh    _TSK_setup, a4
1        00000208 00101362                  b       a4
1        0000020c 01810C2A+                 mvkl    tskstup?, b3      ; return address
1        00000210 0180006A+                 mvkh    tskstup?, b3
1        00000214 00004000                  nop     3
1                                       .else
1                                           .emsg "There must be at least one task defined under TSK."
1                                       .endif
1                           
1                           tskstup?:
1                           
1                                   .endif
1                           
    1054 00000218                   ISRC_init
    1055 00000218                   GIO_init
1                           
1                                   ; only expand if the GIO module is configured
1                                   .if (GIO$ = 1)
1                                   .endif
1                           
    1056 00000218                   DIO_init
    1057 00000218                   GBL_postamble
1        00000218 01BC52E6          ldw     *++b15[2], b3
1        0000021c 00006000          nop     4
1        00000220 000C0362          b       b3
1        00000224 00008000          nop     5
1                           
    1058                    
    1059                    ;; MODULE STARTUP
    1060 00000228                   .sect ".sysinit"
    1061                            .global BIOS_start, _BIOS_start
    1062 00000228           BIOS_start:
    1063 00000228           _BIOS_start:
    1064 00000228                   GBL_preamble
1        00000228 01BC54F6          stw     b3, *b15--[2]
1                           
    1065 0000022c                   GBL_startup
    1066 0000022c                   SEM_startup
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  182

1                                   .if     SEM$NUMOF != 0
1                                   .endif
    1067 0000022c                   MEM_startup
    1068 0000022c                   OBJ_startup
    1069 0000022c                   BUF_startup
1                           
1                                   .if     BUF$NUMOF != 0
1                                   .endif
    1070 0000022c                   CLK_startup
1                           
1                                   ; only expand if the CLK module is configured by the user and he/she
1                                   ; asks to use the timer
1                                   .if ((CLK$ = 1) & (CLK_USETIMER = 1))
1                                   
1                                   .if GBL_SUPPORTCSL
1                           
1                                       ;
1                                       ; Force a reference to the appropriate CLK_startXXX function.
1                                       ; CLK_start will be aliased to this function in the cfg.cmd file.
1                                       ;
1                                       ; A forced reference is necessary because no module directly
1                                       ; references this function, and the aliasing performed in the
1                                       ; linker command file cfg.cmd needs the symbol to be well
1                                       ; defined at the time of the alias, which is after the libraries
1                                       ; have already been scanned.  The following reference alone will
1                                       ; cause the function to be linked in from the BIOS library,
1                                       ; allowing the subsequent alias to be satisfied.
1                                       ;
1                                       .ref        _CLK_start6x            ; only one version now
1                                       .ref        _CLK_start
1                                   
1        0000022c 00000028!             mvkl        _CLK_start, a0
1        00000230 00000068!             mvkh        _CLK_start, a0
1        00000234 00001362              b   a0
1        00000238 0181222A+             mvkl        clk_startup_ret?, b3
1        0000023c 0180006A+             mvkh        clk_startup_ret?, b3
1        00000240 00004000              nop 3
1                           clk_startup_ret?:
1                           
1                                   .else
1                           
1                                       mvkl CLK_REGS,a0            ; get address to Timer Control register
1                                ||     mvkl CLK_CLKSRC,b2
1                                       mvkh CLK_REGS,a0
1                                ||     mvkh CLK_CLKSRC,b2
1                                       stw b2,*a0              ; write /HLD=0 and CLKSRC=1 to Timer Control
1                           
1                                       ; set the period
1                                       mvkl CLK_PRD, a1
1                                       mvkh CLK_PRD, a1
1                                       stw a1, *+a0[1]
1                           
1                                       ; start timer
1                                       ldw *a0, a1
1                                       mvk CLK_START,b1    ; get start mask
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  183

1                                       nop 3
1                                       or b1,a1,a1         ; set GO=1 and /HLD=1
1                                       stw a1,*a0          ; write to Timer Control to start timer
1                           
1                                       ; enable Timer interrupt in IER
1                                       mvkl CLK_INTBIT,a0
1                                       mvkh CLK_INTBIT,a0
1                                       mvc ier,b1
1                                       or a0,b1,b1         ; set CLK_INTBIT
1                                       mvc b1,ier
1                           
1                                   .endif
1                           
1                                   .endif
1                           
    1071 00000244                   PRD_startup
    1072 00000244                   RTDX_startup
    1073 00000244                   IDL_startup
    1074 00000244                   LCK_startup
1                           
1                                   .if     LCK$NUMOF != 0
1                                   .endif
    1075 00000244                   LOG_startup
    1076 00000244                   MBX_startup
1                           
1                                   .if     MBX$NUMOF != 0
1                                   .endif
    1077 00000244                   PIP_startup
1        00000244                   CHK_void PIP_startup, dummy
1                           
1                                   ; expand startup code only if some PIP objects are configured
1                                   .if((PIP$ + PIP_gNumEmbed) !=0 )
1        00000244 0200002A!             mvkl PIP_F_start,b4         ; set up for far branch
1        00000248 0200006A!             mvkh PIP_F_start,b4
1        0000024c 00100362              b b4                        ; start branch to startup function
1        00000250 02000028!             mvkl PIP_D_tabbeg,a4        ; set a4 for PIP_F_start call
1        00000254 02000068!             mvkh PIP_D_tabbeg,a4
1        00000258 00000000              nop
1        0000025c 0181322A+             mvkl pips?,b3               ; set return for here
1        00000260 0180006A+             mvkh pips?,b3
1                                   .endif
1                           
1                           pips?:  
1                           
    1078 00000264                   QUE_startup
    1079 00000264                   STS_startup
    1080 00000264                   SYS_startup
    1081 00000264                   HWI_startup
1                           
1                                   ; globally enable interrupts
1        00000264                   HWI_enable
2        00000264 00000312          b hwie?
2        00000268 000403E2          mvc csr,b0
2        0000026c 000028F2          or GIE,b0,b0
2        00000270 008003A2          mvc b0,csr      
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  184

2        00000274 00002000          nop 2
2                           hwie?:
1                           
    1082 00000278                   HST_startup
    1083 00000278                   DEV_startup
    1084 00000278                   UDEV_startup
    1085 00000278                   DGN_startup
1                                   .if     DGN$NUMOF != 0
1                           
1                                   ;
1                                   ; DGN_init is #defined as SYS_nop in dgn.h,
1                                   ; so we won't do anything here.
1                                   ;
1                                   ;.global _DGN_init
1                                   ; call   _DGN_init
1                           
1                                   .endif
    1086 00000278                   DHL_startup
1                                   .if     DHL$NUMOF != 0
1                           
1                                   .endif
    1087 00000278                   DPI_startup
1                                   .if     DPI$NUMOF != 0
1                                   .endif
    1088 00000278                   SIO_startup
    1089 00000278                   SWI_startup
1        00000278                   CHK_void SWI_startup, dummy
1                           
1                                   ; only expand if the SWI module is configured by the user
1                                   .if (SWI$ = 1)
1        00000278 02000028!             mvkl SWI_F_enable,a4                ; prepare for far branch
1        0000027c 02000068!             mvkh SWI_F_enable,a4
1        00000280 00101362              b a4                        ; start branch to SWI_F_enable  
1        00000284 0181482A+             mvkl swii?,b3               ; setup b3 pointer to come back here
1        00000288 0180006A+             mvkh swii?,b3
1        0000028c 00004000              nop 3
1                           swii?:
1                                   .endif  
    1090 00000290                   HOOK_startup
1                           
1                                   ; only expand if the HOOK module is configured
1                                   .if (HOOK$ = 1)
1                           
1                                   .endif
1                           
    1091 00000290                   TSK_startup
1                           
1                                   ; only expand if the TSK module is configured
1                                   .if (TSK$ = 1)
1                           
1                                       .global _TSK_startup
1                           
1                                       .if TSK$NUMOF != 0
1                           
1        00000290 02000028!                 mvkl _TSK_startup, a4
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  185

1        00000294 02000068!                 mvkh _TSK_startup, a4
1        00000298 00101362                  b    a4
1        0000029c 0181542A+                 mvkl tskstup?, b3      ; return address
1        000002a0 0180006A+                 mvkh tskstup?, b3
1        000002a4 00004000                  nop  3
1                           
1                                       .endif
1                           
1                           tskstup?:
1                                   .endif
    1092 000002a8                   ISRC_startup
    1093 000002a8                   GIO_startup
    1094 000002a8                   DIO_startup
    1095 000002a8                   GBL_postamble
1        000002a8 01BC52E6          ldw     *++b15[2], b3
1        000002ac 00006000          nop     4
1        000002b0 000C0362          b       b3
1        000002b4 00008000          nop     5
1                           
    1096                    
    1097                    ;; EPILOGUE
    1098 000002b8                   GBL_end
1                           
1        0000003c                   .sect ".gblinit"
1        0000003c 00000000          .word 0                 ; end of gblinit table marker
1                           
    1099 00000040                   MEM_end
    1100 00000040                   OBJ_end
1                           
1                                   ;
1                                   ;  We only need the OBJ_table if any of the objects in the modules
1                                   ;  below are created in the configuration, or if they can be created
1                                   ;  dynamically (requires heaps).
1                                   ;
1                                   .if (MEM_gNumHeap > 0) | MBX$ | SEM$ | SIO$ | TSK$ | DEV$NUMDEVICES | BUF$
1                           
1                                    .global _OBJ_table
1        00000030                   .bss    _OBJ_table, OBJ_MODULES * STD_TARGWORDMAUS * 2, STD_TARGWORDMAUS
1                           
1        00000750                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000750 00000038          .word   OBJ_MODULES * STD_TARGWORDMAUS * 2
1        00000754 00000030-         .word   _OBJ_table
1        00000758 00000030-         .word   _OBJ_table + 0 * STD_TARGWORDMAUS, _OBJ_table + 0 * STD_TARGWORDMAUS
         0000075c 00000030-
1        00000760 00000038-         .word   _OBJ_table + 2 * STD_TARGWORDMAUS, _OBJ_table + 2 * STD_TARGWORDMAUS
         00000764 00000038-
1        00000768 00000000-         .word   TSK_idle$obj, TSK_image$obj
         0000076c 00000060-
1        00000770 00000048-         .word   _OBJ_table + 6 * STD_TARGWORDMAUS, _OBJ_table + 6 * STD_TARGWORDMAUS
         00000774 00000048-
1        00000778 00000050-         .word   _OBJ_table + 8 * STD_TARGWORDMAUS, _OBJ_table + 8 * STD_TARGWORDMAUS
         0000077c 00000050-
1        00000780 00000000-         .word   UDEV_VP0CAPTURE$obj, UDEV_VP2DISPLAY$obj
         00000784 00000048-
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  186

1        00000788 00000000-         .word   BUF_imgPool$obj, BUF_copyPool$obj
         0000078c 00000028-
1                           
1                                   .endif
1                           
    1101 00000790                   BUF_end
    1102 00000790                   CLK_end
1                                   .if (CLK$NUMOF != 0)
1        00000790                       CLK_Obj     1,CLK_null,-1,0 ; NULL terminate clock isr fxn table
2        00000790                   CHK_nargs "CLK_Obj", fxn
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "CLK_OBJ parameter error."
2                                   .endif
2                           
2                                   .var fxnlen
2                                   .eval $symlen("0"),fxnlen
2                           
2                                   .if (1 = 0)
2                                       .mexit
2                                   .endif
2                           
2                                   .global CLK_null
2                           
2                                   .if ($symcmp("0", "0") != 0)
2                                   .global fxn
2                                   .endif
2                           
2                           CLK_null  .tag    CLK_Obj         ; declare name as having type CLK_Obj
2                           
2                           ; allocate all CLK objs contiguously in ".clk"
2        00000004           CLK_null        .usect ".clk", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        00000790                   .sect ".cinit"
2                           
2                                   .align  8
2                           
2        00000790 00000004          .field  STD_TARGWORDMAUS * 1
2                           
2        00000794 00000004-         .field  CLK_null    
2                           
2        00000798 00000000          .field  0           ; fxn
2                           
1                                   .endif
1                           
    1103 0000079c                   PRD_end
1                 00000000  PRD_SWIHANDLE .set 0
    1104 0000079c                   RTDX_end
    1105 0000079c                   HST_end
    1106 0000079c                   HWI_end
    1107 0000079c                   SWI_end
    1108 0000079c                   TSK_end
1                           
1                                   ; expand only if TSK is enabled.
1                                   .if (TSK$ == 1)
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  187

1                           ;
1                           ; The following two .bss/.cinit sets make configured values readable
1                           ; in the established SPOX manner, e.g., TSK->STACKSIZE.
1                           ;
1                           ;
1                           
1        00000068                   .bss    TSK_config,8 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000079c                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        000007a0 00000020          .word 8 * STD_TARGWORDMAUS
1        000007a4 00000068-         .word TSK_config
1        000007a8 00000000          .word SDRAM$idx
1        000007ac 00000001          .word TSK_PRIORITY
1        000007b0 00005000          .word TSK_STACKSIZE     ; This shall be interpreted as number of MAU's
1        000007b4 00000000!         .word TSK_VCREATEFXN
1        000007b8 00000000!         .word TSK_VDELETEFXN
1        000007bc 00000000!         .word TSK_VEXITFXN
1        000007c0 00000000          .word TSK_SWITCHFXN
1        000007c4 00000000          .word TSK_READYFXN
1                           
1                                   .def _TSK                       ; Pointer to configuration parameters
1        00000088                   .bss        _TSK, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        000007c8                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        000007c8 00000004          .word   1 * STD_TARGWORDMAUS
1        000007cc 00000088-         .word   _TSK
1        000007d0 00000068-         .word   TSK_config
1                           
1                                   ;
1                                   ; The startup stack will be borrowed from the idle task's stack.  The
1                                   ; startup stack must begin beyond the portion of the stack that is
1                                   ; statically initialized, so the __STACK_SIZE will be decremented by
1                                   ; that amount.
1                                   ;
1                           ;       .def    __stack, __STACK_SIZE
1                           
1                           ;__stack                .set    TSK_idle$stack
1                           ;__STACK_SIZE   .set    TSK_idle$stklen - (TSK_USEDSTACK * STD_TARGWORDMAUS)
1                           
1                                   .endif          ; if (TSK$ == 1)
1                           
    1109 000007d4                   IDL_end
1        000007d4               IDL_Obj 1,IDL_END,-1,0,1     ; NULL terminate idle function table
2        000007d4                   CHK_nargs "IDL_Obj", calibration
2                                   .if ($symcmp("", "error") = 0)
2                                       .mexit
2                                   .endif
2                           
2                               .var fxnlen
2                               .eval $symlen("0"),fxnlen
2                           
2                                   .if (1 = 0)   ; if this object is not really to be allocated
2                                       .mexit      ; exit quietly now
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  188

2                                   .endif
2                           
2                                   .global IDL_END$
2                                   .global IDL_END
2                           
2                                   .if ($symcmp("0", "0") != 0)
2                               .global :fxn:
2                                   .endif
2                           
2                           IDL_END$ .tag    IDL_Obj         ; declare name$ as having type IDL_Obj
2                           
2        0000000c           IDL_END$ .usect ".idlcal", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        000007d4                   .sect ".cinit"
2                           
2                               .align  8
2        000007d8 00000004      .field  STD_TARGWORDMAUS * 1
2        000007dc 0000000C-     .field  IDL_END$    
2                                   .if (1 != 0) ; if to be included in IDL calibration
2        000007e0 00000000              .field  0             ; fxn
2                               .else
2                                       .field  FXN_F_nop    ; else use FXN_F_nop
2                                   .endif
2                           
2                           IDL_END  .tag    IDL_Obj         ; declare name as having type IDL_Obj
2                           
2        0000000c           IDL_END  .usect ".idl", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        000007e4                   .sect ".cinit"
2                           
2                               .align  8
2        000007e8 00000004      .field  STD_TARGWORDMAUS * 1
2        000007ec 0000000C-     .field  IDL_END    
2        000007f0 00000000      .field  0           ; fxn
2                           
1                           
    1110 000007f4                   ISRC_end
    1111 000007f4                   LOG_end
    1112 000007f4                   PIP_end
    1113 000007f4                   SEM_end
    1114 000007f4                   MBX_end
    1115 000007f4                   QUE_end
    1116 000007f4                   LCK_end
    1117 000007f4                   SIO_end
    1118 000007f4                   STS_end
    1119 000007f4                   SYS_end
    1120 000007f4                   GIO_end
    1121 000007f4                   DEV_end
1                           
1                           ;
1                           ;  We reserve uninitialized space for the initialization table
1                           ;  (_DEV_devinit). This is a table that contains pointers to all the
1                           ;  initialization routines for all the devices.
1                           ;
1                           
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  189

1                                   .if (DEV$NUMDEVICES > 0)        ; expand only if devices are configured.
1                           
1                                   .global _DEV_devinit
1                                   .global _DEV_D_devinit          ; init pointer to _DEV_devinit
1                           
1        0000008c                   .bss    _DEV_devinit, 0 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        0000008c                   .bss    _DEV_D_devinit, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        000007f4                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        000007f8 00000004          .word   1 * STD_TARGWORDMAUS
1        000007fc 0000008C-         .word   _DEV_D_devinit
1        00000800 0000008C-         .word   _DEV_devinit
1                           
1                           ;
1                           ; __DEV_NUMINITFXNS keeps track of the number of initialization routines for
1                           ; device drivers that need to be called at initialization.
1                           ;
1                                   .global __DEV_NUMINITFXNS
1                                   .global __DEV_D_NUMINITFXNS     ; init pointer to DEV_NUMINITFXNS
1                           
1        00000090                   .bss    __DEV_NUMINITFXNS, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        00000094                   .bss    __DEV_D_NUMINITFXNS, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000804                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000808 00000004          .word   1 * STD_TARGWORDMAUS
1        0000080c 00000090-         .word   __DEV_NUMINITFXNS
1        00000810 00000000          .word   0
1                           
1                                   .align  STD_TARGALIGN
1        00000818 00000004          .word   1 * STD_TARGWORDMAUS
1        0000081c 00000094-         .word   __DEV_D_NUMINITFXNS
1        00000820 00000090-         .word   __DEV_NUMINITFXNS
1                           
1                                   .endif          ; .if (DEV$NUMDEVICES > 0)
1                           
    1122 00000824                   UDEV_end
    1123 00000824                   DGN_end
    1124 00000824                   DHL_end
1                           
1                                   ; expand only if there are DHL devices configured.
1                                   .if (0 > 0)
1                           
1                                       .global  __DHL_tab
1                                       .bss  __DHL_tab, DHL$count * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                       .global  __DHL_numof
1                                       .bss  __DHL_numof, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1                                       .word       1 * STD_TARGWORDMAUS
1                                       .word       __DHL_numof
1                                       .word       DHL$count
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  190

1                           
1                                   .endif
1                           
    1125 00000824                   DPI_end
    1126 00000824                   HOOK_end
1                           
1                                   ; expand only if HOOK is enabled.
1                                   .if (HOOK$ == 1)
1                           
1                                   .bss    __HOOK_initFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_createFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_deleteFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_exitFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_readyFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_switchFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                   .endif
1                           
1                                   ;
1                                   ; always define _HOOK_NUMHOOKS
1                                   ;
1                                   .def    __HOOK_NUMHOOKS
1                           
1        00000098                   .bss    __HOOK_NUMHOOKS, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000824                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000828 00000004          .word   1 * STD_TARGWORDMAUS
1        0000082c 00000098-         .word   __HOOK_NUMHOOKS
1        00000830 00000000          .word   0
1                           
    1127 00000834                   DIO_end
    1128                    
    1129                            .copy confend.s62
 +     1                    ;
 +     2                    ;  Copyright 2003 by Texas Instruments Incorporated.
 +     3                    ;  All rights reserved. Property of Texas Instruments Incorporated.
 +     4                    ;  Restricted rights to use, duplicate or disclose this code are
 +     5                    ;  granted through contract.
 +     6                    ;  
 +     7                    ;
 +     8                    ; "@(#) DSP/BIOS 4.90.270 01-13-05 (barracuda-o07)"
 +     9                    ;
 +    10                    ;  ======== confend.s62 ========
 +    11                    ;  The statements in this file are inserted at the end of 
 +    12                    ;  every BIOS configuration file.
 +    13                    ;
 +    14                            .include vers.h62
 +    15                    
 +    16 00000834                   VERS_create VERS$DATE, VERS$CDB, VERS$TREE, VERS$CDBRELATIVEPATH
1+       00000834                   CHK_nargs "VERS_create", tree
1+                                  .if ($symcmp("", "error") = 0)
1+                                      .mexit
1+                                  .endif
1+                          
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  191

1+       00000000                   .sect ".vers"
1+       00000000 00000054          .byte "Tue Jul 29 10:47:51 2008"
         00000001 00000075 
         00000002 00000065 
         00000003 00000020 
         00000004 0000004A 
         00000005 00000075 
         00000006 0000006C 
         00000007 00000020 
         00000008 00000032 
         00000009 00000039 
         0000000a 00000020 
         0000000b 00000031 
         0000000c 00000030 
         0000000d 0000003A 
         0000000e 00000034 
         0000000f 00000037 
         00000010 0000003A 
         00000011 00000035 
         00000012 00000031 
         00000013 00000020 
         00000014 00000032 
         00000015 00000030 
         00000016 00000030 
         00000017 00000038 
1+       00000018 00000000          .byte 0
1+       00000019 00000066          .byte "framework.cdb"
         0000001a 00000072 
         0000001b 00000061 
         0000001c 0000006D 
         0000001d 00000065 
         0000001e 00000077 
         0000001f 0000006F 
         00000020 00000072 
         00000021 0000006B 
         00000022 0000002E 
         00000023 00000063 
         00000024 00000064 
         00000025 00000062 
1+       00000026 00000000          .byte 0
1+       00000027 00000040          .byte "@(#)*** xdc-c38"
         00000028 00000028 
         00000029 00000023 
         0000002a 00000029 
         0000002b 0000002A 
         0000002c 0000002A 
         0000002d 0000002A 
         0000002e 00000020 
         0000002f 00000078 
         00000030 00000064 
         00000031 00000063 
         00000032 0000002D 
         00000033 00000063 
         00000034 00000033 
         00000035 00000038 
TMS320C6x COFF Assembler PC v5.1.0 Thu Mar 10 14:36:07 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  192

1+       00000036 00000000          .byte 0
1+       00000037 0000003B          .byte ";;;;"
         00000038 0000003B 
         00000039 0000003B 
         0000003a 0000003B 
1+       0000003b 00000000          .byte 0
1+       00000000                   .text
 +    17                    
 +    18 00000000                   .text
 +    19                    

No Assembly Errors, No Assembly Warnings
