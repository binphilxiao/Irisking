TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    1

       1                    ;;   Do *not* directly modify this file.  It was   
       2                    ;;   generated by the Configuration Tool; any 
       3                    ;;   changes risk being overwritten.               
       4                    
       5                    ;; INPUT framework.cdb
       6                    
       7                    ;; CONFIGURATION/VERSION INFORMATION
       8                            .asg "Fri Jan 07 14:25:10 2011", VERS$DATE
       9                    
      10                    ;; PROLOGUE
      11                            .include frameworkcfg.h62
      12                            .copy confbeg.s62
 B     1                    ;
 B     2                    ;  Copyright 2003 by Texas Instruments Incorporated.
 B     3                    ;  All rights reserved. Property of Texas Instruments Incorporated.
 B     4                    ;  Restricted rights to use, duplicate or disclose this code are
 B     5                    ;  granted through contract.
 B     6                    ;  
 B     7                    ;
 B     8                    ; "@(#) DSP/BIOS 4.90.270 01-13-05 (barracuda-o07)"
 B     9                    ;
 B    10                    ;  ======== confbeg.s62 ========
 B    11                    ;  The statements in this file are inserted at the beginning of 
 B    12                    ;  every BIOS configuration file.
 B    13                    ;
 B    14                    
 B    15                    
      13                    
      14                    ;; TYPE HEADERS
      15                            .include gbl.h62
      16                            .include mem.h62
      17                            .include obj.h62
      18                            .include buf.h62
      19                            .include clk.h62
      20                            .include prd.h62
      21                            .include rtdx.h62
      22                            .include hst.h62
      23                            .include hwi.h62
      24                            .include swi.h62
      25                            .include tsk.h62
      26                            .include idl.h62
      27                            .include isrc.h62
      28                            .include log.h62
      29                            .include pip.h62
 +   636                    
      30                            .include sem.h62
      31                            .include mbx.h62
      32                            .include que.h62
      33                            .include lck.h62
      34                            .include sio.h62
      35                            .include sts.h62
      36                            .include sys.h62
 +   117                        
      37                            .include gio.h62
 +   132                        
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    2

      38                            .include dev.h62
      39                            .include udev.h62
      40                            .include dgn.h62
 +   215                    
      41                            .include dhl.h62
 +   197                    
      42                            .include dpi.h62
      43                            .include hook.h62
 +   225                    
      44                            .include dio.h62
      45                    
      46                    ;; TYPE ATTRIBUTES
      47          00000002  MEM$NUMOF           .set 2
      48          00000000  MEM$SETOF           .set 00H
      49          00000000  OBJ$NUMOF           .set 0
      50          00000000  OBJ$SETOF           .set 00H
      51          00000004  BUF$NUMOF           .set 4
      52          00000000  BUF$SETOF           .set 00H
      53          00000001  CLK$NUMOF           .set 1
      54          00000000  CLK$SETOF           .set 00H
      55          00000000  PRD$NUMOF           .set 0
      56          00000000  PRD$SETOF           .set 00H
      57          00000000  RTDX$NUMOF          .set 0
      58          00000000  RTDX$SETOF          .set 00H
      59          00000002  HST$NUMOF           .set 2
      60          00000003  HST$SETOF           .set 03H
      61          00000010  HWI$NUMOF           .set 16
      62          0000FFFF  HWI$SETOF           .set 0ffffH
      63          00000001  SWI$NUMOF           .set 1
      64          00000000  SWI$SETOF           .set 00H
      65          00000003  TSK$NUMOF           .set 3
      66          00000000  TSK$SETOF           .set 00H
      67          00000003  IDL$NUMOF           .set 3
      68          00000000  IDL$SETOF           .set 00H
      69          00000000  ISRC$NUMOF          .set 0
      70          00000000  ISRC$SETOF          .set 00H
      71          00000002  LOG$NUMOF           .set 2
      72          00000000  LOG$SETOF           .set 00H
      73          00000000  PIP$NUMOF           .set 0
      74          00000000  PIP$SETOF           .set 00H
      75          00000000  SEM$NUMOF           .set 0
      76          00000000  SEM$SETOF           .set 00H
      77          00000000  MBX$NUMOF           .set 0
      78          00000000  MBX$SETOF           .set 00H
      79          00000003  QUE$NUMOF           .set 3
      80          00000000  QUE$SETOF           .set 00H
      81          00000000  LCK$NUMOF           .set 0
      82          00000000  LCK$SETOF           .set 00H
      83          00000000  SIO$NUMOF           .set 0
      84          00000000  SIO$SETOF           .set 00H
      85          00000006  STS$NUMOF           .set 6
      86          00000000  STS$SETOF           .set 00H
      87          00000000  DEV$NUMOF           .set 0
      88          00000000  DEV$SETOF           .set 00H
      89          00000003  UDEV$NUMOF          .set 3
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    3

      90          00000000  UDEV$SETOF          .set 00H
      91          00000000  DGN$NUMOF           .set 0
      92          00000000  DGN$SETOF           .set 00H
      93          00000000  DHL$NUMOF           .set 0
      94          00000000  DHL$SETOF           .set 00H
      95          00000000  DPI$NUMOF           .set 0
      96          00000000  DPI$SETOF           .set 00H
      97          00000000  HOOK$NUMOF          .set 0
      98          00000000  HOOK$SETOF          .set 00H
      99          00000000  DIO$NUMOF           .set 0
     100          00000000  DIO$SETOF           .set 00H
     101                    
     102                    ;; module GBL (ROM, BIGENDIAN, USERINIT, USERINITFXN, ENABLEINST, CACHE, L2CONFIGURE, L2MODE, L2PRIORI
     103                            .global GBL$                     ; == 1
     104                            .global GBL_ROM                  ; frameworkcfg.h62
     105                            .global GBL_BIGENDIAN            ; frameworkcfg.h62
     106                            .global GBL_USERINIT             ; frameworkcfg.h62
     107                            .global GBL_USERINITFXN          ; frameworkcfg.cmd
     108                            .global GBL_ENABLEINST           ; frameworkcfg.h62
     109                            .global GBL_CACHE                ; frameworkcfg.h62
     110                            .global GBL_L2CONFIGURE          ; frameworkcfg.h62
     111                            .global GBL_L2MODE               ; frameworkcfg.h62
     112                            .global GBL_L2PRIORITY           ; frameworkcfg.h62
     113                            .global GBL_L2MARMASK            ; frameworkcfg.h62
     114                            .global GBL_SUPPORTCSL           ; frameworkcfg.h62
     115                            .global GBL_TRCMASKVALUE         ; frameworkcfg.h62
     116                            .global GBL_CALLCSLCFGINIT       ; frameworkcfg.h62
     117                            .global GBL_C641XL2PRIORITY      ; frameworkcfg.h62
     118                            .global GBL_L2MARMASK1           ; frameworkcfg.h62
     119                            .global GBL_L2MARMASK2           ; frameworkcfg.h62
     120                            .global GBL_L2MARMASK3           ; frameworkcfg.h62
     121                            .global GBL_L2MARMASK4           ; frameworkcfg.h62
     122                            .global GBL_L2MARMASK5           ; frameworkcfg.h62
     123                            .global GBL_L2CONFIGALLOC        ; frameworkcfg.h62
     124                            .global GBL_L2ALLOC              ; frameworkcfg.h62
     125                    
     126                    ;; module MEM (gNumHeap, SEGZERO, MALLOCSEG)
     127                            .global MEM$                     ; == 1
     128                            .global MEM_gNumHeap             ; frameworkcfg.h62
     129                            .global MEM_SEGZERO              ; frameworkcfg.cmd
     130                            .global MEM_MALLOCSEG            ; frameworkcfg.cmd
     131                    
     132                    ;; module OBJ ()
     133                            .global OBJ$                     ; == 0
     134                    
     135                    ;; module BUF (ENABLED)
     136                            .global BUF$                     ; == 1
     137                            .global BUF_ENABLED              ; frameworkcfg.h62
     138                    
     139                    ;; module CLK (INTBIT, REGS, TIMERNUM, USETIMER, TCR, TDDR, TDDRHIGH, PRD, PRDHIGH, COUNTSPMS, COUNTSP
     140                            .global CLK$                     ; == 1
     141                            .global CLK_INTBIT               ; frameworkcfg.h62
     142                            .global CLK_REGS                 ; frameworkcfg.h62
     143                            .global CLK_TIMERNUM             ; frameworkcfg.h62
     144                            .global CLK_USETIMER             ; frameworkcfg.h62
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    4

     145                            .global CLK_TCR                  ; frameworkcfg.h62
     146                            .global CLK_TDDR                 ; frameworkcfg.h62
     147                            .global CLK_TDDRHIGH             ; frameworkcfg.h62
     148                            .global CLK_PRD                  ; frameworkcfg.h62
     149                            .global CLK_PRDHIGH              ; frameworkcfg.h62
     150                            .global CLK_COUNTSPMS            ; frameworkcfg.h62
     151                            .global CLK_COUNTSPMSHIGH        ; frameworkcfg.h62
     152                            .global CLK_TIMEFXN              ; frameworkcfg.cmd
     153                            .global CLK_HOOKFXN              ; frameworkcfg.cmd
     154                    
     155                    ;; module PRD (SCALAR, THOOKFXN)
     156                            .global PRD$                     ; == 1
     157                            .global PRD_SCALAR               ; frameworkcfg.h62
     158                            .global PRD_THOOKFXN             ; frameworkcfg.cmd
     159                    
     160                    ;; module RTDX (USERTDX, USERTEXECUTION, DATAMEMSEG, BUFMEMSIZE)
     161                            .global RTDX$                    ; == 1
     162                            .global RTDX_USERTDX             ; frameworkcfg.h62
     163                            .global RTDX_USERTEXECUTION      ; frameworkcfg.h62
     164                            .global RTDX_DATAMEMSEG          ; frameworkcfg.cmd
     165                            .global RTDX_BUFMEMSIZE          ; frameworkcfg.h62
     166                    
     167                    ;; module HST (RTDX, DSM, NONE, MAXFRAMESET, MAXFRAMEALLOWED, DSMBUFSEG, DSMMEMSIZE)
     168                            .global HST$                     ; == 1
     169                            .global HST_RTDX                 ; frameworkcfg.h62
     170                            .global HST_DSM                  ; frameworkcfg.h62
     171                            .global HST_NONE                 ; frameworkcfg.h62
     172                            .global HST_MAXFRAMESET          ; frameworkcfg.h62
     173                            .global HST_MAXFRAMEALLOWED      ; frameworkcfg.h62
     174                            .global HST_DSMBUFSEG            ; frameworkcfg.cmd
     175                            .global HST_DSMMEMSIZE           ; frameworkcfg.h62
     176                    
     177                    ;; module HWI (ZEROTAB, GENERATE_RESET_VEC, POLARITYMASK, INTRMULTLOW, INTRMULTHIGH)
     178                            .global HWI$                     ; == 1
     179                            .global HWI_ZEROTAB              ; frameworkcfg.h62
     180                            .global HWI_GENERATE_RESET_VEC   ; frameworkcfg.h62
     181                            .global HWI_POLARITYMASK         ; frameworkcfg.h62
     182                            .global HWI_INTRMULTLOW          ; frameworkcfg.h62
     183                            .global HWI_INTRMULTHIGH         ; frameworkcfg.h62
     184                    
     185                    ;; module SWI (EHOOKFXN, IHOOKFXN, EXECFXN, RUNFXN)
     186                            .global SWI$                     ; == 1
     187                            .global SWI_EHOOKFXN             ; frameworkcfg.cmd
     188                            .global SWI_IHOOKFXN             ; frameworkcfg.cmd
     189                            .global SWI_EXECFXN              ; frameworkcfg.cmd
     190                            .global SWI_RUNFXN               ; frameworkcfg.cmd
     191                    
     192                    ;; module TSK (STACKSIZE, STACKSEG, PRIORITY, VCREATEFXN, VDELETEFXN, VEXITFXN, SWITCHFXN, READYFXN, N
     193                            .global TSK$                     ; == 1
     194                            .global TSK_STACKSIZE            ; frameworkcfg.h62
     195                            .global TSK_STACKSEG             ; frameworkcfg.cmd
     196                            .global TSK_PRIORITY             ; frameworkcfg.h62
     197                            .global TSK_VCREATEFXN           ; frameworkcfg.cmd
     198                            .global TSK_VDELETEFXN           ; frameworkcfg.cmd
     199                            .global TSK_VEXITFXN             ; frameworkcfg.cmd
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    5

     200                            .global TSK_SWITCHFXN            ; frameworkcfg.h62
     201                            .global TSK_READYFXN             ; frameworkcfg.h62
     202                            .global TSK_NUM_HOOKS            ; frameworkcfg.h62
     203                    
     204                    ;; module IDL (USECLKIDLTIME, CALIBRFXN)
     205                            .global IDL$                     ; == 1
     206                            .global IDL_USECLKIDLTIME        ; frameworkcfg.h62
     207                            .global IDL_CALIBRFXN            ; frameworkcfg.cmd
     208                    
     209                    ;; module ISRC ()
     210                            .global ISRC$                    ; == 1
     211                    
     212                    ;; module LOG (ENABLED)
     213                            .global LOG$                     ; == 1
     214                            .global LOG_ENABLED              ; frameworkcfg.h62
     215                    
     216                    ;; module PIP (gNumEmbed, gNextId)
     217                            .global PIP$                     ; == 0
     218                            .global PIP_gNumEmbed            ; frameworkcfg.h62
     219                            .global PIP_gNextId              ; frameworkcfg.h62
     220                    
     221                    ;; module SEM ()
     222                            .global SEM$                     ; == 0
     223                    
     224                    ;; module MBX ()
     225                            .global MBX$                     ; == 0
     226                    
     227                    ;; module QUE ()
     228                            .global QUE$                     ; == 1
     229                    
     230                    ;; module LCK ()
     231                            .global LCK$                     ; == 1
     232                    
     233                    ;; module SIO ()
     234                            .global SIO$                     ; == 0
     235                    
     236                    ;; module STS ()
     237                            .global STS$                     ; == 1
     238                    
     239                    ;; module SYS (ABORTFXN, ERRORFXN, EXITFXN, PUTCFXN)
     240                            .global SYS$                     ; == 1
     241                            .global SYS_ABORTFXN             ; frameworkcfg.cmd
     242                            .global SYS_ERRORFXN             ; frameworkcfg.cmd
     243                            .global SYS_EXITFXN              ; frameworkcfg.cmd
     244                            .global SYS_PUTCFXN              ; frameworkcfg.cmd
     245                    
     246                    ;; module GIO (CREATEFXN, DELETEFXN, PENDFXN, POSTFXN)
     247                            .global GIO$                     ; == 1
     248                            .global GIO_CREATEFXN            ; frameworkcfg.cmd
     249                            .global GIO_DELETEFXN            ; frameworkcfg.cmd
     250                            .global GIO_PENDFXN              ; frameworkcfg.cmd
     251                            .global GIO_POSTFXN              ; frameworkcfg.cmd
     252                    
     253                    ;; module DEV ()
     254                            .global DEV$                     ; == 0
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    6

     255                    
     256                    ;; module UDEV ()
     257                            .global UDEV$                    ; == 1
     258                    
     259                    ;; module DGN ()
     260                            .global DGN$                     ; == 0
     261                    
     262                    ;; module DHL (gChannelsAvailable)
     263                            .global DHL$                     ; == 0
     264                            .global DHL_gChannelsAvailable   ; frameworkcfg.h62
     265                    
     266                    ;; module DPI ()
     267                            .global DPI$                     ; == 0
     268                    
     269                    ;; module HOOK (KNLID)
     270                            .global HOOK$                    ; == 0
     271                            .global HOOK_KNLID               ; frameworkcfg.h62
     272                    
     273                    ;; module DIO (STATIC, NUMTSKBASE, NUMSWIBASE)
     274                            .global DIO$                     ; == 0
     275                            .global DIO_STATIC               ; frameworkcfg.h62
     276                            .global DIO_NUMTSKBASE           ; frameworkcfg.h62
     277                            .global DIO_NUMSWIBASE           ; frameworkcfg.h62
     278                    
     279                    ;; MODULE CONFIGURATION
     280                    
     281                    ;; ======== GBL_config ========
     282                            .asg 00H, _ROM
     283                            .asg 00H, _BIGENDIAN
     284                            .asg 01H, _USERINIT
     285                            .asg _dm642_init, _USERINITFXN
     286                            .asg 01H, _ENABLEINST
     287                            .asg 00H, _CACHE
     288                            .asg 00H, _L2CONFIGURE
     289                            .asg 00H, _L2MODE
     290                            .asg 00H, _L2PRIORITY
     291                            .asg 00H, _L2MARMASK
     292                            .asg 01H, _SUPPORTCSL
     293                            .asg 0dbefH, _TRCMASKVALUE
     294                            .asg 01H, _CALLCSLCFGINIT
     295                            .asg 00H, _C641XL2PRIORITY
     296                            .asg 00H, _L2MARMASK1
     297                            .asg 00H, _L2MARMASK2
     298                            .asg 00H, _L2MARMASK3
     299                            .asg 00H, _L2MARMASK4
     300                            .asg 00H, _L2MARMASK5
     301                            .asg 00H, _L2CONFIGALLOC
     302                            .asg 02226H, _L2ALLOC
     303 00000000                   GBL_config  _ROM, _BIGENDIAN, _USERINIT, _USERINITFXN, _ENABLEINST, _CACHE, _L2CONFIGURE, _L2M
1                                   
1                                   ; reference special symbol GBL_boot defined in BIOS boot file to make sure
1                                   ; we are linking correct boot file (workaround for SDSsq24217)
1                                   .ref GBL_boot
1                           
1                                   .def TRC_cinit
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    7

1                                   .def _TRC_R_mask
1                                   .asg    _dm642_init, USERINITFXN        ; used by GBL_init
1                           
1                                   ;
1                                   ; print a warning message if project build options do not match
1                                   ; global configuration options.
1                                   ;
1                                   .if .BIG_ENDIAN
1                                       .if (GBL_BIGENDIAN == 0)
1                                           .emsg "Project build options do not match Global configuration settings.  Compiler opt
1                                       .endif
1                                   .else
1                                       .if (GBL_BIGENDIAN == 1)
1                                           .emsg "Project build options do not match Global configuration settings.  Compiler opt
1                                       .endif
1                                   .endif
1                           
1                                   ; initialize 'gblinit' variable, used in GBL_init
1        00000000           gblinit .sect ".gblinit"
1                           
1                                   ;
1                                   ; fill stack with '0xc0ffee'
1                                   ;
1                                   ; Don't overwrite the bottom 16 words to avoid trashing
1                                   ; valid stack data. (Only one of these words contains
1                                   ; valid data, but just to be safe we leave 16 untouched).
1                                   ;
1                                   ; (stacksize / wordsize) since size is in words
1                                   ;
1        00000000 00000000%         .word ( (GBL_stackend-GBL_stackbeg+1) / STD_TARGWORDMAUS ) - 16 ; nwords
1        00000004 00000000!         .word GBL_stackbeg                      ; addr
1        00000008 00C0FFEE          .word 0xc0ffee                          ; value
1                           
1                                   ;
1                                   ;  DEFINE A SPECIAL WORD THAT WILL BE COPIED TO TRC_R_mask
1                                   ;  AT PROGRAM INITIALIZATION, INSTEAD OF PUTTING TRC_cinit
1                                   ;  INTO THE .cinit SECTION.
1                                   ;  THIS WAY WE CAN WRITE TO BOTH TRC_R_mask AND TRC_cinit
1                                   ;  AND APPLICATION PROGRAMS CAN STILL USE THE .cinit SECTION
1                                   ;  AFTER INITIALIZATION IS DONE.
1                                   ;
1        00000000                   .sect ".trcdata"
1                           
1        00000000           TRC_cinit:
1                                   .align 4
1        00000000 0000DBEF          .word GBL_TRCMASKVALUE          ; defined by configuration tool
1                           
1                                   ; We need to initialize TRC_R_mask, but can't use a .cinit
1                                   ; record, so it can't go into .bss as it was before since
1                                   ; the initialization below causes the whole .bss section to
1                                   ; become initialized and filled.
1                                   ;
1        00000004           TRC_R_mask:
1                                   .align 4
1        00000004 0000DBEF          .word GBL_TRCMASKVALUE          ; defined by configuration tool
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    8

1                           
1                 00000004+ _TRC_R_mask     .set    TRC_R_mask
1                           
1        00000008           GBL_initdone
1        00000008                   .sect ".trcdata"
1        00000008 00000000          .word 0
1                           
     304                    
     305                    ;; ======== MEM_config ========
     306                            .asg 01H, _gNumHeap
     307                            .asg SDRAM, _SEGZERO
     308                            .asg SDRAM, _MALLOCSEG
     309 0000000c                   MEM_config  _gNumHeap, _SEGZERO, _MALLOCSEG
1                           
1                               ;
1                               ; Proceed only if there are heaps declared.
1                               ;
1                               .if 01H
1                                   .global _MEM        ; Pointer to configuration parameters
1                                   .global _MEM_memtab        ; Array of memory heaps
1                                   .global __MEM_NUMSEGMENTS    ; Number of memory heaps
1                           
1                                   ;
1                                   ; The following two .bss/.cinit sets make configured values readable
1                                   ; in the established SPOX manner, e.g., MEM->MALLOCSEG.
1                                   ;
1        00000000           MEM_config    .usect    ".mem", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000000                   .sect ".cinit"
1                                   .align STD_TARGALIGN
1        00000000 00000004          .word 1 * STD_TARGWORDMAUS
1        00000004 00000000-         .word MEM_config   
1                           
1                                   ;; If MALLOCSEG = MEM_NULL then put in an err value in for MALLOCSEG$idx
1                                   .if ($symcmp("SDRAM", "MEM_NULL") == 0)
1                                       .word -1
1                                   .else
1        00000008 00000000              .word SDRAM$idx
1                                   .endif
1                           
1        0000000c                   .sect ".cinit"
1                                   .align STD_TARGALIGN
1        00000010 00000004          .word 1 * STD_TARGWORDMAUS
1        00000014 00000000!         .word _MEM   
1        00000018 00000000-         .word MEM_config
1                           
1                                   ;
1                                   ; This declares space for the array of configured heaps, the .cinit
1                                   ; parts are defined for each task in MEM_Obj.  This space has to be
1                                   ; reserved NOW, before the MEM_Obj macro is called and the elements
1                                   ; of the table are defined.
1                                   ;
1        00000000                   .bss _MEM_memtab, 01H * 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                   ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE    9

1                                   ; Set MEM_tabIdx to 1 if _segzero is set to a MEM segment other then
1                                   ; MEM_NULL because the MEM segment will in the 0th place.
1                                   ; If _segzero is MEM_NULL then set MEM_tabIdx to 0 since MEM_NULL is
1                                   ; only a place holder and not a real MEM segment with a heap.
1                                   ;
1                                   .if $symcmp("MEM_NULL", "SDRAM") == 0
1                                       .asg    0, MEM_tabIdx        ; Index into MEM_memtab
1                                   .else
1                                       .asg    1, MEM_tabIdx        ; Index into MEM_memtab
1                                   .endif
1                           
1                               ;
1                               ; _MEM_memtab needs to be set to zero if no heap are defined
1                               ;
1                               .else
1                               .global _MEM_memtab
1                           _MEM_memtab .set 00h
1                               .endif        ; .if :_gNumHeap:
1                           
     310                    
     311                    ;; ======== OBJ_config ========
     312 0000001c                   OBJ_config
1                           
1                           
1                                   .asg    "_OBJ_table + 0 * STD_TARGWORDMAUS",    OBJ_TAB_SEM
1                                   .asg    "_OBJ_table + 2 * STD_TARGWORDMAUS",    OBJ_TAB_SWI
1                                   .asg    "_OBJ_table + 4 * STD_TARGWORDMAUS",    OBJ_TAB_TSK
1                                   .asg    "_OBJ_table + 6 * STD_TARGWORDMAUS",    OBJ_TAB_MBX
1                                   .asg    "_OBJ_table + 8 * STD_TARGWORDMAUS",    OBJ_TAB_SIO
1                                   .asg    "_OBJ_table + 10 * STD_TARGWORDMAUS",   OBJ_TAB_DEV
1                                   .asg    "_OBJ_table + 12 * STD_TARGWORDMAUS",   OBJ_TAB_BUF
1                           
1                                   .asg _OBJ_table + 0 * STD_TARGWORDMAUS, OBJ_sem$next
1                                   .asg _OBJ_table + 2 * STD_TARGWORDMAUS, OBJ_swi$next
1                                   .asg _OBJ_table + 4 * STD_TARGWORDMAUS, OBJ_tsk$next
1                                   .asg _OBJ_table + 6 * STD_TARGWORDMAUS, OBJ_mbx$next
1                                   .asg _OBJ_table + 8 * STD_TARGWORDMAUS, OBJ_sio$next
1                                   .asg _OBJ_table + 10 * STD_TARGWORDMAUS,  OBJ_dev$next
1                                   .asg _OBJ_table + 12 * STD_TARGWORDMAUS,  OBJ_buf$next
1                           
1                                   .asg _OBJ_table + 0 * STD_TARGWORDMAUS, OBJ_sem$prev
1                                   .asg _OBJ_table + 2 * STD_TARGWORDMAUS, OBJ_swi$prev
1                                   .asg _OBJ_table + 4 * STD_TARGWORDMAUS, OBJ_tsk$prev
1                                   .asg _OBJ_table + 6 * STD_TARGWORDMAUS, OBJ_mbx$prev
1                                   .asg _OBJ_table + 8 * STD_TARGWORDMAUS, OBJ_sio$prev
1                                   .asg _OBJ_table + 10 * STD_TARGWORDMAUS, OBJ_dev$prev
1                                   .asg _OBJ_table + 12 * STD_TARGWORDMAUS, OBJ_buf$prev
1                           
1                                   .asg    1,      SEM$sernum
1                                   .asg    1,      SWI$sernum
1                                   .asg    1,      TSK$sernum
1                                   .asg    1,      MBX$sernum
1                                   .asg    1,      SIO$sernum
1                                   .asg    1,      DEV$sernum
1                                   .asg    1,      BUF$sernum
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   10

1                           
     313                    
     314                    ;; ======== BUF_config ========
     315                            .asg 01H, _ENABLED
     316 0000001c                   BUF_config  _ENABLED
     317                    
     318                    ;; ======== CLK_config ========
     319                            .asg 04000H, _INTBIT
     320                            .asg 01940000H, _REGS
     321                            .asg 00H, _TIMERNUM
     322                            .asg 01H, _USETIMER
     323                            .asg 020H, _TCR
     324                            .asg 00H, _TDDR
     325                            .asg 00H, _TDDRHIGH
     326                            .asg 0124f8H, _PRD
     327                            .asg 01H, _PRDHIGH
     328                            .asg 0124f8H, _COUNTSPMS
     329                            .asg 01H, _COUNTSPMSHIGH
     330                            .asg CLK_F_getshtime, _TIMEFXN
     331                            .asg HWI_F_dispatch, _HOOKFXN
     332 0000001c                   CLK_config  _INTBIT, _REGS, _TIMERNUM, _USETIMER, _TCR, _TDDR, _TDDRHIGH, _PRD, _PRDHIGH, _COU
1                           
1                                   ;
1                                   ; NOTE! BIOS and SPOX overlap still needs resolution
1                                   ;
1                                   
     333                    
     334                    ;; ======== PRD_config ========
     335                            .asg 04000H, _SCALAR
     336                            .asg _KNL_tick, _THOOKFXN
     337 0000001c                   PRD_config  _SCALAR, _THOOKFXN
1                                   ; only expand if the PRD module is configured by the user
1                                   .asg 0, PRD_swihandle
1                                   .if (PRD$ = 1)
1                                       .if (PRD$NUMOF > 0)
1                                           .if (SWI$ != 1)
1                                               .emsg "PRD objects require the configuration of SWI"
1                                               .mexit
1                                           .endif
1                                           .asg "PRD_swi", PRD_swihandle
1                                       .endif
1                                   .endif
1                                   
     338                    
     339                    ;; ======== RTDX_config ========
     340                            .asg 01H, _USERTDX
     341                            .asg 00H, _USERTEXECUTION
     342                            .asg SDRAM, _DATAMEMSEG
     343                            .asg 0408H, _BUFMEMSIZE
     344 0000001c                   RTDX_config  _USERTDX, _USERTEXECUTION, _DATAMEMSEG, _BUFMEMSIZE
1                                   .if(RTDX_USERTDX = 1)
1                                       .global _RTDX_Buffer, _RTDX_Buffer_Start, _RTDX_Buffer_End
1                           
1                                       ; reserve uninitialized space for RTDX buffer
1        00000000           _RTDX_Buffer    .usect ".rtdx_data", 0408H, STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   11

1                           
1                                       ; define _RTDX_Buffer_Start
1        00000408           _RTDX_Buffer_Start  .usect ".rtdx_data", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000001c                   .sect ".cinit"
1                                   .align STD_TARGALIGN
1        00000020 00000004          .field  1 * STD_TARGWORDMAUS
1        00000024 00000408-         .field  _RTDX_Buffer_Start
1        00000028 00000000-         .field  _RTDX_Buffer
1                                   
1                                       ; define _RTDX_Buffer_End 
1        0000040c           _RTDX_Buffer_End  .usect ".rtdx_data", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000002c                   .sect ".cinit"
1                                   .align STD_TARGALIGN
1        00000030 00000004          .field  1 * STD_TARGWORDMAUS
1        00000034 0000040C-         .field  _RTDX_Buffer_End
1        00000038 00000404-         .field  _RTDX_Buffer + 0408H - (1 * STD_TARGWORDMAUS)
1                           
1                                   .endif
     345                    
     346                    ;; ======== HST_config ========
     347                            .asg 01H, _RTDX
     348                            .asg 00H, _DSM
     349                            .asg 00H, _NONE
     350                            .asg 00H, _MAXFRAMESET
     351                            .asg 0100H, _MAXFRAMEALLOWED
     352                            .asg SDRAM, _DSMBUFSEG
     353                            .asg 0400H, _DSMMEMSIZE
     354 0000003c                   HST_config  _RTDX, _DSM, _NONE, _MAXFRAMESET, _MAXFRAMEALLOWED, _DSMBUFSEG, _DSMMEMSIZE
1                                   .asg    0, HST$hstCount
1                                   .asg    0, chanId
1                           
1                                   .if(HST$ != 0)
1        0000003c                       LNK_config _dsm, _dsmbufseg, _dsmmemsize  ; do any reqd LNK config 
2                                   .ref LNK_dspFrameRequestMask, LNK_dspFrameReadyMask
2                           
2                                   .if(00H = 1)
2                           
2                                   .global LNK_outputBuf, LNK_inputBuf
2                           
2                                   ; reserve uninitialized space for DSP output buffer
2                           LNK_outputBuf .usect ".dsm", _dsmmemsize, STD_TARGWORDMAUS
2                           
2                                   ; reserve uninitialized space for DSP input buffer
2                           LNK_inputBuf .usect ".dsm", _dsmmemsize, STD_TARGWORDMAUS
2                           
2                                   .endif
2                           
1                                   .endif
1                           
     355                    
     356                    ;; ======== HWI_config ========
     357                            .asg 00H, _ZEROTAB
     358                            .asg 00H, _GENERATE_RESET_VEC
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   12

     359                            .asg 00H, _POLARITYMASK
     360                            .asg 0250718a4H, _INTRMULTLOW
     361                            .asg 082039a3H, _INTRMULTHIGH
     362 0000003c                   HWI_config  _ZEROTAB, _GENERATE_RESET_VEC, _POLARITYMASK, _INTRMULTLOW, _INTRMULTHIGH
1                           
     363                    
     364                    ;; ======== SWI_config ========
     365                            .asg GBL_NULL, _EHOOKFXN
     366                            .asg GBL_NULL, _IHOOKFXN
     367                            .asg SWI_F_iexec, _EXECFXN
     368                            .asg SWI_F_run, _RUNFXN
     369 0000003c                   SWI_config  _EHOOKFXN, _IHOOKFXN, _EXECFXN, _RUNFXN
1                           
     370                    
     371                    ;; ======== TSK_config ========
     372                            .asg 05000H, _STACKSIZE
     373                            .asg SDRAM, _STACKSEG
     374                            .asg 01H, _PRIORITY
     375                            .asg _FXN_F_nop, _VCREATEFXN
     376                            .asg _FXN_F_nop, _VDELETEFXN
     377                            .asg _FXN_F_nop, _VEXITFXN
     378                            .asg 00H, _SWITCHFXN
     379                            .asg 00H, _READYFXN
     380                            .asg 00H, _NUM_HOOKS
     381 0000003c                   TSK_config  _STACKSIZE, _STACKSEG, _PRIORITY, _VCREATEFXN, _VDELETEFXN, _VEXITFXN, _SWITCHFXN,
1                           
1                                   ;; If MEM_gNumHeap then put in an err value in for TSK$stackseg
1                                   .if (MEM_gNumHeap == 0)
1                                           .asg    "-1", TSK$stackseg
1                                   .else 
1                                       .if ($symcmp("SDRAM", "MEM_NULL") == 0)
1                                           .asg    "-1", TSK$stackseg
1                                       .else
1                                           .asg    "SDRAM$idx", TSK$stackseg
1                                       .endif
1                                   .endif
1                           
1                                   .ref    _FXN_F_nop, _FXN_F_nop, _FXN_F_nop
1                           
1                                   .if $isname("00H")
1                                       .ref        :_switchfxn:
1                                   .endif
1                           
1                                   .if $isname("00H")
1                                       .ref :_readyfxn:
1                                   .endif
1                           
1                                   .global _TSK_exit
1                           
1                                   ;
1                                   ; Initialize counter for use in TSK_Obj
1                                   ;
1                                   .eval 0, TSK$strCount
1                           
1                                   .eval   00H, TSK$num_hooks
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   13

1                           
     382                    
     383                    ;; ======== IDL_config ========
     384                            .asg 01H, _USECLKIDLTIME
     385                            .asg IDL_F_stub, _CALIBRFXN
     386 0000003c                   IDL_config  _USECLKIDLTIME, _CALIBRFXN
1                               .asg 01H,USECLKIDLTIME    ; used by IDL_init
     387                    
     388                    ;; ======== ISRC_config ========
     389 0000003c                   ISRC_config
     390                    
     391                    ;; ======== LOG_config ========
     392                            .asg 01H, _ENABLED
     393 0000003c                   LOG_config  _ENABLED
     394                    
     395                    ;; ======== PIP_config ========
     396                            .asg 02H, _gNumEmbed
     397                            .asg 00H, _gNextId
     398 0000003c                   PIP_config  _gNumEmbed, _gNextId
     399                    
     400                    ;; ======== SEM_config ========
     401 0000003c                   SEM_config
1                           
1                                   .global __SEM_dopost
     402                    
     403                    ;; ======== MBX_config ========
     404 0000003c                   MBX_config
     405                    
     406                    ;; ======== QUE_config ========
     407 0000003c                   QUE_config
     408                    
     409                    ;; ======== LCK_config ========
     410 0000003c                   LCK_config
     411                    
     412                    ;; ======== SIO_config ========
     413 0000003c                   SIO_config
     414                    
     415                    ;; ======== STS_config ========
     416 0000003c                   STS_config
1                                   ; only expand if the STS module is configured by the user
1                                   .if (STS$ = 1)
1                                       .if (STS$NUMOF > 0)
1                                       .endif
1                                   .endif
1                                   
     417                    
     418                    ;; ======== SYS_config ========
     419                            .asg _UTL_doAbort, _ABORTFXN
     420                            .asg _UTL_doError, _ERRORFXN
     421                            .asg _UTL_halt, _EXITFXN
     422                            .asg _UTL_doPutc, _PUTCFXN
     423 0000003c                   SYS_config  _ABORTFXN, _ERRORFXN, _EXITFXN, _PUTCFXN
1                                   .global SYS$config
1                           
1        00000000           SYS$config:     .usect  ".sys",4 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   14

1                           
1        0000003c                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000040 00000010          .word   4 * STD_TARGWORDMAUS
1        00000044 00000000-         .word   SYS$config
1        00000048 00000000!         .word   _UTL_doAbort
1        0000004c 00000000!         .word   _UTL_doError
1        00000050 00000000!         .word   _UTL_halt
1        00000054 00000000!         .word   _UTL_doPutc
1                           
     424                    
     425                    ;; ======== GIO_config ========
     426                            .asg _SEM_create, _CREATEFXN
     427                            .asg _SEM_delete, _DELETEFXN
     428                            .asg _SEM_pend, _PENDFXN
     429                            .asg _SEM_post, _POSTFXN
     430 00000058                   GIO_config  _CREATEFXN, _DELETEFXN, _PENDFXN, _POSTFXN
1                                   .if (GIO$ = 1)
1                           
1                                       .global _GIO
1                                       .global GIO$config
1                           
1        00000000           GIO$config:     .usect  ".gio", 4 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000058                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1        00000058 00000010              .word       4 * STD_TARGWORDMAUS
1        0000005c 00000000-             .word       GIO$config
1        00000060 00000000!             .word   _SEM_create
1        00000064 00000000!             .word   _SEM_delete
1        00000068 00000000!             .word   _SEM_pend
1        0000006c 00000000!             .word   _SEM_post
1                           
1                           ;
1                           ;  Set up pointer to GIO configuration parameters
1                           ;
1        0000000c                       .bss    _GIO, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000070                       .sect   ".cinit"
1                                       .align  STD_TARGALIGN
1        00000070 00000004              .word   1 * STD_TARGWORDMAUS
1        00000074 0000000C-             .word   _GIO
1        00000078 00000000-             .word   GIO$config
1                           
1                                   .endif
     431                    
     432                    ;; ======== DEV_config ========
     433 0000007c                   DEV_config
1                                   .asg    0,      DEV$initCount
     434                    
     435                    ;; ======== UDEV_config ========
     436 0000007c                   UDEV_config
     437                    
     438                    ;; ======== DGN_config ========
     439 0000007c                   DGN_config
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   15

1                           
1                                   .if ($isdefed("STD_FLOATDSP") = 0)
1                           DGN_FLOATDSP    .set 0
1                                   .elseif (STD_FLOATDSP = 1)
1                           DGN_FLOATDSP    .set 1
1                                   .else
1                 00000000  DGN_FLOATDSP    .set 0
1                                   .endif
1                                   
1                                   .if (DGN_FLOATDSP == 1)
1                           
1                                   .global _DGN_fconst
1                                   .global _DGN_frand
1                                   .global _DGN_fsine
1                                   .global _DGN_user
1                           
1                                   .asg    _DGN_fconst,  DGN_CONST
1                                   .asg    _DGN_frand,  DGN_RAND
1                                   .asg    _DGN_fsine,  DGN_SINE
1                                   .asg    _DGN_user,   DGN_USER
1                           
1                                   .else
1                           
1                                   .global _DGN_iconst
1                                   .global _DGN_irand
1                                   .global _DGN_isine
1                                   .global _DGN_user
1                           
1                                   .asg    _DGN_iconst, DGN_CONST
1                                   .asg    _DGN_irand,  DGN_RAND
1                                   .asg    _DGN_isine,  DGN_SINE
1                                   .asg    _DGN_user,   DGN_USER
1                           
1                                   .endif
1                           
     440                    
     441                    ;; ======== DHL_config ========
     442                            .asg 00H, _gChannelsAvailable
     443 0000007c                   DHL_config  _gChannelsAvailable
1                           
1                                   .global _DHL_notify
1                           
1                                   .asg    0, DHL$count
1                           
     444                    
     445                    ;; ======== DPI_config ========
     446 0000007c                   DPI_config
1                                   .asg    0, DPI$devid
     447                    
     448                    ;; ======== HOOK_config ========
     449                            .asg 00H, _KNLID
     450 0000007c                   HOOK_config  _KNLID
1                           
1                                   .if (HOOK$ == 1)
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   16

1                                   .def    __HOOK_initFxnTable
1                                   .def    __HOOK_createFxnTable
1                                   .def    __HOOK_deleteFxnTable
1                                   .def    __HOOK_exitFxnTable
1                                   .def    __HOOK_readyFxnTable
1                                   .def    __HOOK_switchFxnTable
1                           
1                                   .endif
1                           
1                                   .asg    0, HOOK$index
1                                   .eval   00H, HOOK$knl_index
1                           
1                                   .def    __HOOK_knlId
1                           
1        00000010                   .bss    __HOOK_knlId, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000007c                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000080 00000004          .word   1 * STD_TARGWORDMAUS
1        00000084 00000010-         .word   __HOOK_knlId
1        00000088 00000000          .word   0
1                           
     451                    
     452                    ;; ======== DIO_config ========
     453                            .asg 00H, _STATIC
     454                            .asg 00H, _NUMTSKBASE
     455                            .asg 00H, _NUMSWIBASE
     456 0000008c                   DIO_config  _STATIC, _NUMTSKBASE, _NUMSWIBASE
1                                   .if (00H)
1                                       .if (:_numTskBase: != 0)
1                                           .global _DIO_NUMTSKSTATIC  ; Number of Static TSK DIO objects
1                                           .global _DIO_TSKTABLE      ; Table of DIO objects for TSK.
1                           
1                                           .eval DIO_OBJSIZE * :_numTskBase:, DIO_TABLESIZE
1                           
1                           ;
1                           ;  Allocate space for DIO_NUMTSKSTATIC value.
1                           ;  This value is used in Static TSK version of DIO.
1                           ;  Allocate space for TSK DIO table
1                           ;
1                           _DIO_NUMTSKSTATIC       .usect ".dio", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           _DIO_TSKTABLE           .usect ".dio", DIO_TABLESIZE * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                           ;
1                                           ;  initialize DIO_NUMTSKSTATIC.
1                                           ;
1                                           .sect ".cinit"
1                                           .align STD_TARGALIGN
1                                           .word 1 * STD_TARGWORDMAUS
1                                           .word _DIO_NUMTSKSTATIC
1                                           .word :_numTskBase:
1                                       
1                                           .eval   0, count
1                           
1                                           .loop
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   17

1                           
1                                               ;
1                                               ;  Initialize the TSK DIO table.
1                                               ;
1                                               .sect ".cinit"
1                                               .align STD_TARGALIGN
1                                               .word DIO_OBJSIZE * STD_TARGWORDMAUS
1                                               .word _DIO_TSKTABLE + DIO_OBJSIZE * :count: * STD_TARGWORDMAUS
1                                               .word 0                     ; fxns
1                                               .word 0                     ; chanp
1                                               .word dio:count:$complete   ; complete
1                                               .word 0                     ; ready
1                                               .word 0                     ; extra word for union
1                           
1                                               ;  create the complete SEM object
1                                               DIO_semObject dio:count:$complete, 0
1                           
1                                               .eval count + 1, count
1                                               .break (count == :_numTskBase:)
1                                           .endloop
1                                       .endif      ; .if (:_numTskBase: != 0)
1                           
1                                       .if (:_numSwiBase: != 0)
1                                           .global _DIO_NUMCBSTATIC  ; Number of Cb Static DIO objects.
1                                           .global _DIO_CBTABLE      ; Table of DIO objects for Callback.
1                           
1                                           .eval DIO_OBJSIZE * :_numSwiBase:, DIO_TABLESIZE
1                           
1                           ;
1                           ;  Allocate space for DIO_NUMCBSTATIC value
1                           ;  This value is used in Static Callback version of DIO.
1                           ;  Allocate space for Callback DIO Table
1                           ;
1                           _DIO_NUMCBSTATIC        .usect ".dio", 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           _DIO_CBTABLE            .usect ".dio", DIO_TABLESIZE * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                           ;
1                                           ;  initialize DIO_NUMCBSTATIC.
1                                           ;
1                                           .sect ".cinit"
1                                           .align STD_TARGALIGN
1                                           .word 1 * STD_TARGWORDMAUS
1                                           .word _DIO_NUMCBSTATIC
1                                           .word :_numSwiBase:
1                                   
1                                           .eval   0, count
1                           
1                                           .loop
1                                               
1                                               ;
1                                               ;  Initialize the Callback DIO table.
1                                               ;
1                                               .sect ".cinit"
1                                               .align STD_TARGALIGN
1                                               .word DIO_OBJSIZE * STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   18

1                                               .word _DIO_CBTABLE + DIO_OBJSIZE * :count: * STD_TARGWORDMAUS
1                                               .word 0                     ; fxns
1                                               .word 0                     ; chanp
1                                               .word 0                     ; context.cb.fxn
1                                               .word 0                     ; context.cb.arg0
1                                               .word 0                     ; context.cb.arg1
1                                           
1                                               .eval count + 1, count
1                                               .break (count == :_numSwiBase:)
1                                           .endloop
1                                       .endif      ; .if (:_numSiBase: != 0)
1                                   .endif          ; .if (:_static:)
1                           
     457                    
     458                    ;; ======== UDEV_Obj VP0CAPTURE ========
     459                    ;; <add comments here>
     460                    ;;
     461                    ;; UDEV_Obj VP0CAPTURE (iFxns, driverType, iParams, deviceId, initFxn, deviceGlobalDataPtr)
     462                            .global VP0CAPTURE
     463                            .asg _VPORTCAP_Fxns, _iFxns
     464                            .asg "DEV_IOMTYPE", _driverType
     465                            .asg _EMB_vCapParamsPort, _iParams
     466                            .asg 00H, _deviceId
     467                            .asg 00H, _initFxn
     468                            .asg 00H, _deviceGlobalDataPtr
     469 0000008c                   UDEV_Obj 1, VP0CAPTURE, 0, _iFxns, _driverType, _iParams, _deviceId, _initFxn, _deviceGlobalDa
1                           
1        00000000                   .sect   ".const"
1        00000000 0000002F  UDEV_VP0CAPTURE .string "/VP0CAPTURE",0 ; Set up string "/<devName>"
         00000001 00000056 
         00000002 00000050 
         00000003 00000030 
         00000004 00000043 
         00000005 00000041 
         00000006 00000050 
         00000007 00000054 
         00000008 00000055 
         00000009 00000052 
         0000000a 00000045 
         0000000b 00000000 
1                           
1                                   ; This matches SIO_:_device:$params in sio.hti
1                                   .asg "_EMB_vCapParamsPort", SIO_VP0CAPTURE$params
1                           
1                                   ;
1                                   ; This adds an entry to the device table, DEV_devtab, and the init
1                                   ; table, DEV_devinit.
1                                   ;
1        0000000c                   DEV_addDevice UDEV_VP0CAPTURE, _VPORTCAP_Fxns, 00H, _EMB_vCapParamsPort, 00H, DEV_IOMTYPE, 00H
2                           
2                                   .global UDEV_VP0CAPTURE$obj
2                                   .global UDEV_VP0CAPTURE$device 
2        00000000           UDEV_VP0CAPTURE$obj     .usect  ".devtable", 9 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
2                           
2                 0000000C- UDEV_VP0CAPTURE$device .set UDEV_VP0CAPTURE$obj + (3 * STD_TARGWORDMAUS)
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   19

2                           
2                             ; UDEV_VP0CAPTURE$device points to begining of DEV_Device entry. Note that
2                             ; UDEV_VP0CAPTURE can't be used here because UDEV_VP0CAPTURE is a string already 
2                             ; allocated in const by Obj's that call this macro. 
2                             ; So UDEV_VP0CAPTURE cannot be redefined to point to this DEV_Device entry.
2                           
2        0000008c                   .sect   ".cinit"
2                                   .align  STD_TARGALIGN
2        00000090 00000024          .word   9 * STD_TARGWORDMAUS
2        00000094 00000000-         .word   UDEV_VP0CAPTURE$obj
2                           
2        00000098                   OBJ_Obj UDEV_VP0CAPTURE$obj, OBJ_DEV, DEV_ENTRYSIZE     ;Cinitialized 3 words 
3                           
3                           ;
3                           ;  OBJ_SEM 
3                           ;
3                           
3                                   .if OBJ_DEV == OBJ_SEM
3                           
3                                       .if SEM$NUMOF != SEM$sernum
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sem$prev
3                           
3                                       .if SEM$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sem$next
3                                       .endif
3                           
3                                       .eval       SEM$sernum+1, SEM$sernum
3                           
3                           ;
3                           ;  OBJ_SWI
3                           ;
3                            
3                                   .elseif OBJ_DEV == OBJ_SWI
3                            
3                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
3                                           ; next points to next SWI Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   20

3                                       .endif
3                                    
3                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_swi$prev
3                           
3                                       .if SWI$sernum = 1                  ; first SWI Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       SWI$sernum+1, SWI$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_TSK 
3                           ;
3                           
3                                   .elseif OBJ_DEV == OBJ_TSK
3                           
3                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
3                                           ; next points to next TSK Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_tsk$prev
3                           
3                                       .if TSK$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       TSK$sernum+1, TSK$sernum
3                           
3                           ;
3                           ;  OBJ_MBX 
3                           ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   21

3                                   .elseif OBJ_DEV == OBJ_MBX
3                           
3                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_mbx$prev
3                           
3                                       .if MBX$sernum = 1                  ; first MBX Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_mbx$next
3                                       .endif
3                           
3                                       .eval       MBX$sernum+1, MBX$sernum
3                           
3                           ;
3                           ;  OBJ_SIO 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_SIO
3                           
3                                       .if (SIO$NUMOF != SIO$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sio$prev
3                           
3                                       .if SIO$sernum = 1                  ; first SIO Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sio$next
3                                       .endif
3                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   22

3                                       .eval       SIO$sernum+1, SIO$sernum
3                           
3                           ;
3                           ;  OBJ_DEV 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_DEV
3                                      
3                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
3                                       ; that get created. These entries are created from UDEV, DGN, DHL
3                                       ; DPI and DIO. 
3                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
3                           
3                                       .if DEV$NUMDEVICES != 1
3                                           ; next points to next object
3        00000098 00000024-                 .word   UDEV_VP0CAPTURE$obj + 9 * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
3                                       .endif
3                           
3        0000009c 00000058-             .word       _OBJ_table + 10 * STD_TARGWORDMAUS              ; previous object or OBJ_table
3                           
3        000000a0 0000ABC5              .word       OBJ_DEV | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       ; Below assignment is different from other OBJ modules. 
3                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
3                                       ; with UDEV_VP0CAPTURE$obj$obj itself. For example 'DGN_printData$obj', Note
3                                       ; that here we can't pass 'DGN_printData' to this macro
3                                       ; Because 'DGN_printData' is a string allocated in .const section
3                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
3                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
3                                       ; not string 'DGN_printData'
3                           
3                                       .asg "UDEV_VP0CAPTURE$obj", OBJ_dev$prev
3                           
3                                       .if 1 = 1                   ; first DEV_Device Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg "UDEV_VP0CAPTURE$obj", OBJ_dev$next
3                                       .endif
3                           
3                                       .eval       1+1, DEV$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_BUF 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_BUF
3                           
3                                       .if (BUF$NUMOF != BUF$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   23

3                                       .else
3                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_buf$prev
3                           
3                                       .if BUF$sernum = 1                  ; first BUF Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_buf$next
3                                       .endif
3                                       
3                                       .eval       BUF$sernum+1, BUF$sernum
3                                   
3                                   .else
3                           
3                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
3                           
3                                   .endif
3                           
2        000000a4 00000000+         .word  UDEV_VP0CAPTURE
2        000000a8 00000000!         .word  _VPORTCAP_Fxns
2        000000ac 00000000          .word  00H
2        000000b0 00000000!         .word  _EMB_vCapParamsPort
2        000000b4 00000001          .word  DEV_IOMTYPE
2        000000b8 00000000          .word  00H
2                           
2                                   ;
2                                   ; Prevent multiple appearances of a driver Dxx_init function in the
2                                   ; _DEV_devinit table even when there are  multiple occurrences of
2                                   ; different devices for the same driver. DXX_init should be only called
2                                   ; once!
2                                   ;
2                                   ; Only add to _DEV_devinit real functions. Do not add 0's.
2                                   .if ($isname("00H") = 1)
2                                     .if ($isdefed("DEV$:_initfxn:") = 0)
2                           DEV$:00H:       .set    1
2                           
2                                       .global     :_initfxn:
2                           
2                                       .sect       ".cinit"
2                                       .align      STD_TARGALIGN
2                                       .word       STD_TARGWORDMAUS
2                                       .word       _DEV_devinit + DEV$initCount * STD_TARGWORDMAUS
2                                       .word       :_initfxn:
2                           
2                                       ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   24

2                                       ; increment DEV$initCount for use by the next call of this macro and
2                                       ; DEV_end. DEV$initCount keep track of the size of _DEV_devinit.
2                                       ;
2                                       .eval       DEV$initCount+1,DEV$initCount
2                           
2                                     .endif        ; endif ($isdefed(DEV$:_initfxn:) = 0)
2                                   .endif          ; endif ($isname(":_initfxn:") = 1)
2                           
1                           
     470                    
     471                    ;; ======== UDEV_Obj VP1CAPTURE ========
     472                    ;; <add comments here>
     473                    ;;
     474                    ;; UDEV_Obj VP1CAPTURE (iFxns, driverType, iParams, deviceId, initFxn, deviceGlobalDataPtr)
     475                            .global VP1CAPTURE
     476                            .asg _VPORTCAP_Fxns, _iFxns
     477                            .asg "DEV_IOMTYPE", _driverType
     478                            .asg _EMB_vCapParamsPort, _iParams
     479                            .asg 01H, _deviceId
     480                            .asg 00H, _initFxn
     481                            .asg 00H, _deviceGlobalDataPtr
     482 000000bc                   UDEV_Obj 1, VP1CAPTURE, 0, _iFxns, _driverType, _iParams, _deviceId, _initFxn, _deviceGlobalDa
1                           
1        0000000c                   .sect   ".const"
1        0000000c 0000002F  UDEV_VP1CAPTURE .string "/VP1CAPTURE",0 ; Set up string "/<devName>"
         0000000d 00000056 
         0000000e 00000050 
         0000000f 00000031 
         00000010 00000043 
         00000011 00000041 
         00000012 00000050 
         00000013 00000054 
         00000014 00000055 
         00000015 00000052 
         00000016 00000045 
         00000017 00000000 
1                           
1                                   ; This matches SIO_:_device:$params in sio.hti
1                                   .asg "_EMB_vCapParamsPort", SIO_VP1CAPTURE$params
1                           
1                                   ;
1                                   ; This adds an entry to the device table, DEV_devtab, and the init
1                                   ; table, DEV_devinit.
1                                   ;
1        00000018                   DEV_addDevice UDEV_VP1CAPTURE, _VPORTCAP_Fxns, 01H, _EMB_vCapParamsPort, 00H, DEV_IOMTYPE, 00H
2                           
2                                   .global UDEV_VP1CAPTURE$obj
2                                   .global UDEV_VP1CAPTURE$device 
2        00000024           UDEV_VP1CAPTURE$obj     .usect  ".devtable", 9 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
2                           
2                 00000030- UDEV_VP1CAPTURE$device .set UDEV_VP1CAPTURE$obj + (3 * STD_TARGWORDMAUS)
2                           
2                             ; UDEV_VP1CAPTURE$device points to begining of DEV_Device entry. Note that
2                             ; UDEV_VP1CAPTURE can't be used here because UDEV_VP1CAPTURE is a string already 
2                             ; allocated in const by Obj's that call this macro. 
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   25

2                             ; So UDEV_VP1CAPTURE cannot be redefined to point to this DEV_Device entry.
2                           
2        000000bc                   .sect   ".cinit"
2                                   .align  STD_TARGALIGN
2        000000c0 00000024          .word   9 * STD_TARGWORDMAUS
2        000000c4 00000024-         .word   UDEV_VP1CAPTURE$obj
2                           
2        000000c8                   OBJ_Obj UDEV_VP1CAPTURE$obj, OBJ_DEV, DEV_ENTRYSIZE     ;Cinitialized 3 words 
3                           
3                           ;
3                           ;  OBJ_SEM 
3                           ;
3                           
3                                   .if OBJ_DEV == OBJ_SEM
3                           
3                                       .if SEM$NUMOF != SEM$sernum
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sem$prev
3                           
3                                       .if SEM$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sem$next
3                                       .endif
3                           
3                                       .eval       SEM$sernum+1, SEM$sernum
3                           
3                           ;
3                           ;  OBJ_SWI
3                           ;
3                            
3                                   .elseif OBJ_DEV == OBJ_SWI
3                            
3                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
3                                           ; next points to next SWI Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
3                                       .endif
3                                    
3                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
3                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   26

3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_swi$prev
3                           
3                                       .if SWI$sernum = 1                  ; first SWI Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       SWI$sernum+1, SWI$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_TSK 
3                           ;
3                           
3                                   .elseif OBJ_DEV == OBJ_TSK
3                           
3                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
3                                           ; next points to next TSK Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_tsk$prev
3                           
3                                       .if TSK$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       TSK$sernum+1, TSK$sernum
3                           
3                           ;
3                           ;  OBJ_MBX 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_MBX
3                           
3                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
3                                           ; next points to next object
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   27

3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_mbx$prev
3                           
3                                       .if MBX$sernum = 1                  ; first MBX Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_mbx$next
3                                       .endif
3                           
3                                       .eval       MBX$sernum+1, MBX$sernum
3                           
3                           ;
3                           ;  OBJ_SIO 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_SIO
3                           
3                                       .if (SIO$NUMOF != SIO$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sio$prev
3                           
3                                       .if SIO$sernum = 1                  ; first SIO Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sio$next
3                                       .endif
3                           
3                                       .eval       SIO$sernum+1, SIO$sernum
3                           
3                           ;
3                           ;  OBJ_DEV 
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   28

3                           ;
3                                   .elseif OBJ_DEV == OBJ_DEV
3                                      
3                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
3                                       ; that get created. These entries are created from UDEV, DGN, DHL
3                                       ; DPI and DIO. 
3                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
3                           
3                                       .if DEV$NUMDEVICES != 2
3                                           ; next points to next object
3        000000c8 00000048-                 .word   UDEV_VP1CAPTURE$obj + 9 * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
3                                       .endif
3                           
3        000000cc 00000000-             .word       UDEV_VP0CAPTURE$obj             ; previous object or OBJ_table
3                           
3        000000d0 0000ABC5              .word       OBJ_DEV | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       ; Below assignment is different from other OBJ modules. 
3                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
3                                       ; with UDEV_VP1CAPTURE$obj$obj itself. For example 'DGN_printData$obj', Note
3                                       ; that here we can't pass 'DGN_printData' to this macro
3                                       ; Because 'DGN_printData' is a string allocated in .const section
3                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
3                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
3                                       ; not string 'DGN_printData'
3                           
3                                       .asg "UDEV_VP1CAPTURE$obj", OBJ_dev$prev
3                           
3                                       .if 2 = 1                   ; first DEV_Device Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:", OBJ_dev$next
3                                       .endif
3                           
3                                       .eval       2+1, DEV$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_BUF 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_BUF
3                           
3                                       .if (BUF$NUMOF != BUF$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
3                                       .endif
3                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   29

3                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_buf$prev
3                           
3                                       .if BUF$sernum = 1                  ; first BUF Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_buf$next
3                                       .endif
3                                       
3                                       .eval       BUF$sernum+1, BUF$sernum
3                                   
3                                   .else
3                           
3                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
3                           
3                                   .endif
3                           
2        000000d4 0000000C+         .word  UDEV_VP1CAPTURE
2        000000d8 00000000!         .word  _VPORTCAP_Fxns
2        000000dc 00000001          .word  01H
2        000000e0 00000000!         .word  _EMB_vCapParamsPort
2        000000e4 00000001          .word  DEV_IOMTYPE
2        000000e8 00000000          .word  00H
2                           
2                                   ;
2                                   ; Prevent multiple appearances of a driver Dxx_init function in the
2                                   ; _DEV_devinit table even when there are  multiple occurrences of
2                                   ; different devices for the same driver. DXX_init should be only called
2                                   ; once!
2                                   ;
2                                   ; Only add to _DEV_devinit real functions. Do not add 0's.
2                                   .if ($isname("00H") = 1)
2                                     .if ($isdefed("DEV$:_initfxn:") = 0)
2                           DEV$:00H:       .set    1
2                           
2                                       .global     :_initfxn:
2                           
2                                       .sect       ".cinit"
2                                       .align      STD_TARGALIGN
2                                       .word       STD_TARGWORDMAUS
2                                       .word       _DEV_devinit + DEV$initCount * STD_TARGWORDMAUS
2                                       .word       :_initfxn:
2                           
2                                       ;
2                                       ; increment DEV$initCount for use by the next call of this macro and
2                                       ; DEV_end. DEV$initCount keep track of the size of _DEV_devinit.
2                                       ;
2                                       .eval       DEV$initCount+1,DEV$initCount
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   30

2                           
2                                     .endif        ; endif ($isdefed(DEV$:_initfxn:) = 0)
2                                   .endif          ; endif ($isname(":_initfxn:") = 1)
2                           
1                           
     483                    
     484                    ;; ======== UDEV_Obj VP2DISPLAY ========
     485                    ;; <add comments here>
     486                    ;;
     487                    ;; UDEV_Obj VP2DISPLAY (iFxns, driverType, iParams, deviceId, initFxn, deviceGlobalDataPtr)
     488                            .global VP2DISPLAY
     489                            .asg _VPORTDIS_Fxns, _iFxns
     490                            .asg "DEV_IOMTYPE", _driverType
     491                            .asg _EMB_vDisParamsPort, _iParams
     492                            .asg 02H, _deviceId
     493                            .asg 00H, _initFxn
     494                            .asg 00H, _deviceGlobalDataPtr
     495 000000ec                   UDEV_Obj 1, VP2DISPLAY, 0, _iFxns, _driverType, _iParams, _deviceId, _initFxn, _deviceGlobalDa
1                           
1        00000018                   .sect   ".const"
1        00000018 0000002F  UDEV_VP2DISPLAY .string "/VP2DISPLAY",0 ; Set up string "/<devName>"
         00000019 00000056 
         0000001a 00000050 
         0000001b 00000032 
         0000001c 00000044 
         0000001d 00000049 
         0000001e 00000053 
         0000001f 00000050 
         00000020 0000004C 
         00000021 00000041 
         00000022 00000059 
         00000023 00000000 
1                           
1                                   ; This matches SIO_:_device:$params in sio.hti
1                                   .asg "_EMB_vDisParamsPort", SIO_VP2DISPLAY$params
1                           
1                                   ;
1                                   ; This adds an entry to the device table, DEV_devtab, and the init
1                                   ; table, DEV_devinit.
1                                   ;
1        00000024                   DEV_addDevice UDEV_VP2DISPLAY, _VPORTDIS_Fxns, 02H, _EMB_vDisParamsPort, 00H, DEV_IOMTYPE, 00H
2                           
2                                   .global UDEV_VP2DISPLAY$obj
2                                   .global UDEV_VP2DISPLAY$device 
2        00000048           UDEV_VP2DISPLAY$obj     .usect  ".devtable", 9 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
2                           
2                 00000054- UDEV_VP2DISPLAY$device .set UDEV_VP2DISPLAY$obj + (3 * STD_TARGWORDMAUS)
2                           
2                             ; UDEV_VP2DISPLAY$device points to begining of DEV_Device entry. Note that
2                             ; UDEV_VP2DISPLAY can't be used here because UDEV_VP2DISPLAY is a string already 
2                             ; allocated in const by Obj's that call this macro. 
2                             ; So UDEV_VP2DISPLAY cannot be redefined to point to this DEV_Device entry.
2                           
2        000000ec                   .sect   ".cinit"
2                                   .align  STD_TARGALIGN
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   31

2        000000f0 00000024          .word   9 * STD_TARGWORDMAUS
2        000000f4 00000048-         .word   UDEV_VP2DISPLAY$obj
2                           
2        000000f8                   OBJ_Obj UDEV_VP2DISPLAY$obj, OBJ_DEV, DEV_ENTRYSIZE     ;Cinitialized 3 words 
3                           
3                           ;
3                           ;  OBJ_SEM 
3                           ;
3                           
3                                   .if OBJ_DEV == OBJ_SEM
3                           
3                                       .if SEM$NUMOF != SEM$sernum
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sem$prev
3                           
3                                       .if SEM$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sem$next
3                                       .endif
3                           
3                                       .eval       SEM$sernum+1, SEM$sernum
3                           
3                           ;
3                           ;  OBJ_SWI
3                           ;
3                            
3                                   .elseif OBJ_DEV == OBJ_SWI
3                            
3                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
3                                           ; next points to next SWI Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
3                                       .endif
3                                    
3                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   32

3                                       ;
3                                       .asg        ":name:$obj", OBJ_swi$prev
3                           
3                                       .if SWI$sernum = 1                  ; first SWI Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       SWI$sernum+1, SWI$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_TSK 
3                           ;
3                           
3                                   .elseif OBJ_DEV == OBJ_TSK
3                           
3                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
3                                           ; next points to next TSK Obj
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
3                                       .endif
3                                   
3                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_tsk$prev
3                           
3                                       .if TSK$sernum = 1                  ; first TSK Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
3                                       .endif
3                           
3                                       .eval       TSK$sernum+1, TSK$sernum
3                           
3                           ;
3                           ;  OBJ_MBX 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_MBX
3                           
3                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
3                                       .endif
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   33

3                                   
3                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg        ":name:$obj", OBJ_mbx$prev
3                           
3                                       .if MBX$sernum = 1                  ; first MBX Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_mbx$next
3                                       .endif
3                           
3                                       .eval       MBX$sernum+1, MBX$sernum
3                           
3                           ;
3                           ;  OBJ_SIO 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_SIO
3                           
3                                       .if (SIO$NUMOF != SIO$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_sio$prev
3                           
3                                       .if SIO$sernum = 1                  ; first SIO Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_sio$next
3                                       .endif
3                           
3                                       .eval       SIO$sernum+1, SIO$sernum
3                           
3                           ;
3                           ;  OBJ_DEV 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_DEV
3                                      
3                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   34

3                                       ; that get created. These entries are created from UDEV, DGN, DHL
3                                       ; DPI and DIO. 
3                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
3                           
3                                       .if DEV$NUMDEVICES != 3
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3        000000f8 00000058-                 .word   _OBJ_table + 10 * STD_TARGWORDMAUS              ; next points back to OBJ_tabl
3                                       .endif
3                           
3        000000fc 00000024-             .word       UDEV_VP1CAPTURE$obj             ; previous object or OBJ_table
3                           
3        00000100 0000ABC5              .word       OBJ_DEV | OBJ_KEY
3                           
3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       ; Below assignment is different from other OBJ modules. 
3                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
3                                       ; with UDEV_VP2DISPLAY$obj$obj itself. For example 'DGN_printData$obj', Note
3                                       ; that here we can't pass 'DGN_printData' to this macro
3                                       ; Because 'DGN_printData' is a string allocated in .const section
3                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
3                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
3                                       ; not string 'DGN_printData'
3                           
3                                       .asg "UDEV_VP2DISPLAY$obj", OBJ_dev$prev
3                           
3                                       .if 3 = 1                   ; first DEV_Device Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:", OBJ_dev$next
3                                       .endif
3                           
3                                       .eval       3+1, DEV$sernum
3                           
3                           
3                           ;
3                           ;  OBJ_BUF 
3                           ;
3                                   .elseif OBJ_DEV == OBJ_BUF
3                           
3                                       .if (BUF$NUMOF != BUF$sernum)
3                                           ; next points to next object
3                                           .word   :name: + :size: * STD_TARGWORDMAUS
3                                       .else
3                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
3                                       .endif
3                           
3                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
3                           
3                                       .word       :type: | OBJ_KEY
3                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   35

3                                       ;
3                                       ; For next obj, this one is prev
3                                       ;
3                                       .asg ":name:$obj", OBJ_buf$prev
3                           
3                                       .if BUF$sernum = 1                  ; first BUF Obj
3                                           ;
3                                           ; If this is the first element, queue head will point to this
3                                           ;
3                                           .asg ":name:$obj", OBJ_buf$next
3                                       .endif
3                                       
3                                       .eval       BUF$sernum+1, BUF$sernum
3                                   
3                                   .else
3                           
3                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
3                           
3                                   .endif
3                           
2        00000104 00000018+         .word  UDEV_VP2DISPLAY
2        00000108 00000000!         .word  _VPORTDIS_Fxns
2        0000010c 00000002          .word  02H
2        00000110 00000000!         .word  _EMB_vDisParamsPort
2        00000114 00000001          .word  DEV_IOMTYPE
2        00000118 00000000          .word  00H
2                           
2                                   ;
2                                   ; Prevent multiple appearances of a driver Dxx_init function in the
2                                   ; _DEV_devinit table even when there are  multiple occurrences of
2                                   ; different devices for the same driver. DXX_init should be only called
2                                   ; once!
2                                   ;
2                                   ; Only add to _DEV_devinit real functions. Do not add 0's.
2                                   .if ($isname("00H") = 1)
2                                     .if ($isdefed("DEV$:_initfxn:") = 0)
2                           DEV$:00H:       .set    1
2                           
2                                       .global     :_initfxn:
2                           
2                                       .sect       ".cinit"
2                                       .align      STD_TARGALIGN
2                                       .word       STD_TARGWORDMAUS
2                                       .word       _DEV_devinit + DEV$initCount * STD_TARGWORDMAUS
2                                       .word       :_initfxn:
2                           
2                                       ;
2                                       ; increment DEV$initCount for use by the next call of this macro and
2                                       ; DEV_end. DEV$initCount keep track of the size of _DEV_devinit.
2                                       ;
2                                       .eval       DEV$initCount+1,DEV$initCount
2                           
2                                     .endif        ; endif ($isdefed(DEV$:_initfxn:) = 0)
2                                   .endif          ; endif ($isname(":_initfxn:") = 1)
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   36

1                           
     496                    
     497                    ;; ======== MEM_Obj ISRAM ========
     498                    ;; This object defines space for the DSP's on-chip memory
     499                    ;;
     500                    ;; MEM_Obj ISRAM (len, iAllocHeap, iSegZero, iHeapId)
     501                            .global ISRAM
     502                            .asg 02f300H, _len
     503                            .asg 00H, _iAllocHeap
     504                            .asg SDRAM, _iSegZero
     505                            .asg segment_name, _iHeapId
     506 0000011c                   MEM_Obj 1, ISRAM, 0, _len, _iAllocHeap, _iSegZero, _iHeapId
1                           
1                               .if 1 == 1
1                           
1                                   .asg -1, idxVal    ; default index value
1                               
1                                 .if    02f300H
1                           
1                                   .if 00H
1                           
1                                       .global :name:$B    ; heap base address
1                                       .global :name:$L    ; heap length
1                           
1                                       ;
1                                       ; Define an entry in _MEM_memtab[] (allocated out of bss in
1                                       ; MEM_config.
1                                       ; The following block must match the MEM_Segment structure
1                                       ; in mem.h.
1                                       ;
1                                       .sect ".cinit"
1                                       .align STD_TARGALIGN
1                                       .if    $symcmp(":name:", ":_iSegZero:") == 0
1                                             .word 3 * STD_TARGWORDMAUS
1                                             .word _MEM_memtab   
1                                             .eval 0, idxVal
1                                       .else
1                                             .word 3 * STD_TARGWORDMAUS
1                                             .word _MEM_memtab + MEM_tabIdx *3 * STD_TARGWORDMAUS
1                                             ; assign meaningful index value
1                                             .eval MEM_tabIdx, idxVal
1                           
1                                             ; post-increment macro variable for next pass
1                                             .eval    MEM_tabIdx + 1, MEM_tabIdx
1                                       .endif
1                                             .word :name:$B
1                                             .word :name:$L
1                                             .word 1
1                           
1                                             ; create array index variable (using the segment's name)
1                                             .bss :name:, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                             .sect ".cinit"
1                                             .align STD_TARGALIGN
1                                             .word 1 * STD_TARGWORDMAUS
1                                             .word :name:   
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   37

1                                             .word idxVal
1                           
1                                            ; create array index variable (using the segment's name)
1                                           .if $symcmp(":_iHeapId:", "segment_name") != 0
1                                               .global :_iHeapId:
1                           :_iHeapId:          .set :name:
1                                           .endif
1                           
1                           
1                           :name:$idx .set    idxVal    ; used by MEM_config
1                           
1                                   .else
1                 FFFFFFFF  ISRAM .set -1        ; To satisfy assignment of C alias in *cfg.cmd file.
1                           
1                                   .endif            ; .if :iHeap:
1                           
1                                 .endif            ; .if 02f300H
1                           
1                               .endif                ; .if 1 == 1
1                           
     507                    
     508                    ;; ======== MEM_Obj SDRAM ========
     509                    ;; This object defines space for the DSP's off-chip memory
     510                    ;;
     511                    ;; MEM_Obj SDRAM (len, iAllocHeap, iSegZero, iHeapId)
     512                            .global SDRAM
     513                            .asg 01f00000H, _len
     514                            .asg 01H, _iAllocHeap
     515                            .asg SDRAM, _iSegZero
     516                            .asg _extHeap, _iHeapId
     517 0000011c                   MEM_Obj 1, SDRAM, 0, _len, _iAllocHeap, _iSegZero, _iHeapId
1                           
1                               .if 1 == 1
1                           
1                                   .asg -1, idxVal    ; default index value
1                               
1                                 .if    01f00000H
1                           
1                                   .if 01H
1                           
1                                       .global SDRAM$B    ; heap base address
1                                       .global SDRAM$L    ; heap length
1                           
1                                       ;
1                                       ; Define an entry in _MEM_memtab[] (allocated out of bss in
1                                       ; MEM_config.
1                                       ; The following block must match the MEM_Segment structure
1                                       ; in mem.h.
1                                       ;
1        0000011c                       .sect ".cinit"
1                                       .align STD_TARGALIGN
1                                       .if    $symcmp("SDRAM", "SDRAM") == 0
1        00000120 0000000C                    .word 3 * STD_TARGWORDMAUS
1        00000124 00000000-                   .word _MEM_memtab   
1                                             .eval 0, idxVal
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   38

1                                       .else
1                                             .word 3 * STD_TARGWORDMAUS
1                                             .word _MEM_memtab + MEM_tabIdx *3 * STD_TARGWORDMAUS
1                                             ; assign meaningful index value
1                                             .eval MEM_tabIdx, idxVal
1                           
1                                             ; post-increment macro variable for next pass
1                                             .eval    MEM_tabIdx + 1, MEM_tabIdx
1                                       .endif
1        00000128 00000000!                   .word SDRAM$B
1        0000012c 00000000!                   .word SDRAM$L
1        00000130 00000001                    .word 1
1                           
1                                             ; create array index variable (using the segment's name)
1        00000014                             .bss SDRAM, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        00000134                             .sect ".cinit"
1                                             .align STD_TARGALIGN
1        00000138 00000004                    .word 1 * STD_TARGWORDMAUS
1        0000013c 00000014-                   .word SDRAM   
1        00000140 00000000                    .word 0
1                           
1                                            ; create array index variable (using the segment's name)
1                                           .if $symcmp("_extHeap", "segment_name") != 0
1                                               .global _extHeap
1                 00000014- _extHeap            .set SDRAM
1                                           .endif
1                           
1                           
1                 00000000  SDRAM$idx .set    0    ; used by MEM_config
1                           
1                                   .else
1                           :name: .set -1        ; To satisfy assignment of C alias in *cfg.cmd file.
1                           
1                                   .endif            ; .if :iHeap:
1                           
1                                 .endif            ; .if 01f00000H
1                           
1                               .endif                ; .if 1 == 1
1                           
     518                    
     519                    ;; ======== BUF_Obj BUF_imgPool ========
     520                    ;; grabbed image pool
     521                    ;;
     522                    ;; BUF_Obj BUF_imgPool (bufseg, bufcount, size, align, postalignsize)
     523                            .global BUF_imgPool
     524                            .asg SDRAM, _bufseg
     525                            .asg 02H, _bufcount
     526                            .asg 04b000H, _size
     527                            .asg 04H, _align
     528                            .asg 04b000H, _postalignsize
     529 00000144                   BUF_Obj 1, BUF_imgPool, 0, _bufseg, _bufcount, _size, _align, _postalignsize
1                           
1                                   .global BUF_imgPool
1                                   .global BUF_imgPool$databeg
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   39

1                           
1        00000000           BUF_imgPool$obj .usect ".buf", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000000c           BUF_imgPool             .usect ".buf", 7 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000144                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000148 00000028          .word   10 * STD_TARGWORDMAUS
1        0000014c 00000000-         .word   BUF_imgPool$obj
1                           
1                                   ; A label for this object, "BUF_imgPool", will be set in OBJ_Obj
1        00000150                   OBJ_Obj BUF_imgPool, OBJ_BUF, BUF_CORESIZE
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_BUF == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_BUF == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   40

2                                       .endif
2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_BUF == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_tsk$prev
2                           
2                                       .if TSK$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       TSK$sernum+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   41

2                                   .elseif OBJ_BUF == OBJ_MBX
2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   42

2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != 1)
2                                           ; next points to next object
2        00000150 00000028-                 .word   BUF_imgPool + 7 * STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   43

2                                       .else
2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
2                                       .endif
2                           
2        00000154 00000060-             .word       _OBJ_table + 12 * STD_TARGWORDMAUS              ; previous object or OBJ_table
2                           
2        00000158 0000ABC6              .word       OBJ_BUF | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg "BUF_imgPool$obj", OBJ_buf$prev
2                           
2                                       .if 1 = 1                   ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg "BUF_imgPool$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       1+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        0000015c 00000000!         .word   BUF_imgPool$databeg  ; This filed is defined in linker command file
1        00000160 0004B000          .word   04b000H          ; original buffer size before alignment
1        00000164 0004B000          .word   04b000H ; size after alignment
1        00000168 00000000!         .word   BUF_imgPool$databeg  ; Address of first free buffer
1        0000016c 00000002          .word   02H       ; Total number of buffers in pool
1        00000170 00000002          .word   02H       ; Number of free buffers in pool
1        00000174 00000014-         .word   SDRAM          ; Memory segment of buffer pool
1                           
1                           
     530                    
     531                    ;; ======== BUF_Obj BUF_copyPool ========
     532                    ;; copy image pool
     533                    ;;
     534                    ;; BUF_Obj BUF_copyPool (bufseg, bufcount, size, align, postalignsize)
     535                            .global BUF_copyPool
     536                            .asg SDRAM, _bufseg
     537                            .asg 02H, _bufcount
     538                            .asg 04b44cH, _size
     539                            .asg 04H, _align
     540                            .asg 04b44cH, _postalignsize
     541 00000178                   BUF_Obj 1, BUF_copyPool, 0, _bufseg, _bufcount, _size, _align, _postalignsize
1                           
1                                   .global BUF_copyPool
1                                   .global BUF_copyPool$databeg
1                           
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   44

1        00000028           BUF_copyPool$obj        .usect ".buf", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000034           BUF_copyPool            .usect ".buf", 7 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000178                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000178 00000028          .word   10 * STD_TARGWORDMAUS
1        0000017c 00000028-         .word   BUF_copyPool$obj
1                           
1                                   ; A label for this object, "BUF_copyPool", will be set in OBJ_Obj
1        00000180                   OBJ_Obj BUF_copyPool, OBJ_BUF, BUF_CORESIZE
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_BUF == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_BUF == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
2                                       .endif
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   45

2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_BUF == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_tsk$prev
2                           
2                                       .if TSK$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       TSK$sernum+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_MBX
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   46

2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
2                                       .eval       SIO$sernum+1, SIO$sernum
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   47

2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != 2)
2                                           ; next points to next object
2        00000180 00000050-                 .word   BUF_copyPool + 7 * STD_TARGWORDMAUS
2                                       .else
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   48

2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
2                                       .endif
2                           
2        00000184 00000000-             .word       BUF_imgPool$obj         ; previous object or OBJ_table
2                           
2        00000188 0000ABC6              .word       OBJ_BUF | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg "BUF_copyPool$obj", OBJ_buf$prev
2                           
2                                       .if 2 = 1                   ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       2+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        0000018c 00000000!         .word   BUF_copyPool$databeg  ; This filed is defined in linker command file
1        00000190 0004B44C          .word   04b44cH          ; original buffer size before alignment
1        00000194 0004B44C          .word   04b44cH ; size after alignment
1        00000198 00000000!         .word   BUF_copyPool$databeg  ; Address of first free buffer
1        0000019c 00000002          .word   02H       ; Total number of buffers in pool
1        000001a0 00000002          .word   02H       ; Number of free buffers in pool
1        000001a4 00000014-         .word   SDRAM          ; Memory segment of buffer pool
1                           
1                           
     542                    
     543                    ;; ======== BUF_Obj BUF_imgCap ========
     544                    ;; <add comments here>
     545                    ;;
     546                    ;; BUF_Obj BUF_imgCap (bufseg, bufcount, size, align, postalignsize)
     547                            .global BUF_imgCap
     548                            .asg SDRAM, _bufseg
     549                            .asg 02H, _bufcount
     550                            .asg 04b000H, _size
     551                            .asg 04H, _align
     552                            .asg 04b000H, _postalignsize
     553 000001a8                   BUF_Obj 1, BUF_imgCap, 0, _bufseg, _bufcount, _size, _align, _postalignsize
1                           
1                                   .global BUF_imgCap
1                                   .global BUF_imgCap$databeg
1                           
1                           
1        00000050           BUF_imgCap$obj  .usect ".buf", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   49

1                           
1        0000005c           BUF_imgCap              .usect ".buf", 7 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        000001a8                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        000001a8 00000028          .word   10 * STD_TARGWORDMAUS
1        000001ac 00000050-         .word   BUF_imgCap$obj
1                           
1                                   ; A label for this object, "BUF_imgCap", will be set in OBJ_Obj
1        000001b0                   OBJ_Obj BUF_imgCap, OBJ_BUF, BUF_CORESIZE
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_BUF == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_BUF == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
2                                       .endif
2                                    
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   50

2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_BUF == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_tsk$prev
2                           
2                                       .if TSK$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       TSK$sernum+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_MBX
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   51

2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   52

2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != 3)
2                                           ; next points to next object
2        000001b0 00000078-                 .word   BUF_imgCap + 7 * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   53

2                                       .endif
2                           
2        000001b4 00000028-             .word       BUF_copyPool$obj                ; previous object or OBJ_table
2                           
2        000001b8 0000ABC6              .word       OBJ_BUF | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg "BUF_imgCap$obj", OBJ_buf$prev
2                           
2                                       .if 3 = 1                   ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       3+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        000001bc 00000000!         .word   BUF_imgCap$databeg  ; This filed is defined in linker command file
1        000001c0 0004B000          .word   04b000H          ; original buffer size before alignment
1        000001c4 0004B000          .word   04b000H ; size after alignment
1        000001c8 00000000!         .word   BUF_imgCap$databeg  ; Address of first free buffer
1        000001cc 00000002          .word   02H       ; Total number of buffers in pool
1        000001d0 00000002          .word   02H       ; Number of free buffers in pool
1        000001d4 00000014-         .word   SDRAM          ; Memory segment of buffer pool
1                           
1                           
     554                    
     555                    ;; ======== BUF_Obj BUF_capFrame ========
     556                    ;; <add comments here>
     557                    ;;
     558                    ;; BUF_Obj BUF_capFrame (bufseg, bufcount, size, align, postalignsize)
     559                            .global BUF_capFrame
     560                            .asg SDRAM, _bufseg
     561                            .asg 02H, _bufcount
     562                            .asg 096000H, _size
     563                            .asg 04H, _align
     564                            .asg 096000H, _postalignsize
     565 000001d8                   BUF_Obj 1, BUF_capFrame, 0, _bufseg, _bufcount, _size, _align, _postalignsize
1                           
1                                   .global BUF_capFrame
1                                   .global BUF_capFrame$databeg
1                           
1                           
1        00000078           BUF_capFrame$obj        .usect ".buf", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   54

1        00000084           BUF_capFrame            .usect ".buf", 7 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        000001d8                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        000001d8 00000028          .word   10 * STD_TARGWORDMAUS
1        000001dc 00000078-         .word   BUF_capFrame$obj
1                           
1                                   ; A label for this object, "BUF_capFrame", will be set in OBJ_Obj
1        000001e0                   OBJ_Obj BUF_capFrame, OBJ_BUF, BUF_CORESIZE
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_BUF == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_BUF == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
2                                       .endif
2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   55

2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_BUF == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != TSK$sernum         ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_tsk$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_tsk$prev
2                           
2                                       .if TSK$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       TSK$sernum+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_MBX
2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   56

2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
2                           ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   57

2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_BUF == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != 4)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2        000001e0 00000060-                 .word   _OBJ_table + 12 * STD_TARGWORDMAUS              ; next points back to OBJ_tabl
2                                       .endif
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   58

2                           
2        000001e4 00000050-             .word       BUF_imgCap$obj          ; previous object or OBJ_table
2                           
2        000001e8 0000ABC6              .word       OBJ_BUF | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg "BUF_capFrame$obj", OBJ_buf$prev
2                           
2                                       .if 4 = 1                   ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       4+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        000001ec 00000000!         .word   BUF_capFrame$databeg  ; This filed is defined in linker command file
1        000001f0 00096000          .word   096000H          ; original buffer size before alignment
1        000001f4 00096000          .word   096000H ; size after alignment
1        000001f8 00000000!         .word   BUF_capFrame$databeg  ; Address of first free buffer
1        000001fc 00000002          .word   02H       ; Total number of buffers in pool
1        00000200 00000002          .word   02H       ; Number of free buffers in pool
1        00000204 00000014-         .word   SDRAM          ; Memory segment of buffer pool
1                           
1                           
     566                    
     567                    ;; ======== CLK_Obj PRD_clock ========
     568                    ;; This clock function calls PRD_tick from within the on-chip timer ISR
     569                    ;;
     570                    ;; CLK_Obj PRD_clock (function)
     571                            .global PRD_clock
     572                            .asg PRD_F_tick, _function
     573 00000208                   CLK_Obj 1, PRD_clock, 0, _function
1        00000208                   CHK_nargs "CLK_Obj", fxn
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "CLK_OBJ parameter error."
1                                   .endif
1                           
1                                   .var fxnlen
1                                   .eval $symlen("PRD_F_tick"),fxnlen
1                           
1                                   .if (1 = 0)
1                                       .mexit
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   59

1                                   .global PRD_clock
1                           
1                                   .if ($symcmp("PRD_F_tick", "0") != 0)
1                                   .global PRD_F_tick
1                                   .endif
1                           
1                           PRD_clock  .tag    CLK_Obj         ; declare name as having type CLK_Obj
1                           
1                           ; allocate all CLK objs contiguously in ".clk"
1        00000000           PRD_clock       .usect ".clk", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        00000208                   .sect ".cinit"
1                           
1                                   .align  8
1                           
1        00000208 00000004          .field  STD_TARGWORDMAUS * 1
1                           
1        0000020c 00000000-         .field  PRD_clock    
1                           
1        00000210 00000000!         .field  PRD_F_tick           ; fxn
1                           
     574                    
     575                    ;; ======== HST_Obj RTA_fromHost ========
     576                    ;; Used to access LOG and STS data
     577                    ;;
     578                    ;; HST_Obj RTA_fromHost (mode, buf, framesize, numframes, stsflg, notify, arg0, arg1, lnk, bufFrameAli
     579                            .global RTA_fromHost
     580                            .asg "input", _mode
     581                            .asg "<NULL>", _buf
     582                            .asg 04H, _framesize
     583                            .asg 01H, _numframes
     584                            .asg 00H, _stsflg
     585                            .asg _FXN_F_nop, _notify
     586                            .asg 00H, _arg0
     587                            .asg 00H, _arg1
     588                            .asg "RTDX", _lnk
     589                            .asg 04H, _bufFrameAlign
     590 00000214                   HST_Obj 1, RTA_fromHost, 1, _mode, _buf, _framesize, _numframes, _stsflg, _notify, _arg0, _arg
1                           
1                                   .if (1 = 0)
1                                       .mexit
1                                   .endif
1                            
1        00000214                   CHK_nargs "HST_Obj", lnktype 
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "HST_Obj lnktype error"
1                                   .endif
1                            
1        00000214                   CHK_domain HST_Obj, mode, "output,input", "output"
2                           
1                                   .asg "input", mode
1                                   .if ($symcmp("input", "error") = 0)
1                                       .emsg "HST_Obj mode error"
1                                   .endif
1                            
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   60

1                                   .global RTA_fromHost, RTA_fromHost$buf, RTA_fromHost$rtdx
1                            
1                                   .if ($symcmp("<NULL>", "<NULL>") = 0)
1        00000214                       GBL_Obj RTA_fromHost$buf, 04H*01H, .hst1
2        00000214                   CHK_domain "GBL_Obj", alignFlag, "noalign,align", "noalign"
3                                       .mexit
3                                           
3                           
3                           
2                                   .if ($symcmp("noalign", "error") = 0)
2                                       .emsg "GBL_Obj align parameter error."
2                                   .endif
2                                   .asg "noalign", alignFlag
2                           
2        00000214                   CHK_nargs "GBL_Obj", size
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "GBL_Obj size parameter error."
2                                   .endif
2                           
2                                   .if ($symlen(section) = 0)
2                                       .asg ".bss", section
2                                   .endif
2                           
2                                   .if ($symlen(fillValue) != 0)
2                                       .sect ".gblinit"
2                                       .word :size:
2                                       .word :name:
2                                       .word :fillValue:
2                                   .endif
2                           
2                                   .if (($symcmp(section, ".data") = 0) | ($symcmp(alignFlag, "align") = 0))
2                                       .sect ":section:"
2                                       .if ($symcmp(alignFlag, "align") = 0)
2                                           .align  :alignValue:
2                                       .endif
2                           :name::
2                                       ;
2                                       ; Can't use .space directive here because it reserves
2                                       ; bits for some processors and bytes for others.
2                                       ;
2                                       .loop       :size:
2                                           .word 0
2                                       .endloop
2                           
2                                   .elseif ($symcmp(".hst1", ".bss") = 0)
2                                       .bss :name:, :size: * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS / STD_TARGC
2                                   .else
2        00000000           RTA_fromHost$buf:     .usect ".hst1", 04H*01H * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMA
2                                   .endif
2                           
1                                       .asg    RTA_fromHost$buf, buf
1                                   .endif
1                           
1                                   .if (00H == 0)
1                                       .asg "none",stsType
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   61

1                                   .else
1                                       .if ($symcmp(":mode:","input") == 0)
1                                           .asg "reader",stsType
1                                       .else
1                                           .asg "writer",stsType
1                                       .endif
1                                   .endif
1                            
1                                   ; set first word of HST_Obj table to size of individual HST objects
1                           
1                                   .asg    0, chanId
1                           
1                                   .if 0 = 0
1                           
1        00000000           RTA_fromHost$objsize    .usect ".hst", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS 
1                           
1        00000214                       .sect ".cinit"
1                           
1                                       .align 8
1                           
1        00000218 00000004              .field STD_TARGWORDMAUS * 1
1                           
1        0000021c 00000000-             .field RTA_fromHost$objsize   
1                           
1                                       .if ($symcmp("RTDX","RTDX") == 0)
1        00000220 00000014                  .field 5 * STD_TARGWORDMAUS
1                                       .else
1                                           .field 2 * STD_TARGWORDMAUS
1                                       .endif
1                           
1                                   .endif
1                           
1        00000004           RTA_fromHost    .usect ".hst", STD_TARGWORDMAUS * 2, STD_TARGWORDMAUS 
1                            
1        00000224                   .sect ".cinit"
1                           
1                                   .align  8
1        00000228 00000008          .field  STD_TARGWORDMAUS * 2
1        0000022c 00000004-         .field  RTA_fromHost    
1        00000230 00000001          .field  1<<0    ; mask 
1        00000234 00000000-         .field  RTA_fromHost$pipe       ; pipe
1                           
1                                   .if ($symcmp("RTDX","RTDX") == 0)
1                           
1                                       ; allocate RTDX_channel
1        0000000c           RTA_fromHost$rtdx .usect ".hst", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS 
1                           
1        00000238                       .sect ".cinit"
1                           
1                                       .align 8
1                           
1        00000238 0000000C              .field STD_TARGWORDMAUS * 3
1        0000023c 0000000C-             .field RTA_fromHost$rtdx    
1        00000240 00000000              .field 0                    ; enabled = 0
1        00000244 00000000              .field 0                    ; count = 0
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   62

1        00000248 00000000              .field 0                    ; busy = 0
1                           
1                                   .endif
1                           
1                                   .if ($symcmp("input","output") == 0)
1                                           PIP_Obj 1, :name:$pipe, -1, :name:$buf, framesize, numframes, :stsType:, fxn, arg0, ar
1                                   .endif
1                            
1                                   .if ($symcmp("input","input") == 0)
1        0000024c                           PIP_Obj 1, RTA_fromHost$pipe, -1, RTA_fromHost$buf, framesize, numframes, none, RTA_F_
2                           
2                                   .global RTA_fromHost$pipe, RTA_fromHost$pipe$rd, RTA_fromHost$pipe$wr, RTA_fromHost$pipe$dtab
2                                   .global RTA_fromHost$pipe$aaa, RTA_fromHost$pipe$bbb
2                                   .asg   0,bufAlloc
2                                   .eval 0, newframesize
2                           
2                                   .eval 04H * (STD_TARGWORDMAUS/STD_TARGCHARMAUS), newframesize
2                                   ; Convert framesize to bytes which is needed since align value is
2                                   ; already in bytes.
2                           
2                                   .eval (16 + (04H - 1)) & ( ~(04H - 1)), newframesize
2                                   ; 16 is equal to multiple of 04H. This is needed
2                                   ; for all the frames to start at 'align'ed boundary from the start
2                                   ; of pip frames section. Note that pip frames section will also
2                                   ; start from 'align'ed boundary.
2                           
2                                   .if (1 = 0)
2                                       .mexit
2                                   .endif
2                           
2                                   .if ($symcmp("RTA_fromHost$buf", "<NULL>") = 0)
2                                       .eval       0, count
2                                       .asg        :name:$buf:count:, buf
2                                       .loop
2                                           .break (count == :numframes: - 1 )
2                                           .global :name:$buf:count:
2                           :name:$buf:count:       .usect ".pip:id:", :newframesize: 
2                                           .asg    :name:$buf:count:, buf:count:
2                                           .eval   count + 1, count
2                                       .endloop
2                                   
2                                       ; Last frame in the PIP buffers should start at align boundary
2                                       ; but the size of last PIP buffer need not be multiple of
2                                       ; :align:. Because there are no more frames left to start at align
2                                       ; boundary. Hence last frame is usect'd with the default
2                                       ; framesize.
2                                       .global     :name:$buf:count:
2                           :name:$buf:count:       .usect ".pip:id:", :framesize: * (STD_TARGWORDMAUS/STD_TARGCHARMAUS) 
2                                       .asg        :name:$buf:count:, buf:count:
2                           
2                                       .eval       1, bufAlloc
2                                   .endif
2                           
2        00000000           RTA_fromHost$pipe       .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   63

2        0000024c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000250 00000004          .field  STD_TARGWORDMAUS * 1
2        00000254 00000000-         .field  RTA_fromHost$pipe
2        00000258 00000004          .field  04H             ; thresh
2                           
2        00000004           RTA_fromHost$pipe$rd .usect ".pip", STD_TARGWORDMAUS * 8, STD_TARGWORDMAUS
2                           
2        0000025c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000260 00000020          .field  STD_TARGWORDMAUS * 8
2        00000264 00000004-         .field RTA_fromHost$pipe$rd
2        00000268 00000000          .field  0                       ; reader take-probe
2        0000026c 00000000          .field  0                       ; reader addr
2        00000270 00000004          .field  04H             ; reader size
2        00000274 00000018-         .field  RTA_fromHost$pipe$dtab             ; reader curdesc
2        00000278 00000054-         .field  RTA_fromHost$pipe$wr+PIP_O_FXNOBJ  ; reader pfxnobj
2        0000027c 00000000          .field  0                       ; reader numframes
2        00000280 00000000          .field  0                       ; reader give-probe
2        00000284 00000048-         .field  RTA_fromHost$pipe$wr+PIP_O_NUMFRAMES       ; reader pnumframes
2                           
2        00000288                   FXN_Obj RTA_fromHost$pipe$rdfxn, RTA_F_or, LNK_dspFrameRequestMask, 1<<0, ".pip"
3        00000288               CHK_nargs "FXN_Obj", section
3                               .if ($symcmp("", "error") = 0)
3                                   .emsg "FXN_Obj parameter error"
3                               .endif
3                           
3                           RTA_fromHost$pipe$rdfxn  .tag    FXN_Obj
3                           
3        00000024           RTA_fromHost$pipe$rdfxn .usect ".pip", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
3                           
3        00000288                   .sect ".cinit"
3                           
3                                   .align 8
3        00000288 0000000C          .field  STD_TARGWORDMAUS * 3
3        0000028c 00000024-         .field RTA_fromHost$pipe$rdfxn
3        00000290 00000000!         .field  RTA_F_or          ; fxn
3        00000294 00000001          .field  1<<0         ; arg1
3        00000298 00000000!         .field  LNK_dspFrameRequestMask         ; arg0
3                           
2                           
2        00000030           RTA_fromHost$pipe$aaa .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000029c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        000002a0 00000004          .field  STD_TARGWORDMAUS * 1
2        000002a4 00000030-         .field RTA_fromHost$pipe$aaa
2                                   .if ($symcmp("none", "reader") = 0)
2                                       .field :name:$sts
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   64

2                                   .else
2        000002a8 00000000              .field 0
2                                   .endif
2                           
2        00000034           RTA_fromHost$pipe$wr .usect ".pip", STD_TARGWORDMAUS * 8, STD_TARGWORDMAUS
2                           
2        000002ac                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        000002b0 00000020          .field  STD_TARGWORDMAUS * 8
2        000002b4 00000034-         .field RTA_fromHost$pipe$wr
2        000002b8 00000000          .field  0                       ; writer take-probe
2        000002bc 00000000          .field  0                       ; writer addr
2        000002c0 00000004          .field  04H             ; writer size
2        000002c4 00000018-         .field  RTA_fromHost$pipe$dtab             ; writer curdesc
2        000002c8 00000024-         .field  RTA_fromHost$pipe$rd+PIP_O_FXNOBJ  ; writer pfxnobj
2        000002cc 00000001          .field  01H             ; writer numframes
2        000002d0 00000000          .field  0                       ; writer give-probe
2        000002d4 00000018-         .field  RTA_fromHost$pipe$rd+PIP_O_NUMFRAMES       ; writer pnumframes
2                           
2        000002d8                   FXN_Obj RTA_fromHost$pipe$wrfxn, _FXN_F_nop, 00H, 00H, ".pip"
3        000002d8               CHK_nargs "FXN_Obj", section
3                               .if ($symcmp("", "error") = 0)
3                                   .emsg "FXN_Obj parameter error"
3                               .endif
3                           
3                           RTA_fromHost$pipe$wrfxn  .tag    FXN_Obj
3                           
3        00000054           RTA_fromHost$pipe$wrfxn .usect ".pip", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
3                           
3        000002d8                   .sect ".cinit"
3                           
3                                   .align 8
3        000002d8 0000000C          .field  STD_TARGWORDMAUS * 3
3        000002dc 00000054-         .field RTA_fromHost$pipe$wrfxn
3        000002e0 00000000!         .field  _FXN_F_nop          ; fxn
3        000002e4 00000000          .field  00H         ; arg1
3        000002e8 00000000          .field  00H         ; arg0
3                           
2                           
2        00000060           RTA_fromHost$pipe$bbb .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        000002ec                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        000002f0 00000004          .field  STD_TARGWORDMAUS * 1
2        000002f4 00000060-         .field RTA_fromHost$pipe$bbb
2                                   .if ($symcmp("none", "writer") = 0)
2                                       .field      :name:$sts
2                                   .else
2        000002f8 00000000              .field      0
2                                   .endif
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   65

2                                   ;
2                                   ; put PIP descriptors into .bss section
2                                   ;
2                                   ;   addr[i]
2                                   ;   size[i]
2                                   ;   next[i]
2                                   ;
2                                   .global RTA_fromHost$pipe$dtab
2                           
2        00000018                   .bss RTA_fromHost$pipe$dtab, (3 * STD_TARGWORDMAUS * 01H), STD_TARGWORDMAUS
2                           
2        000002fc                   .sect ".cinit"
2                           
2                                   .var    temp0, temp1, boff
2                                   .eval   0, temp0
2                                   .eval   0, temp1
2                                   .eval   0, boff
2                                   .eval   01H * (3 * STD_TARGWORDMAUS), temp0
2                           
2                                   .align 8
2                           
2        00000300 0000000C          .field  12
2                           
2        00000304 00000018-         .field RTA_fromHost$pipe$dtab
2                           
2                                   .eval   3 * STD_TARGWORDMAUS, temp1
2                           
2                                   .eval   0, count
2                                   .loop   01H-1
2                                       .field :buf:+:boff:                 ; addr[i]
2                                       .field :framesize:                  ; size[i]
2                                       .field :name:$dtab + :temp1:        ; next[i]
2                           
2                                       .if :bufAlloc:
2                                           .eval count + 1, count
2                                           .asg  buf:count:, buf
2                                       .else
2                                           .eval :boff:+(:framesize: * (STD_TARGWORDMAUS)), boff
2                                       .endif
2                                       .eval :temp1: + (3 * STD_TARGWORDMAUS), temp1
2                                   .endloop
2                                       
2        00000308 00000000-         .field RTA_fromHost$buf+0       ; addr[n]
2        0000030c 00000004          .field 04H      ; size[n]
2        00000310 00000018-         .field RTA_fromHost$pipe$dtab   ; next[n]
2                           
2                                   .if ($symcmp("none", "reader") = 0)
2                                           STS_Obj 1, :name:$sts, 0, 0, 0
2                                   .endif
2                           
2                                   .if ($symcmp("none", "writer") = 0)
2                                           STS_Obj 1, :name:$sts, 0, 0, 0
2                                   .endif
2                           
1                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   66

1                           
1                                   .eval 0 + 1, HST$hstCount
1                           
     591                    
     592                    ;; ======== HST_Obj RTA_toHost ========
     593                    ;; Used to access LOG and STS data
     594                    ;;
     595                    ;; HST_Obj RTA_toHost (mode, buf, framesize, numframes, stsflg, notify, arg0, arg1, lnk, bufFrameAlign
     596                            .global RTA_toHost
     597                            .asg "output", _mode
     598                            .asg "<NULL>", _buf
     599                            .asg 040H, _framesize
     600                            .asg 01H, _numframes
     601                            .asg 00H, _stsflg
     602                            .asg _FXN_F_nop, _notify
     603                            .asg 00H, _arg0
     604                            .asg 00H, _arg1
     605                            .asg "RTDX", _lnk
     606                            .asg 04H, _bufFrameAlign
     607 00000314                   HST_Obj 1, RTA_toHost, 0, _mode, _buf, _framesize, _numframes, _stsflg, _notify, _arg0, _arg1,
1                           
1                                   .if (1 = 0)
1                                       .mexit
1                                   .endif
1                            
1        00000314                   CHK_nargs "HST_Obj", lnktype 
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "HST_Obj lnktype error"
1                                   .endif
1                            
1        00000314                   CHK_domain HST_Obj, mode, "output,input", "output"
2                           
1                                   .asg "output", mode
1                                   .if ($symcmp("output", "error") = 0)
1                                       .emsg "HST_Obj mode error"
1                                   .endif
1                            
1                                   .global RTA_toHost, RTA_toHost$buf, RTA_toHost$rtdx
1                            
1                                   .if ($symcmp("<NULL>", "<NULL>") = 0)
1        00000314                       GBL_Obj RTA_toHost$buf, 040H*01H, .hst0
2        00000314                   CHK_domain "GBL_Obj", alignFlag, "noalign,align", "noalign"
3                                       .mexit
3                                           
3                           
3                           
2                                   .if ($symcmp("noalign", "error") = 0)
2                                       .emsg "GBL_Obj align parameter error."
2                                   .endif
2                                   .asg "noalign", alignFlag
2                           
2        00000314                   CHK_nargs "GBL_Obj", size
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "GBL_Obj size parameter error."
2                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   67

2                           
2                                   .if ($symlen(section) = 0)
2                                       .asg ".bss", section
2                                   .endif
2                           
2                                   .if ($symlen(fillValue) != 0)
2                                       .sect ".gblinit"
2                                       .word :size:
2                                       .word :name:
2                                       .word :fillValue:
2                                   .endif
2                           
2                                   .if (($symcmp(section, ".data") = 0) | ($symcmp(alignFlag, "align") = 0))
2                                       .sect ":section:"
2                                       .if ($symcmp(alignFlag, "align") = 0)
2                                           .align  :alignValue:
2                                       .endif
2                           :name::
2                                       ;
2                                       ; Can't use .space directive here because it reserves
2                                       ; bits for some processors and bytes for others.
2                                       ;
2                                       .loop       :size:
2                                           .word 0
2                                       .endloop
2                           
2                                   .elseif ($symcmp(".hst0", ".bss") = 0)
2                                       .bss :name:, :size: * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS / STD_TARGC
2                                   .else
2        00000000           RTA_toHost$buf:     .usect ".hst0", 040H*01H * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAU
2                                   .endif
2                           
1                                       .asg    RTA_toHost$buf, buf
1                                   .endif
1                           
1                                   .if (00H == 0)
1                                       .asg "none",stsType
1                                   .else
1                                       .if ($symcmp(":mode:","input") == 0)
1                                           .asg "reader",stsType
1                                       .else
1                                           .asg "writer",stsType
1                                       .endif
1                                   .endif
1                            
1                                   ; set first word of HST_Obj table to size of individual HST objects
1                           
1                                   .asg    1, chanId
1                           
1                                   .if 1 = 0
1                           
1                           :name:$objsize  .usect ".hst", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS 
1                           
1                                       .sect ".cinit"
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   68

1                                       .align 8
1                           
1                                       .field STD_TARGWORDMAUS * 1
1                           
1                                       .field :name:$objsize   
1                           
1                                       .if ($symcmp(":lnktype:","RTDX") == 0)
1                                           .field 5 * STD_TARGWORDMAUS
1                                       .else
1                                           .field 2 * STD_TARGWORDMAUS
1                                       .endif
1                           
1                                   .endif
1                           
1        00000018           RTA_toHost      .usect ".hst", STD_TARGWORDMAUS * 2, STD_TARGWORDMAUS 
1                            
1        00000314                   .sect ".cinit"
1                           
1                                   .align  8
1        00000318 00000008          .field  STD_TARGWORDMAUS * 2
1        0000031c 00000018-         .field  RTA_toHost    
1        00000320 00000002          .field  1<<1    ; mask 
1        00000324 00000064-         .field  RTA_toHost$pipe         ; pipe
1                           
1                                   .if ($symcmp("RTDX","RTDX") == 0)
1                           
1                                       ; allocate RTDX_channel
1        00000020           RTA_toHost$rtdx .usect ".hst", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS 
1                           
1        00000328                       .sect ".cinit"
1                           
1                                       .align 8
1                           
1        00000328 0000000C              .field STD_TARGWORDMAUS * 3
1        0000032c 00000020-             .field RTA_toHost$rtdx    
1        00000330 00000000              .field 0                    ; enabled = 0
1        00000334 00000000              .field 0                    ; count = 0
1        00000338 00000000              .field 0                    ; busy = 0
1                           
1                                   .endif
1                           
1                                   .if ($symcmp("output","output") == 0)
1        0000033c                           PIP_Obj 1, RTA_toHost$pipe, -1, RTA_toHost$buf, framesize, numframes, none, fxn, arg0,
2                           
2                                   .global RTA_toHost$pipe, RTA_toHost$pipe$rd, RTA_toHost$pipe$wr, RTA_toHost$pipe$dtab
2                                   .global RTA_toHost$pipe$aaa, RTA_toHost$pipe$bbb
2                                   .asg   0,bufAlloc
2                                   .eval 0, newframesize
2                           
2                                   .eval 040H * (STD_TARGWORDMAUS/STD_TARGCHARMAUS), newframesize
2                                   ; Convert framesize to bytes which is needed since align value is
2                                   ; already in bytes.
2                           
2                                   .eval (256 + (04H - 1)) & ( ~(04H - 1)), newframesize
2                                   ; 256 is equal to multiple of 04H. This is needed
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   69

2                                   ; for all the frames to start at 'align'ed boundary from the start
2                                   ; of pip frames section. Note that pip frames section will also
2                                   ; start from 'align'ed boundary.
2                           
2                                   .if (1 = 0)
2                                       .mexit
2                                   .endif
2                           
2                                   .if ($symcmp("RTA_toHost$buf", "<NULL>") = 0)
2                                       .eval       0, count
2                                       .asg        :name:$buf:count:, buf
2                                       .loop
2                                           .break (count == :numframes: - 1 )
2                                           .global :name:$buf:count:
2                           :name:$buf:count:       .usect ".pip:id:", :newframesize: 
2                                           .asg    :name:$buf:count:, buf:count:
2                                           .eval   count + 1, count
2                                       .endloop
2                                   
2                                       ; Last frame in the PIP buffers should start at align boundary
2                                       ; but the size of last PIP buffer need not be multiple of
2                                       ; :align:. Because there are no more frames left to start at align
2                                       ; boundary. Hence last frame is usect'd with the default
2                                       ; framesize.
2                                       .global     :name:$buf:count:
2                           :name:$buf:count:       .usect ".pip:id:", :framesize: * (STD_TARGWORDMAUS/STD_TARGCHARMAUS) 
2                                       .asg        :name:$buf:count:, buf:count:
2                           
2                                       .eval       1, bufAlloc
2                                   .endif
2                           
2        00000064           RTA_toHost$pipe .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000033c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000340 00000004          .field  STD_TARGWORDMAUS * 1
2        00000344 00000064-         .field  RTA_toHost$pipe
2        00000348 00000040          .field  040H             ; thresh
2                           
2        00000068           RTA_toHost$pipe$rd .usect ".pip", STD_TARGWORDMAUS * 8, STD_TARGWORDMAUS
2                           
2        0000034c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000350 00000020          .field  STD_TARGWORDMAUS * 8
2        00000354 00000068-         .field RTA_toHost$pipe$rd
2        00000358 00000000          .field  0                       ; reader take-probe
2        0000035c 00000000          .field  0                       ; reader addr
2        00000360 00000040          .field  040H             ; reader size
2        00000364 00000024-         .field  RTA_toHost$pipe$dtab             ; reader curdesc
2        00000368 000000B8-         .field  RTA_toHost$pipe$wr+PIP_O_FXNOBJ  ; reader pfxnobj
2        0000036c 00000000          .field  0                       ; reader numframes
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   70

2        00000370 00000000          .field  0                       ; reader give-probe
2        00000374 000000AC-         .field  RTA_toHost$pipe$wr+PIP_O_NUMFRAMES       ; reader pnumframes
2                           
2        00000378                   FXN_Obj RTA_toHost$pipe$rdfxn, _FXN_F_nop, 00H, 00H, ".pip"
3        00000378               CHK_nargs "FXN_Obj", section
3                               .if ($symcmp("", "error") = 0)
3                                   .emsg "FXN_Obj parameter error"
3                               .endif
3                           
3                           RTA_toHost$pipe$rdfxn  .tag    FXN_Obj
3                           
3        00000088           RTA_toHost$pipe$rdfxn   .usect ".pip", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
3                           
3        00000378                   .sect ".cinit"
3                           
3                                   .align 8
3        00000378 0000000C          .field  STD_TARGWORDMAUS * 3
3        0000037c 00000088-         .field RTA_toHost$pipe$rdfxn
3        00000380 00000000!         .field  _FXN_F_nop          ; fxn
3        00000384 00000000          .field  00H         ; arg1
3        00000388 00000000          .field  00H         ; arg0
3                           
2                           
2        00000094           RTA_toHost$pipe$aaa .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000038c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        00000390 00000004          .field  STD_TARGWORDMAUS * 1
2        00000394 00000094-         .field RTA_toHost$pipe$aaa
2                                   .if ($symcmp("none", "reader") = 0)
2                                       .field :name:$sts
2                                   .else
2        00000398 00000000              .field 0
2                                   .endif
2                           
2        00000098           RTA_toHost$pipe$wr .usect ".pip", STD_TARGWORDMAUS * 8, STD_TARGWORDMAUS
2                           
2        0000039c                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        000003a0 00000020          .field  STD_TARGWORDMAUS * 8
2        000003a4 00000098-         .field RTA_toHost$pipe$wr
2        000003a8 00000000          .field  0                       ; writer take-probe
2        000003ac 00000000          .field  0                       ; writer addr
2        000003b0 00000040          .field  040H             ; writer size
2        000003b4 00000024-         .field  RTA_toHost$pipe$dtab             ; writer curdesc
2        000003b8 00000088-         .field  RTA_toHost$pipe$rd+PIP_O_FXNOBJ  ; writer pfxnobj
2        000003bc 00000001          .field  01H             ; writer numframes
2        000003c0 00000000          .field  0                       ; writer give-probe
2        000003c4 0000007C-         .field  RTA_toHost$pipe$rd+PIP_O_NUMFRAMES       ; writer pnumframes
2                           
2        000003c8                   FXN_Obj RTA_toHost$pipe$wrfxn, RTA_F_or, LNK_dspFrameReadyMask, 1<<1, ".pip"
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   71

3        000003c8               CHK_nargs "FXN_Obj", section
3                               .if ($symcmp("", "error") = 0)
3                                   .emsg "FXN_Obj parameter error"
3                               .endif
3                           
3                           RTA_toHost$pipe$wrfxn  .tag    FXN_Obj
3                           
3        000000b8           RTA_toHost$pipe$wrfxn   .usect ".pip", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
3                           
3        000003c8                   .sect ".cinit"
3                           
3                                   .align 8
3        000003c8 0000000C          .field  STD_TARGWORDMAUS * 3
3        000003cc 000000B8-         .field RTA_toHost$pipe$wrfxn
3        000003d0 00000000!         .field  RTA_F_or          ; fxn
3        000003d4 00000002          .field  1<<1         ; arg1
3        000003d8 00000000!         .field  LNK_dspFrameReadyMask         ; arg0
3                           
2                           
2        000000c4           RTA_toHost$pipe$bbb .usect ".pip", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        000003dc                   .sect ".cinit"
2                           
2                                   .align 8
2                           
2        000003e0 00000004          .field  STD_TARGWORDMAUS * 1
2        000003e4 000000C4-         .field RTA_toHost$pipe$bbb
2                                   .if ($symcmp("none", "writer") = 0)
2                                       .field      :name:$sts
2                                   .else
2        000003e8 00000000              .field      0
2                                   .endif
2                           
2                                   ;
2                                   ; put PIP descriptors into .bss section
2                                   ;
2                                   ;   addr[i]
2                                   ;   size[i]
2                                   ;   next[i]
2                                   ;
2                                   .global RTA_toHost$pipe$dtab
2                           
2        00000024                   .bss RTA_toHost$pipe$dtab, (3 * STD_TARGWORDMAUS * 01H), STD_TARGWORDMAUS
2                           
2        000003ec                   .sect ".cinit"
2                           
2                                   .var    temp0, temp1, boff
2                                   .eval   0, temp0
2                                   .eval   0, temp1
2                                   .eval   0, boff
2                                   .eval   01H * (3 * STD_TARGWORDMAUS), temp0
2                           
2                                   .align 8
2                           
2        000003f0 0000000C          .field  12
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   72

2                           
2        000003f4 00000024-         .field RTA_toHost$pipe$dtab
2                           
2                                   .eval   3 * STD_TARGWORDMAUS, temp1
2                           
2                                   .eval   0, count
2                                   .loop   01H-1
2                                       .field :buf:+:boff:                 ; addr[i]
2                                       .field :framesize:                  ; size[i]
2                                       .field :name:$dtab + :temp1:        ; next[i]
2                           
2                                       .if :bufAlloc:
2                                           .eval count + 1, count
2                                           .asg  buf:count:, buf
2                                       .else
2                                           .eval :boff:+(:framesize: * (STD_TARGWORDMAUS)), boff
2                                       .endif
2                                       .eval :temp1: + (3 * STD_TARGWORDMAUS), temp1
2                                   .endloop
2                                       
2        000003f8 00000000-         .field RTA_toHost$buf+0 ; addr[n]
2        000003fc 00000040          .field 040H     ; size[n]
2        00000400 00000024-         .field RTA_toHost$pipe$dtab     ; next[n]
2                           
2                                   .if ($symcmp("none", "reader") = 0)
2                                           STS_Obj 1, :name:$sts, 0, 0, 0
2                                   .endif
2                           
2                                   .if ($symcmp("none", "writer") = 0)
2                                           STS_Obj 1, :name:$sts, 0, 0, 0
2                                   .endif
2                           
1                                   .endif
1                            
1                                   .if ($symcmp("output","input") == 0)
1                                           PIP_Obj 1, :name:$pipe, -1, :name:$buf, framesize, numframes, :stsType:, RTA_F_or, LNK
1                                   .endif
1                           
1                                   .eval 1 + 1, HST$hstCount
1                           
     608                    
     609                    ;; ======== HWI_Obj HWI_RESET ========
     610                    ;; defines function for the RESET ISR
     611                    ;;
     612                    ;; HWI_Obj HWI_RESET (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     613                            .global HWI_RESET
     614                            .asg _c_int00, _function
     615                            .asg "Nothing", _monitor
     616                            .asg 00H, _addr
     617                            .asg "signed", _dataType
     618                            .asg "STS_add(*addr)", _operation
     619                            .asg "USER", _client
     620                            .asg 00H, _iUseDispatcher
     621                            .asg 00H, _iArg
     622                            .asg 01H, _IntrMask
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   73

     623                            .asg 01H, _iCCBitMask
     624 00000404                   HWI_Obj 1, HWI_RESET, 0, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDisp
1        00000404                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_RESET, _c_int00
1                           
1                                   .if (1 != 0)
1                 00000000  HWI_RESET               .set    0
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi0, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (0 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    _c_int00, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("_c_int00", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (0 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg _c_int00, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   74

1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000000                   .sect ".hwi_vec"
1                                   .global hwi0
1                           hwi0:
1                                   .if ((0 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1        00000000 0000002A!             mvkl _c_int00,b0    ; load destination function address to b0
1        00000004 0000006A!             mvkh _c_int00,b0
1        00000008 00000362              b b0                ; start branch to destination function  
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   75

1        0000000c 0000A35A              zero b0             ; disable interrupts by clearing 'IER'
1        00000010 020003A2              mvc b0,ier
1        00000014 00000000              nop                 ; fill delay slot, pad packet
1        00000018 00000000              nop                 ; fill delay slot, pad packet
1        0000001c 00000000              nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (0 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   76

1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   77

1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     625                    
     626                    ;; ======== HWI_Obj HWI_NMI ========
     627                    ;; defines function for the NMI ISR
     628                    ;;
     629                    ;; HWI_Obj HWI_NMI (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrMa
     630                            .global HWI_NMI
     631                            .asg HWI_unused, _function
     632                            .asg "Nothing", _monitor
     633                            .asg 00H, _addr
     634                            .asg "signed", _dataType
     635                            .asg "STS_add(*addr)", _operation
     636                            .asg "USER", _client
     637                            .asg 00H, _iUseDispatcher
     638                            .asg 00H, _iArg
     639                            .asg 02H, _IntrMask
     640                            .asg 01H, _iCCBitMask
     641 00000020                   HWI_Obj 1, HWI_NMI, 1, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispat
1        00000020                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_NMI, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000001  HWI_NMI         .set    1
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi1, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   78

1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (1 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   79

1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000020                   .sect ".hwi_vec"
1                                   .global hwi1
1                           hwi1:
1                                   .if ((1 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (1 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   80

1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000020           spin?
1        00000020 00000012              b spin?             ; nested branches to block interrupts
1        00000024 00006000              nop 4
1        00000028 00000012              b spin?
1        0000002c 00000000              nop
1        00000030 00000000              nop
1        00000034 00000000              nop
1        00000038 00000000              nop
1        0000003c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   81

1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     642                    
     643                    ;; ======== HWI_Obj HWI_RESERVED0 ========
     644                    ;; RESERVED for RTDX
     645                    ;;
     646                    ;; HWI_Obj HWI_RESERVED0 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, 
     647                            .global HWI_RESERVED0
     648                            .asg RESERVED, _function
     649                            .asg "Nothing", _monitor
     650                            .asg 00H, _addr
     651                            .asg "signed", _dataType
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   82

     652                            .asg "STS_add(*addr)", _operation
     653                            .asg "RTDX", _client
     654                            .asg 00H, _iUseDispatcher
     655                            .asg 00H, _iArg
     656                            .asg 04H, _IntrMask
     657                            .asg 01H, _iCCBitMask
     658 00000040                   HWI_Obj 1, HWI_RESERVED0, 2, _function, _monitor, _addr, _dataType, _operation, _client, _iUse
1        00000040                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_RESERVED0, RESERVED
1                           
1                                   .if (1 != 0)
1                 00000002  HWI_RESERVED0           .set    2
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi2, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (RTDX$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (2 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    RESERVED, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("RESERVED", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (1 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   83

1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg RESERVED, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000040                   .sect ".hwi_vec"
1                                   .global hwi2
1                           hwi2:
1                                   .if ((2 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   84

1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (2 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1        00000040           spin?
1        00000040 00000012                  b spin?         ; nested branches to block interrupts
1        00000044 00006000                  nop 4
1        00000048 00000012                  b spin?
1        0000004c 00000000                  nop
1        00000050 00000000                  nop
1        00000054 00000000                  nop
1        00000058 00000000                  nop
1        0000005c 00000000                  nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   85

1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   86

1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     659                    
     660                    ;; ======== HWI_Obj HWI_RESERVED1 ========
     661                    ;; RESERVED for RTDX
     662                    ;;
     663                    ;; HWI_Obj HWI_RESERVED1 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, 
     664                            .global HWI_RESERVED1
     665                            .asg _RTDX_Poll, _function
     666                            .asg "Nothing", _monitor
     667                            .asg 00H, _addr
     668                            .asg "signed", _dataType
     669                            .asg "STS_add(*addr)", _operation
     670                            .asg "RTDX", _client
     671                            .asg 01H, _iUseDispatcher
     672                            .asg 00H, _iArg
     673                            .asg 08H, _IntrMask
     674                            .asg 01H, _iCCBitMask
     675 00000060                   HWI_Obj 1, HWI_RESERVED1, 3, _function, _monitor, _addr, _dataType, _operation, _client, _iUse
1        00000060                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_RESERVED1, _RTDX_Poll
1                           
1                                   .if (1 != 0)
1                 00000003  HWI_RESERVED1           .set    3
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi3, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   87

1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (RTDX$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (3 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    01H, local_dispatch
1                                   .asg    _RTDX_Poll, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("_RTDX_Poll", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (1 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg _RTDX_Poll, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   88

1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000060                   .sect ".hwi_vec"
1                                   .global hwi3
1                           hwi3:
1                                   .if ((3 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (3 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   89

1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!01H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
1                                   .else
1                                       .if ( 01H )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp("_RTDX_Poll", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   90

1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        _RTDX_Poll, dispatch_fxn
1                           
1                                           .endif
1                                           
1        00000060 003C54F6                  stw     b0, *b15--[2]
1        00000064 000CA35A                  mvk     3, b0
1        00000068 003C22F6                  stw     b0, *+b15[1]
1        0000006c 0000002A!                 mvkl    HWI_F_dispatch, b0
1        00000070 0000006A!                 mvkh    HWI_F_dispatch, b0
1        00000074 00000362                  b       b0
1        00000078 003C42E6                  ldw     *+b15[2], b0
1        0000007c 00006000                  nop     4
1                           
1        00000404                           .sect   ".cinit"
1                                           .align  8
1        00000408 00000010                  .field  4 * STD_TARGWORDMAUS
1        0000040c 00000030!                 .field  _HWI_dispatchTab + (4 * 3 * STD_TARGWORDMAUS)
1        00000410 00000000!                 .field  _RTDX_Poll
1        00000414 00000008                  .field  08H
1        00000418 00000001                  .field  01H
1        0000041c 00000000                  .field  00H
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     676                    
     677                    ;; ======== HWI_Obj HWI_INT4 ========
     678                    ;; defines the INT4 Interrupt
     679                    ;;
     680                    ;; HWI_Obj HWI_INT4 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   91

     681                            .global HWI_INT4
     682                            .asg HWI_unused, _function
     683                            .asg "Nothing", _monitor
     684                            .asg 00H, _addr
     685                            .asg "signed", _dataType
     686                            .asg "STS_add(*addr)", _operation
     687                            .asg "USER", _client
     688                            .asg 00H, _iUseDispatcher
     689                            .asg 00H, _iArg
     690                            .asg 010H, _IntrMask
     691                            .asg 01H, _iCCBitMask
     692 00000420                   HWI_Obj 1, HWI_INT4, 4, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        00000420                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT4, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000004  HWI_INT4                .set    4
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi4, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (4 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   92

1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000080                   .sect ".hwi_vec"
1                                   .global hwi4
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   93

1                           hwi4:
1                                   .if ((4 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (4 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000080           spin?
1        00000080 00000012              b spin?             ; nested branches to block interrupts
1        00000084 00006000              nop 4
1        00000088 00000012              b spin?
1        0000008c 00000000              nop
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   94

1        00000090 00000000              nop
1        00000094 00000000              nop
1        00000098 00000000              nop
1        0000009c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   95

1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     693                    
     694                    ;; ======== HWI_Obj HWI_INT5 ========
     695                    ;; defines the INT5 Interrupt
     696                    ;;
     697                    ;; HWI_Obj HWI_INT5 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     698                            .global HWI_INT5
     699                            .asg HWI_unused, _function
     700                            .asg "Nothing", _monitor
     701                            .asg 00H, _addr
     702                            .asg "signed", _dataType
     703                            .asg "STS_add(*addr)", _operation
     704                            .asg "USER", _client
     705                            .asg 00H, _iUseDispatcher
     706                            .asg 00H, _iArg
     707                            .asg 020H, _IntrMask
     708                            .asg 01H, _iCCBitMask
     709 000000a0                   HWI_Obj 1, HWI_INT5, 5, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        000000a0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT5, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000005  HWI_INT5                .set    5
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   96

1                                   .asg hwi5, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (5 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   97

1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000000a0                   .sect ".hwi_vec"
1                                   .global hwi5
1                           hwi5:
1                                   .if ((5 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (5 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   98

1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000000a0           spin?
1        000000a0 00000012              b spin?             ; nested branches to block interrupts
1        000000a4 00006000              nop 4
1        000000a8 00000012              b spin?
1        000000ac 00000000              nop
1        000000b0 00000000              nop
1        000000b4 00000000              nop
1        000000b8 00000000              nop
1        000000bc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE   99

1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  100

     710                    
     711                    ;; ======== HWI_Obj HWI_INT6 ========
     712                    ;; defines the INT6 Interrupt
     713                    ;;
     714                    ;; HWI_Obj HWI_INT6 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     715                            .global HWI_INT6
     716                            .asg HWI_unused, _function
     717                            .asg "Nothing", _monitor
     718                            .asg 00H, _addr
     719                            .asg "signed", _dataType
     720                            .asg "STS_add(*addr)", _operation
     721                            .asg "USER", _client
     722                            .asg 00H, _iUseDispatcher
     723                            .asg 00H, _iArg
     724                            .asg 040H, _IntrMask
     725                            .asg 01H, _iCCBitMask
     726 000000c0                   HWI_Obj 1, HWI_INT6, 6, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        000000c0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT6, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000006  HWI_INT6                .set    6
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi6, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (6 > 15)
1                                       .mexit
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  101

1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  102

1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000000c0                   .sect ".hwi_vec"
1                                   .global hwi6
1                           hwi6:
1                                   .if ((6 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (6 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  103

1        000000c0           spin?
1        000000c0 00000012              b spin?             ; nested branches to block interrupts
1        000000c4 00006000              nop 4
1        000000c8 00000012              b spin?
1        000000cc 00000000              nop
1        000000d0 00000000              nop
1        000000d4 00000000              nop
1        000000d8 00000000              nop
1        000000dc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  104

1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     727                    
     728                    ;; ======== HWI_Obj HWI_INT7 ========
     729                    ;; defines the INT7 Interrupt
     730                    ;;
     731                    ;; HWI_Obj HWI_INT7 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     732                            .global HWI_INT7
     733                            .asg HWI_unused, _function
     734                            .asg "Nothing", _monitor
     735                            .asg 00H, _addr
     736                            .asg "signed", _dataType
     737                            .asg "STS_add(*addr)", _operation
     738                            .asg "USER", _client
     739                            .asg 00H, _iUseDispatcher
     740                            .asg 00H, _iArg
     741                            .asg 080H, _IntrMask
     742                            .asg 01H, _iCCBitMask
     743 000000e0                   HWI_Obj 1, HWI_INT7, 7, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        000000e0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT7, HWI_unused
1                           
1                                   .if (1 != 0)
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  105

1                 00000007  HWI_INT7                .set    7
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi7, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (7 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  106

1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000000e0                   .sect ".hwi_vec"
1                                   .global hwi7
1                           hwi7:
1                                   .if ((7 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (7 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  107

1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000000e0           spin?
1        000000e0 00000012              b spin?             ; nested branches to block interrupts
1        000000e4 00006000              nop 4
1        000000e8 00000012              b spin?
1        000000ec 00000000              nop
1        000000f0 00000000              nop
1        000000f4 00000000              nop
1        000000f8 00000000              nop
1        000000fc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  108

1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  109

1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     744                    
     745                    ;; ======== HWI_Obj HWI_INT8 ========
     746                    ;; defines the INT8 Interrupt
     747                    ;;
     748                    ;; HWI_Obj HWI_INT8 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     749                            .global HWI_INT8
     750                            .asg HWI_unused, _function
     751                            .asg "Nothing", _monitor
     752                            .asg 00H, _addr
     753                            .asg "signed", _dataType
     754                            .asg "STS_add(*addr)", _operation
     755                            .asg "USER", _client
     756                            .asg 00H, _iUseDispatcher
     757                            .asg 00H, _iArg
     758                            .asg 0100H, _IntrMask
     759                            .asg 01H, _iCCBitMask
     760 00000100                   HWI_Obj 1, HWI_INT8, 8, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        00000100                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT8, HWI_unused
1                           
1                                   .if (1 != 0)
1                 00000008  HWI_INT8                .set    8
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi8, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  110

1                                   ; the build error. 
1                                   .if (8 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  111

1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000100                   .sect ".hwi_vec"
1                                   .global hwi8
1                           hwi8:
1                                   .if ((8 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (8 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  112

1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000100           spin?
1        00000100 00000012              b spin?             ; nested branches to block interrupts
1        00000104 00006000              nop 4
1        00000108 00000012              b spin?
1        0000010c 00000000              nop
1        00000110 00000000              nop
1        00000114 00000000              nop
1        00000118 00000000              nop
1        0000011c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  113

1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     761                    
     762                    ;; ======== HWI_Obj HWI_INT9 ========
     763                    ;; defines the INT9 Interrupt
     764                    ;;
     765                    ;; HWI_Obj HWI_INT9 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, IntrM
     766                            .global HWI_INT9
     767                            .asg _RTDX_Poll, _function
     768                            .asg "Nothing", _monitor
     769                            .asg 00H, _addr
     770                            .asg "signed", _dataType
     771                            .asg "STS_add(*addr)", _operation
     772                            .asg "RTDX", _client
     773                            .asg 01H, _iUseDispatcher
     774                            .asg 00H, _iArg
     775                            .asg 0208H, _IntrMask
     776                            .asg 01H, _iCCBitMask
     777 00000120                   HWI_Obj 1, HWI_INT9, 9, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDispa
1        00000120                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  114

1                                   .endif
1                           
1                                   .global HWI_INT9, _RTDX_Poll
1                           
1                                   .if (1 != 0)
1                 00000009  HWI_INT9                .set    9
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi9, vector               ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (RTDX$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (9 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    01H, local_dispatch
1                                   .asg    _RTDX_Poll, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("_RTDX_Poll", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (1 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg _RTDX_Poll, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  115

1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000120                   .sect ".hwi_vec"
1                                   .global hwi9
1                           hwi9:
1                                   .if ((9 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  116

1                           
1                                   .elseif (9 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!01H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
1                                   .else
1                                       .if ( 01H )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp("_RTDX_Poll", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  117

1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        _RTDX_Poll, dispatch_fxn
1                           
1                                           .endif
1                                           
1        00000120 003C54F6                  stw     b0, *b15--[2]
1        00000124 0024A35A                  mvk     9, b0
1        00000128 003C22F6                  stw     b0, *+b15[1]
1        0000012c 0000002A!                 mvkl    HWI_F_dispatch, b0
1        00000130 0000006A!                 mvkh    HWI_F_dispatch, b0
1        00000134 00000362                  b       b0
1        00000138 003C42E6                  ldw     *+b15[2], b0
1        0000013c 00006000                  nop     4
1                           
1        00000420                           .sect   ".cinit"
1                                           .align  8
1        00000420 00000010                  .field  4 * STD_TARGWORDMAUS
1        00000424 00000090!                 .field  _HWI_dispatchTab + (4 * 9 * STD_TARGWORDMAUS)
1        00000428 00000000!                 .field  _RTDX_Poll
1        0000042c 00000208                  .field  0208H
1        00000430 00000001                  .field  01H
1        00000434 00000000                  .field  00H
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  118

1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     778                    
     779                    ;; ======== HWI_Obj HWI_INT10 ========
     780                    ;; defines the INT10 Interrupt
     781                    ;;
     782                    ;; HWI_Obj HWI_INT10 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     783                            .global HWI_INT10
     784                            .asg HWI_unused, _function
     785                            .asg "Nothing", _monitor
     786                            .asg 00H, _addr
     787                            .asg "signed", _dataType
     788                            .asg "STS_add(*addr)", _operation
     789                            .asg "USER", _client
     790                            .asg 00H, _iUseDispatcher
     791                            .asg 00H, _iArg
     792                            .asg 0400H, _IntrMask
     793                            .asg 01H, _iCCBitMask
     794 00000438                   HWI_Obj 1, HWI_INT10, 10, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        00000438                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT10, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000A  HWI_INT10               .set    10
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi10, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  119

1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (10 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  120

1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000140                   .sect ".hwi_vec"
1                                   .global hwi10
1                           hwi10:
1                                   .if ((10 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (10 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  121

1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000140           spin?
1        00000140 00000012              b spin?             ; nested branches to block interrupts
1        00000144 00006000              nop 4
1        00000148 00000012              b spin?
1        0000014c 00000000              nop
1        00000150 00000000              nop
1        00000154 00000000              nop
1        00000158 00000000              nop
1        0000015c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  122

1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     795                    
     796                    ;; ======== HWI_Obj HWI_INT11 ========
     797                    ;; defines the INT11 Interrupt
     798                    ;;
     799                    ;; HWI_Obj HWI_INT11 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     800                            .global HWI_INT11
     801                            .asg HWI_unused, _function
     802                            .asg "Nothing", _monitor
     803                            .asg 00H, _addr
     804                            .asg "signed", _dataType
     805                            .asg "STS_add(*addr)", _operation
     806                            .asg "USER", _client
     807                            .asg 00H, _iUseDispatcher
     808                            .asg 00H, _iArg
     809                            .asg 0800H, _IntrMask
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  123

     810                            .asg 01H, _iCCBitMask
     811 00000160                   HWI_Obj 1, HWI_INT11, 11, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        00000160                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT11, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000B  HWI_INT11               .set    11
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi11, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (11 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  124

1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000160                   .sect ".hwi_vec"
1                                   .global hwi11
1                           hwi11:
1                                   .if ((11 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  125

1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (11 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000160           spin?
1        00000160 00000012              b spin?             ; nested branches to block interrupts
1        00000164 00006000              nop 4
1        00000168 00000012              b spin?
1        0000016c 00000000              nop
1        00000170 00000000              nop
1        00000174 00000000              nop
1        00000178 00000000              nop
1        0000017c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  126

1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  127

1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     812                    
     813                    ;; ======== HWI_Obj HWI_INT12 ========
     814                    ;; defines the INT12 Interrupt
     815                    ;;
     816                    ;; HWI_Obj HWI_INT12 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     817                            .global HWI_INT12
     818                            .asg HWI_unused, _function
     819                            .asg "Nothing", _monitor
     820                            .asg 00H, _addr
     821                            .asg "signed", _dataType
     822                            .asg "STS_add(*addr)", _operation
     823                            .asg "USER", _client
     824                            .asg 00H, _iUseDispatcher
     825                            .asg 00H, _iArg
     826                            .asg 01000H, _IntrMask
     827                            .asg 01H, _iCCBitMask
     828 00000180                   HWI_Obj 1, HWI_INT12, 12, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        00000180                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT12, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000C  HWI_INT12               .set    12
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi12, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  128

1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (12 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  129

1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        00000180                   .sect ".hwi_vec"
1                                   .global hwi12
1                           hwi12:
1                                   .if ((12 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (12 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  130

1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        00000180           spin?
1        00000180 00000012              b spin?             ; nested branches to block interrupts
1        00000184 00006000              nop 4
1        00000188 00000012              b spin?
1        0000018c 00000000              nop
1        00000190 00000000              nop
1        00000194 00000000              nop
1        00000198 00000000              nop
1        0000019c 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  131

1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     829                    
     830                    ;; ======== HWI_Obj HWI_INT13 ========
     831                    ;; defines the INT13 Interrupt
     832                    ;;
     833                    ;; HWI_Obj HWI_INT13 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     834                            .global HWI_INT13
     835                            .asg HWI_unused, _function
     836                            .asg "Nothing", _monitor
     837                            .asg 00H, _addr
     838                            .asg "signed", _dataType
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  132

     839                            .asg "STS_add(*addr)", _operation
     840                            .asg "USER", _client
     841                            .asg 00H, _iUseDispatcher
     842                            .asg 00H, _iArg
     843                            .asg 02000H, _IntrMask
     844                            .asg 01H, _iCCBitMask
     845 000001a0                   HWI_Obj 1, HWI_INT13, 13, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        000001a0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT13, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000D  HWI_INT13               .set    13
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi13, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (13 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  133

1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000001a0                   .sect ".hwi_vec"
1                                   .global hwi13
1                           hwi13:
1                                   .if ((13 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  134

1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (13 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000001a0           spin?
1        000001a0 00000012              b spin?             ; nested branches to block interrupts
1        000001a4 00006000              nop 4
1        000001a8 00000012              b spin?
1        000001ac 00000000              nop
1        000001b0 00000000              nop
1        000001b4 00000000              nop
1        000001b8 00000000              nop
1        000001bc 00000000              nop
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  135

1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  136

1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     846                    
     847                    ;; ======== HWI_Obj HWI_INT14 ========
     848                    ;; defines the INT14 Interrupt
     849                    ;;
     850                    ;; HWI_Obj HWI_INT14 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
     851                            .global HWI_INT14
     852                            .asg CLK_F_isr, _function
     853                            .asg "Nothing", _monitor
     854                            .asg 00H, _addr
     855                            .asg "signed", _dataType
     856                            .asg "STS_add(*addr)", _operation
     857                            .asg "CLK", _client
     858                            .asg 01H, _iUseDispatcher
     859                            .asg CLK_A_TABBEG, _iArg
     860                            .asg 04000H, _IntrMask
     861                            .asg 01H, _iCCBitMask
     862 000001c0                   HWI_Obj 1, HWI_INT14, 14, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        000001c0                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT14, CLK_F_isr
1                           
1                                   .if (1 != 0)
1                 0000000E  HWI_INT14               .set    14
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi14, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  137

1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (CLK$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (14 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    01H, local_dispatch
1                                   .asg    CLK_F_isr, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("CLK_F_isr", "HWI_unused") != 0))
1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (1 = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg CLK_F_isr, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  138

1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000001c0                   .sect ".hwi_vec"
1                                   .global hwi14
1                           hwi14:
1                                   .if ((14 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (14 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  139

1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!01H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1                           spin?
1                                       b spin?             ; nested branches to block interrupts
1                                       nop 4
1                                       b spin?
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                                       nop
1                           
1                                   .else
1                                       .if ( 01H )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp("CLK_F_isr", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  140

1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1        000001c0 003C54F6                  stw     b0, *b15--[2]
1        000001c4 0038A35A                  mvk     14, b0
1        000001c8 003C22F6                  stw     b0, *+b15[1]
1        000001cc 0000002A!                 mvkl    CLK_F_isr, b0
1        000001d0 0000006A!                 mvkh    CLK_F_isr, b0
1        000001d4 00000362                  b       b0
1        000001d8 003C42E6                  ldw     *+b15[2], b0
1        000001dc 00006000                  nop     4
1                           
1        00000438                           .sect   ".cinit"
1                                           .align  8
1        00000438 00000010                  .field  4 * STD_TARGWORDMAUS
1        0000043c 000000E0!                 .field  _HWI_dispatchTab + (4 * 14 * STD_TARGWORDMAUS)
1        00000440 00000000!                 .field  FXN_F_run
1        00000444 00004000                  .field  04000H
1        00000448 00000001                  .field  01H
1        0000044c 00000000!                 .field  CLK_A_TABBEG
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     863                    
     864                    ;; ======== HWI_Obj HWI_INT15 ========
     865                    ;; defines the INT15 Interrupt
     866                    ;;
     867                    ;; HWI_Obj HWI_INT15 (function, monitor, addr, dataType, operation, client, iUseDispatcher, iArg, Intr
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  141

     868                            .global HWI_INT15
     869                            .asg HWI_unused, _function
     870                            .asg "Nothing", _monitor
     871                            .asg 00H, _addr
     872                            .asg "signed", _dataType
     873                            .asg "STS_add(*addr)", _operation
     874                            .asg "USER", _client
     875                            .asg 00H, _iUseDispatcher
     876                            .asg 00H, _iArg
     877                            .asg 08000H, _IntrMask
     878                            .asg 01H, _iCCBitMask
     879 00000450                   HWI_Obj 1, HWI_INT15, 15, _function, _monitor, _addr, _dataType, _operation, _client, _iUseDis
1        00000450                   CHK_nargs "HWI_Obj", client
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global HWI_INT15, HWI_unused
1                           
1                                   .if (1 != 0)
1                 0000000F  HWI_INT15               .set    15
1                                   .endif
1                                   
1                                   .var    vector, clientcfg
1                           
1                                   .asg hwi15, vector              ; default vector = self branch
1                           
1                                   ; set clientcfg to 1 (or 0) according to whether the client module 
1                                   ; is configured (or not).
1                                   .asg 0, clientcfg
1                                   .if ($symcmp(client, "USER") != 0) 
1                                     .if ($symcmp(client, "CSL") == 0)
1                                       .asg 1, clientcfg
1                                     .else
1                                       .if (:client:$ = 1)
1                                           .asg 1, clientcfg
1                                       .endif
1                                     .endif
1                                   .endif
1                           
1                                   ; The following call to .mexit is to avoid generation of HWI objects
1                                   ; for interrupts greater that INT15.  This allows an HWI_UNUSED object
1                                   ; to be listed in the configuration.  This exit code was first put at
1                                   ; the start of the macro but this caused an error saying that USER$
1                                   ; was undefined.  The exit was put at this point in the macro to avoid
1                                   ; the build error. 
1                                   .if (15 > 15)
1                                       .mexit
1                                   .endif
1                           
1                                   .asg    00H, local_dispatch
1                                   .asg    HWI_unused, local_fxn
1                           
1                                   ; if this object is configured *and* is not "HWI_unused"
1                                   .if ((1 != 0) & ($symcmp("HWI_unused", "HWI_unused") != 0))
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  142

1                           
1                                       ; if client is USER or another configured system module
1                                       .if (($symcmp(client, "USER") = 0) | (:clientcfg: = 1))
1                           
1                                           ; if no monitor, simply branch to user function directly
1                                           .if ($symcmp(monitor, "Nothing") = 0)
1                                               .asg :local_fxn:, vector    ; vector = user specified fxn
1                           
1                                           ; else when need to monitor, create a function stub and call it
1                                           .else
1                                               .if ( local_dispatch )
1                                                   .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, CLK_F_isr
1                                                   .else
1                                                       HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, HWI_F_dispat
1                                                   .endif
1                                               .else
1                                                   HWI_mkStub :name:_stub, monitor, addr, operation, :name:_STS, :local_fxn:
1                                               .endif
1                                               .asg :name:_stub, vector ; vector = HWI stub
1                                           .endif
1                                       .endif
1                                   .endif
1                           
1                           
1                                   .if ($isdefed("HWI_GENERATE_RESET_VEC") = 0)
1                                       .asg        0, HWI_GENERATE_RESET_VEC
1                                   .endif
1                           
1                                   .if HWI_GENERATE_RESET_VEC = 1  ; HWI_GENERATE_RESET_VEC is generated
1                                                                   ; by the config tool
1                                       .sect ".hwi_reset"
1                           
1                                       .if ((id == 0))
1                           
1                                           ; For reset vector do not save/restore register used for 
1                                           ; branch, because b15 has not been initialized yet, and this 
1                                           ; causes an access to an indeterminate place in memory.
1                           
1                                           mvkl :vector:,b0    ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0            ; start branch to destination function  
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                           nop             ; fill delay slot, pad packet
1                                       .endif
1                                   .endif
1                           
1                                   ; Now define ISFP.  Use a register for branching so can reach whole 
1                                   ; address space.
1                           
1        000001e0                   .sect ".hwi_vec"
1                                   .global hwi15
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  143

1                           hwi15:
1                                   .if ((15 == 0))
1                           
1                                       ; For reset vector do not save/restore register used for branch,
1                                       ; because b15 has not been initialized yet, and this causes an 
1                                       ; access to an indeterminate place in memory.
1                           
1                                       mvkl :vector:,b0    ; load destination function address to b0
1                                       mvkh :vector:,b0
1                                       b b0                ; start branch to destination function  
1                                       zero b0             ; disable interrupts by clearing 'IER'
1                                       mvc b0,ier
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                                       nop                 ; fill delay slot, pad packet
1                           
1                                   .elseif (15 == 2)
1                                       .if (RTDX_USERTEXECUTION)
1                           
1                                           .ref RTEMU_exe
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack 
1                                           mvkl RTEMU_exe,b0       ; load destination function address
1                                           mvkh RTEMU_exe,b0
1                                           b b0                    ; start branch to destination function  
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 b0 restore/branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                           
1                                       .else
1                           
1                           spin?
1                                           b spin?         ; nested branches to block interrupts
1                                           nop 4
1                                           b spin?
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                                           nop
1                           
1                                       .endif
1                           
1                                   .elseif (($symcmp(local_fxn, "HWI_unused") == 0) & (!00H))
1                           
1                                       ; plug inifinite loop -- with nested branches to
1                                       ; disable interrupts -- for all undefined vectors that
1                                       ; aren't checked to "Use HWI Dispatcher"
1                           
1        000001e0           spin?
1        000001e0 00000012              b spin?             ; nested branches to block interrupts
1        000001e4 00006000              nop 4
1        000001e8 00000012              b spin?
1        000001ec 00000000              nop
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  144

1        000001f0 00000000              nop
1        000001f4 00000000              nop
1        000001f8 00000000              nop
1        000001fc 00000000              nop
1                           
1                                   .else
1                                       .if ( local_dispatch )
1                                           .global _HWI_dispatchTab
1                                           .var    dispatch_fxn
1                                           .var    vec_fxn
1                           
1                                           .if ( $symcmp(":local_fxn:", "CLK_F_isr") = 0 )
1                           
1                                               .global     CLK_F_isr
1                                               .global     FXN_F_run
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    CLK_F_isr, vec_fxn
1                                               .else
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        FXN_F_run, dispatch_fxn
1                           
1                                           .else
1                                               .global     HWI_F_dispatch
1                                               ;
1                                               ; We allow dispatcher to be selected even for HWIs that
1                                               ; are HWI_unused.  Call FXN_F_nop in this case.
1                                               ; The assumption is that the user will subsequently call
1                                               ; IRQ_config to set the function to something real.
1                                               ;
1                                               .if ($symcmp(local_fxn, "HWI_unused") == 0)
1                                                   .asg    FXN_F_nop, local_fxn
1                                               .endif
1                           
1                                               .if ($symcmp(monitor, "Nothing") = 0)
1                                                   .asg    HWI_F_dispatch, vec_fxn
1                                               .else
1                                                   ; HWI_F_dispatch will be called by monitor
1                                                   .asg    :name:_stub, vec_fxn
1                                               .endif
1                                               .asg        :local_fxn:, dispatch_fxn
1                           
1                                           .endif
1                                           
1                                           stw     b0, *b15--[2]
1                                           mvk     :id:, b0
1                                           stw     b0, *+b15[1]
1                                           mvkl    :vec_fxn:, b0
1                                           mvkh    :vec_fxn:, b0
1                                           b       b0
1                                           ldw     *+b15[2], b0
1                                           nop     4
1                           
1                                           .sect   ".cinit"
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  145

1                                           .align  8
1                                           .field  4 * STD_TARGWORDMAUS
1                                           .field  _HWI_dispatchTab + (4 * :id: * STD_TARGWORDMAUS)
1                                           .field  :dispatch_fxn:
1                                           .field  :intrmask:
1                                           .field  :ccmask:
1                                           .field  :arg:
1                           
1                                       .else
1                                           ; For all vectors besides reset use a common packet format. This
1                                           ; packet can be used for self branches as well as branches to
1                                           ; HWI stubs.
1                           
1                                           stw b0,*b15--[2]        ; temp save b0 on stack
1                                           mvkl :vector:,b0        ; load destination function address to b0
1                                           mvkh :vector:,b0
1                                           b b0                    ; start branch to destination function
1                                           ldw *++b15[2],b0        ; restore b0 register
1                                           nop 2                   ; fill 2 of b0 restore and branch delay slots
1                                           nop                     ; fill delay slot, pad packet
1                                           nop                     ; fill delay slot, pad packet
1                                       .endif
1                           
1                                   .endif
1                                   
     880                    
     881                    ;; ======== SWI_Obj KNL_swi ========
     882                    ;; This Software Interrupt calls the TSK scheduler
     883                    ;;
     884                    ;; SWI_Obj KNL_swi (function, pri, mailbox, arg0, arg1, dorta)
     885                            .global KNL_swi
     886                            .asg _KNL_run, _function
     887                            .asg 00H, _pri
     888                            .asg 00H, _mailbox
     889                            .asg 00H, _arg0
     890                            .asg 00H, _arg1
     891                            .asg 01H, _dorta
     892 00000200                   SWI_Obj 1, KNL_swi, 0, _function, _pri, _mailbox, _arg0, _arg1, _dorta
1        00000200                   CHK_nargs "SWI_Obj", fxn
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   ;
1                                   ; pri, mailbox, arg0 and arg1 are optional -- defaults if necessary
1                                   ;
1                                   .if ($symlen("00H") = 0)
1                                       .asg        "0", pri
1                                       .asg        "0", mailbox
1                                       .asg        "0", arg0
1                                       .asg        "0", arg1
1                                   .elseif ($symlen("00H") = 0)
1                                       .asg        "0", mailbox
1                                       .asg        "0", arg0
1                                       .asg        "0", arg1
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  146

1                                   .elseif ($symlen("00H") = 0)
1                                       .asg        "0", arg0
1                                       .asg        "0", arg1
1                                   .elseif ($symlen("00H") = 0)
1                                       .asg        "0", arg1
1                                   .else
1        00000200                       CHK_nargs "SWI_Obj", arg1
1                                       .if ($symcmp("", "error") = 0)
1                                           .mexit
1                                       .endif
1                                   .endif
1                           
1                                   .if (1 = 0)
1                                       .mexit
1                                   .endif
1                           
1                                   .global KNL_swi, _KNL_run
1                           
1                           KNL_swi  .tag    SWI_Obj
1                           
1        00000000           KNL_swi .usect ".swi", STD_TARGWORDMAUS * 6, STD_TARGWORDMAUS
1                           
1        00000450                   .sect ".cinit"
1                           
1                                   .align 8
1                           
1        00000450 00000018          .field  STD_TARGWORDMAUS * 6
1        00000454 00000000-         .field KNL_swi
1        00000458 FFFFFFFF          .field  -1                      ; lock (not posted)
1        0000045c 00000004!         .field  SWI_D_rdytab+(00H*2+1)*STD_TARGWORDMAUS; ready
1        00000460 00000001          .field  1 << 00H              ; mask
1        00000464 00000000          .field  0                       ; link
1        00000468 00000000          .field  00H               ; initkey
1        0000046c 00000000          .field  00H               ; mailbox
1                           
1        00000470                   FXN_Obj KNL_swi$fxn, _KNL_run, 00H, 00H, ".swi"
2        00000470               CHK_nargs "FXN_Obj", section
2                               .if ($symcmp("", "error") = 0)
2                                   .emsg "FXN_Obj parameter error"
2                               .endif
2                           
2                           KNL_swi$fxn  .tag    FXN_Obj
2                           
2        00000018           KNL_swi$fxn     .usect ".swi", STD_TARGWORDMAUS * 3, STD_TARGWORDMAUS
2                           
2        00000470                   .sect ".cinit"
2                           
2                                   .align 8
2        00000470 0000000C          .field  STD_TARGWORDMAUS * 3
2        00000474 00000018-         .field KNL_swi$fxn
2        00000478 00000000!         .field  _KNL_run          ; fxn
2        0000047c 00000000          .field  00H         ; arg1
2        00000480 00000000          .field  00H         ; arg0
2                           
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  147

1        00000024           KNL_swi$aaa .usect ".swi", STD_TARGWORDMAUS * 2, STD_TARGWORDMAUS
1                           
1        00000484                   .sect ".cinit"
1                           
1                                   .align 8
1                           
1        00000488 00000008          .field  STD_TARGWORDMAUS * 2
1        0000048c 00000024-         .field KNL_swi$aaa
1        00000490 FFFFFFFF          .field  -1                      ; stslock
1                                   .if 01H
1        00000494 00000004+             .field  KNL_swi$sts          ; pointer to STS_Obj
1                                   .else
1                                       .field 0
1                                   .endif
1                           
1                                   ; only allocate STS object if 'Do RTA' is TRUE
1                                   .if 01H
1        00000498                       STS_Obj 1, KNL_swi$sts, 0, 0, 0
2                           
2        00000498                   CHK_nargs "STS_Obj", prevl
2                           
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "STS_Obj parameter error."
2                                   .endif
2                           
2                                   .if (1 = 0)                  ; if this object is not
2                                                                      ; really to be allocated
2                                       .mexit                         ; exit quietly now
2                                   .endif
2                           
2                                   .global KNL_swi$sts, KNL_swi$sts$stsobj     
2                           
2        00000000                   .sect ".sts"                       ; allocate STS_Obj 
2                                                                      ; (in section ".sts")
2                           KNL_swi$sts  .tag    STS_Obj                    ; declare name as having 
2                                                                      ; type STS_Obj
2        00000000           KNL_swi$sts$stsobj:
2                                                                     ; NOTE: on 32-bit targets
2                                                                     ; only prevh is used
2        00000000 00000000          .long   0                         ; allocate space for previous
2                                                                     ; 32-bit value
2        00000004           KNL_swi$sts                                   
2        00000004 00000000          .long   0                         ; num
2        00000008 00000000          .long   0                         ; acc
2        0000000c 80000000          .long   80000000h                 ; max
2                           
2        00000498                   .sect    ".cinit"
2                                   .align    8
2        00000498 00000010          .field    STD_TARGWORDMAUS * 4
2        0000049c 00000000+         .field    KNL_swi$sts$stsobj                    
2        000004a0 00000000          .field    0                  ; allocate space for history   
2        000004a4 00000000          .field    0                        ; num
2        000004a8 00000000          .field    0                        ; acc
2        000004ac 80000000          .field    80000000h                ; max
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  148

2        00000010                   .sect    ".sts"
2                           
1                                   .endif
1                           
     893                    
     894                    ;; ======== TSK_Obj TSK_idle ========
     895                    ;; This is the idle task; it only runs when no other task is ready
     896                    ;;
     897                    ;; TSK_Obj TSK_idle (iFXN, iARG0, iARG1, iARG2, iARG3, iARG4, iARG5, iARG6, iARG7, iAUTOSTK, iMANSTK, 
     898                            .global TSK_idle
     899                            .asg IDL_F_loop, _iFXN
     900                            .asg 00H, _iARG0
     901                            .asg 00H, _iARG1
     902                            .asg 00H, _iARG2
     903                            .asg 00H, _iARG3
     904                            .asg 00H, _iARG4
     905                            .asg 00H, _iARG5
     906                            .asg 00H, _iARG6
     907                            .asg 00H, _iARG7
     908                            .asg 01H, _iAUTOSTK
     909                            .asg null, _iMANSTK
     910                            .asg 0400H, _iSTKSZ
     911                            .asg SDRAM, _iSTKSEG
     912                            .asg 00H, _iPRI
     913                            .asg 00H, _iENV
     914                            .asg 01H, _iEXITFLAG
     915                            .asg 00H, _iUSETSKNAME
     916                            .asg 00H, _iSTATREG
     917 00000010                   TSK_Obj 1, TSK_idle, 0, _iFXN, _iARG0, _iARG1, _iARG2, _iARG3, _iARG4, _iARG5, _iARG6, _iARG7,
1                           
1                                   .global IDL_F_loop
1                                   .global TSK_idle
1                           
1                                   .if 00H
1                                           .sect   ".const"
1                           TSK$:TSK_idle:  .string ":name:",0      ; null-terminated name string
1                                   .endif
1                           
1        00000000           TSK_idle$obj    .usect  ".tsk", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        0000000c           TSK_idle                .usect  ".tsk", 21 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .if     0 > 0
1                           :name:$env      .usect  ".tsk", TSK$num_hooks * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .endif
1                           
1                 00000400  TSK_idle$stklen .set    0400H
1                           
1                                   .if     01H
1                                       ;
1                                       ; Reserve space for automatically allocated stack
1                                       ;
1        00000000           TSK_idle$stack  .usect ".TSK_idle$stk", 0400H, STD_TARGALIGN
1                                           .global TSK_idle$stack, TSK_idle$stackname
1                                           .asg    "TSK_idle$stack", TSK_idle$stackname
1                                   .else
1                                       .if ($symcmp(":manstack:", "null") == 0)
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  149

1                                           .emsg "TSK :name: manually allocated stack cannot be null"
1                                       .else
1                                           .asg    ":manstack:", :name:$stackname
1                                       .endif
1                                   .endif
1                           
1                                   ;
1                                   ; stkptr for the idle stack is used by the IDL_F_stub function
1                                   ;
1                                   .global TSK_idle$stkptr
1                           
1                                   .if 01H
1                 00000398- TSK_idle$stkptr .set TSK_idle$stack + 0400H - STD_TARGALIGN - (24 * STD_TARGWORDMAUS)
1                                   .else
1                                           .asg "(:name:$stackname + :stacksize: - STD_TARGALIGN - (TSK_USEDSTACK * STD_TARGWORDM
1                                   .endif
1                           
1        000004b0                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        000004b0 00000060          .word   24 * STD_TARGWORDMAUS, TSK_idle$obj
         000004b4 00000000-
1                           
1        000004b8                   OBJ_Obj TSK_idle, OBJ_TSK, (TSK_CORESIZE + TSK$num_hooks)       ; allocates 3 words
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_TSK == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  150

2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_TSK == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
2                                       .endif
2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_TSK == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != 1          ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2        000004b8 00000060-                 .word   TSK_idle + (21 + 0) * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2        000004bc 00000040-             .word       _OBJ_table + 4 * STD_TARGWORDMAUS               ; previous object or OBJ_table
2                           
2        000004c0 0000ABC2              .word       OBJ_TSK | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        "TSK_idle$obj", OBJ_tsk$prev
2                           
2                                       .if 1 = 1                   ; first TSK Obj
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  151

2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg "TSK_idle$obj", OBJ_tsk$next       ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       1+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_MBX
2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  152

2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  153

2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != BUF$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_buf$prev
2                           
2                                       .if BUF$sernum = 1                  ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       BUF$sernum+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        000004c4 0000000C-         .word   TSK_idle, TSK_idle                      ; kobj.ready
         000004c8 0000000C-
1        000004cc 00000014-         .word   TSK_idle+2*STD_TARGWORDMAUS, TSK_idle+2*STD_TARGWORDMAUS        ; kobj.alarm
         000004d0 00000014-
1        000004d4 0000001C-         .word   TSK_idle+4*STD_TARGWORDMAUS, TSK_idle+4*STD_TARGWORDMAUS        ; kobj.setpri
         000004d8 0000001C-
1                           
1                                   ;
1                                   ; GCONF gives priority of 0ffffffffh for -1, so we need to translate
1                                   ; since the assembler treats 0ffffffffh as unsigned
1                                   ;
1                                   .if 00H = 0ffffffffh
1                                       .eval       -1, local_priority
1                                   .else
1                                       .eval       00H, local_priority
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  154

1                                   .endif
1                           
1                                   .if 0 < 0
1                                       ;
1                                       ;  KNL_queues[3] is _KNL_inactive queue. All terminated and
1                                       ;  negative priority tasks go here.
1                                       ;
1                                       .word       _KNL_queues+3*2*STD_TARGWORDMAUS        ; kobj.queue = _KNL_inactive
1                                       .word       local_priority          ; kobj.priority
1                                       .word       0                       ; kobj.mask
1                                   .else
1                                       ;
1                                       ; KNL_priority[priority]
1                                       ;
1        000004dc 00000020!             .word       _KNL_queues+(0+4)*2*STD_TARGWORDMAUS
1                           
1        000004e0 00000000              .word       0               ; kobj.priority
1        000004e4 00000001              .word       1<<0    ; kobj.mask
1                                   .endif
1                           
1        000004e8 00000398-         .word   TSK_idle$stkptr         ; kobj.sp
1                           
1        000004ec 00000000          .word   0                       ; kobj.timeout
1        000004f0 00000000          .word   0                       ; kobj.mode
1                           
1                                   .if GBL_ENABLEINST
1        000004f4 00000014+             .word       TSK_idle$sts    ; kobj.sts
1                                   .else
1                                       .word       0
1                                   .endif
1                           
1        000004f8 00000000          .short  0                       ; kobj.signalled
1                                   .align  STD_TARGWORDMAUS
1                           
1                                   ;
1                                   ;  stack - This field is only used by TSK_checkstacks to
1                                   ;  verify that the task stack is still valid.  It always
1                                   ;  points to the top (lowest address) of the task's stack.
1                                   ;
1        000004fc 00000000-         .word   TSK_idle$stack
1        00000500 00000400          .word   0400H
1        00000504 00000014-         .word   SDRAM           
1                           
1                           
1                                   ;
1                                   ;  Set up pointer to task's name or NULL
1                                   ;
1                                   .if     00H
1                                           .word   TSK$:name:              ; name
1                                   .else
1        00000508 00000000                  .word   0
1                                   .endif
1                           
1                                   .if     0 == 0
1        0000050c 00000000              .word       00H                     ; environ
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  155

1                                   .else
1                                       .word       :name:$env
1                                   .endif
1                           
1        00000510 00000000          .word   0                       ; errno
1        00000514 00000001          .short  01H
1                                   .align  STD_TARGWORDMAUS                        ; short followed by word could misalign
1                           
1                                   ; End of TSK_Obj structure;
1                           
1                                   .if GBL_ENABLEINST
1        00000518                       STS_Obj     1, TSK_idle$sts, 0, 0, 0
2                           
2        00000518                   CHK_nargs "STS_Obj", prevl
2                           
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "STS_Obj parameter error."
2                                   .endif
2                           
2                                   .if (1 = 0)                  ; if this object is not
2                                                                      ; really to be allocated
2                                       .mexit                         ; exit quietly now
2                                   .endif
2                           
2                                   .global TSK_idle$sts, TSK_idle$sts$stsobj     
2                           
2        00000010                   .sect ".sts"                       ; allocate STS_Obj 
2                                                                      ; (in section ".sts")
2                           TSK_idle$sts  .tag    STS_Obj                    ; declare name as having 
2                                                                      ; type STS_Obj
2        00000010           TSK_idle$sts$stsobj:
2                                                                     ; NOTE: on 32-bit targets
2                                                                     ; only prevh is used
2        00000010 00000000          .long   0                         ; allocate space for previous
2                                                                     ; 32-bit value
2        00000014           TSK_idle$sts                                   
2        00000014 00000000          .long   0                         ; num
2        00000018 00000000          .long   0                         ; acc
2        0000001c 80000000          .long   80000000h                 ; max
2                           
2        00000518                   .sect    ".cinit"
2                                   .align    8
2        00000518 00000010          .field    STD_TARGWORDMAUS * 4
2        0000051c 00000010+         .field    TSK_idle$sts$stsobj                    
2        00000520 00000000          .field    0                  ; allocate space for history   
2        00000524 00000000          .field    0                        ; num
2        00000528 00000000          .field    0                        ; acc
2        0000052c 80000000          .field    80000000h                ; max
2                           
2        00000020                   .sect    ".sts"
2                           
1                                   .endif
1                           
1                                   .if $symcmp("IDL_F_loop", "_SYS_nop") = 0
1                                       .wmsg "Task :name: is being created to run :fxn:"
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  156

1                                   .endif
1                           
1                                   .if     0 > 0
1                                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1                                       .word       1 * STD_TARGWORDMAUS
1                                       .word       :name:$env + (HOOK$knl_index * (1 * STD_TARGWORDMAUS))
1                                       .word       :envp:
1                                   .endif
1                           
1                           
1                                   ;
1                                   ; generate a cinit record that will initialize the tasks's stack
1                                   ;
1        00000530                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1                           
1                                   ;
1                                   ; TSK_idle$stkptr points one word *below* stack frame, so add 1 word
1                                   ; to the base address of the cinit record
1                                   ;
1        00000530 00000060          .word   24 * STD_TARGWORDMAUS, TSK_idle$stkptr + (1 * STD_TARGWORDMAUS)
         00000534 0000039C-
1                           
1        00000538 00000000          .word   0
1        0000053c 00000000          .word   00H
1        00000540 00000000!         .word   _KNL_exit
1        00000544 00000000          .word   0
1        00000548 00000000!         .word   KNL_glue
1                                   ;
1                                   ; TSK_USEDSTACK is the total number of words in the startup
1                                   ; stack.  There are 15 words that are set explicitly, leaving
1                                   ; TSK_USEDSTACK - 15 words for which we need to leave space here.
1                                   ;
1                           
1                                   ; The .space directive for the C6x indicates bytes
1                           
1        0000054c                   .space  (24 - 15) * STD_TARGWORDMAUS    ; 4 bytes per word
1                           
1                                   .eval   0, strCount$save
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000570 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000574 00000000              .word 00H
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  157

1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000578 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        0000057c 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000580 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000584 00000000              .word 00H
1                                   .endif
1                           
1                           ;
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           ;
1                           ;  Be careful with this little island of non-arg code!
1                           
1        00000588 00000000!         .word   IDL_F_loop
1        0000058c 00000000!         .word   _TSK_exit
1                           
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000590 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  158

1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000594 00000000              .word 00H
1                                   .endif
1                           
1                                   ;
1                                   ; Create a record to fill unused portion of stack with stackstamp
1                                   ; Format: sequence of 3 words; <count, address, fill-value>
1                                   ;
1        0000000c                   .sect ".gblinit"
1        0000000c 000000E7          .word   ((TSK_idle$stkptr - TSK_idle$stack) / STD_TARGWORDMAUS) + 1     ; count
1        00000010 00000000-         .word   TSK_idle$stack
1        00000014 BEBEBEBE          .word   0xbebebebe 
1                           
1                           
1                                   ;
1                                   ; Finally, let TSK_idle point to the right location
1                                   ;
1                                   .asg "TSK_idle$base + OBJ_HDRSIZE * STD_TARGWORDMAUS", TSK_idle
1                           
1                                   ;
1                                   ; Conditionally set up strings for arguments
1                                   ;
1                                   .eval   0, TSK$strCount
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg0(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg1(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg2(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg3(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  159

1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg4(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg5(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg6(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg7(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
     918                    
     919                    ;; ======== TSK_Obj TSK_image ========
     920                    ;; video input
     921                    ;;
     922                    ;; TSK_Obj TSK_image (iFXN, iARG0, iARG1, iARG2, iARG3, iARG4, iARG5, iARG6, iARG7, iAUTOSTK, iMANSTK,
     923                            .global TSK_image
     924                            .asg _tskVideoInput, _iFXN
     925                            .asg 00H, _iARG0
     926                            .asg 00H, _iARG1
     927                            .asg 00H, _iARG2
     928                            .asg 00H, _iARG3
     929                            .asg 00H, _iARG4
     930                            .asg 00H, _iARG5
     931                            .asg 00H, _iARG6
     932                            .asg 00H, _iARG7
     933                            .asg 01H, _iAUTOSTK
     934                            .asg null, _iMANSTK
     935                            .asg 05000H, _iSTKSZ
     936                            .asg SDRAM, _iSTKSEG
     937                            .asg 05H, _iPRI
     938                            .asg 00H, _iENV
     939                            .asg 01H, _iEXITFLAG
     940                            .asg 00H, _iUSETSKNAME
     941                            .asg 00H, _iSTATREG
     942 00000018                   TSK_Obj 1, TSK_image, 0, _iFXN, _iARG0, _iARG1, _iARG2, _iARG3, _iARG4, _iARG5, _iARG6, _iARG7
1                           
1                                   .global _tskVideoInput
1                                   .global TSK_image
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  160

1                                   .if 00H
1                                           .sect   ".const"
1                           TSK$:TSK_image: .string ":name:",0      ; null-terminated name string
1                                   .endif
1                           
1        00000060           TSK_image$obj   .usect  ".tsk", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        0000006c           TSK_image               .usect  ".tsk", 21 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .if     0 > 0
1                           :name:$env      .usect  ".tsk", TSK$num_hooks * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .endif
1                           
1                 00005000  TSK_image$stklen        .set    05000H
1                           
1                                   .if     01H
1                                       ;
1                                       ; Reserve space for automatically allocated stack
1                                       ;
1        00000000           TSK_image$stack .usect ".TSK_image$stk", 05000H, STD_TARGALIGN
1                                           .global TSK_image$stack, TSK_image$stackname
1                                           .asg    "TSK_image$stack", TSK_image$stackname
1                                   .else
1                                       .if ($symcmp(":manstack:", "null") == 0)
1                                           .emsg "TSK :name: manually allocated stack cannot be null"
1                                       .else
1                                           .asg    ":manstack:", :name:$stackname
1                                       .endif
1                                   .endif
1                           
1                                   ;
1                                   ; stkptr for the idle stack is used by the IDL_F_stub function
1                                   ;
1                                   .global TSK_image$stkptr
1                           
1                                   .if 01H
1                 00004F98- TSK_image$stkptr        .set TSK_image$stack + 05000H - STD_TARGALIGN - (24 * STD_TARGWORDMAUS)
1                                   .else
1                                           .asg "(:name:$stackname + :stacksize: - STD_TARGALIGN - (TSK_USEDSTACK * STD_TARGWORDM
1                                   .endif
1                           
1        00000598                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000598 00000060          .word   24 * STD_TARGWORDMAUS, TSK_image$obj
         0000059c 00000060-
1                           
1        000005a0                   OBJ_Obj TSK_image, OBJ_TSK, (TSK_CORESIZE + TSK$num_hooks)      ; allocates 3 words
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_TSK == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  161

2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_TSK == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
2                                       .endif
2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  162

2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_TSK == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != 2          ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2        000005a0 000000C0-                 .word   TSK_image + (21 + 0) * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_TSK             ; next points back to OBJ_table
2                                       .endif
2                                   
2        000005a4 00000000-             .word       TSK_idle$obj            ; previous object or OBJ_table
2                           
2        000005a8 0000ABC2              .word       OBJ_TSK | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        "TSK_image$obj", OBJ_tsk$prev
2                           
2                                       .if 2 = 1                   ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       2+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_MBX
2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  163

2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  164

2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != BUF$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_buf$prev
2                           
2                                       .if BUF$sernum = 1                  ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       BUF$sernum+1, BUF$sernum
2                                   
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  165

2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        000005ac 0000006C-         .word   TSK_image, TSK_image                    ; kobj.ready
         000005b0 0000006C-
1        000005b4 00000074-         .word   TSK_image+2*STD_TARGWORDMAUS, TSK_image+2*STD_TARGWORDMAUS      ; kobj.alarm
         000005b8 00000074-
1        000005bc 0000007C-         .word   TSK_image+4*STD_TARGWORDMAUS, TSK_image+4*STD_TARGWORDMAUS      ; kobj.setpri
         000005c0 0000007C-
1                           
1                                   ;
1                                   ; GCONF gives priority of 0ffffffffh for -1, so we need to translate
1                                   ; since the assembler treats 0ffffffffh as unsigned
1                                   ;
1                                   .if 05H = 0ffffffffh
1                                       .eval       -1, local_priority
1                                   .else
1                                       .eval       05H, local_priority
1                                   .endif
1                           
1                                   .if 5 < 0
1                                       ;
1                                       ;  KNL_queues[3] is _KNL_inactive queue. All terminated and
1                                       ;  negative priority tasks go here.
1                                       ;
1                                       .word       _KNL_queues+3*2*STD_TARGWORDMAUS        ; kobj.queue = _KNL_inactive
1                                       .word       local_priority          ; kobj.priority
1                                       .word       0                       ; kobj.mask
1                                   .else
1                                       ;
1                                       ; KNL_priority[priority]
1                                       ;
1        000005c4 00000048!             .word       _KNL_queues+(5+4)*2*STD_TARGWORDMAUS
1                           
1        000005c8 00000005              .word       5               ; kobj.priority
1        000005cc 00000020              .word       1<<5    ; kobj.mask
1                                   .endif
1                           
1        000005d0 00004F98-         .word   TSK_image$stkptr                ; kobj.sp
1                           
1        000005d4 00000000          .word   0                       ; kobj.timeout
1        000005d8 00000000          .word   0                       ; kobj.mode
1                           
1                                   .if GBL_ENABLEINST
1        000005dc 00000024+             .word       TSK_image$sts   ; kobj.sts
1                                   .else
1                                       .word       0
1                                   .endif
1                           
1        000005e0 00000000          .short  0                       ; kobj.signalled
1                                   .align  STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  166

1                           
1                                   ;
1                                   ;  stack - This field is only used by TSK_checkstacks to
1                                   ;  verify that the task stack is still valid.  It always
1                                   ;  points to the top (lowest address) of the task's stack.
1                                   ;
1        000005e4 00000000-         .word   TSK_image$stack
1        000005e8 00005000          .word   05000H
1        000005ec 00000014-         .word   SDRAM           
1                           
1                           
1                                   ;
1                                   ;  Set up pointer to task's name or NULL
1                                   ;
1                                   .if     00H
1                                           .word   TSK$:name:              ; name
1                                   .else
1        000005f0 00000000                  .word   0
1                                   .endif
1                           
1                                   .if     0 == 0
1        000005f4 00000000              .word       00H                     ; environ
1                                   .else
1                                       .word       :name:$env
1                                   .endif
1                           
1        000005f8 00000000          .word   0                       ; errno
1        000005fc 00000001          .short  01H
1                                   .align  STD_TARGWORDMAUS                        ; short followed by word could misalign
1                           
1                                   ; End of TSK_Obj structure;
1                           
1                                   .if GBL_ENABLEINST
1        00000600                       STS_Obj     1, TSK_image$sts, 0, 0, 0
2                           
2        00000600                   CHK_nargs "STS_Obj", prevl
2                           
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "STS_Obj parameter error."
2                                   .endif
2                           
2                                   .if (1 = 0)                  ; if this object is not
2                                                                      ; really to be allocated
2                                       .mexit                         ; exit quietly now
2                                   .endif
2                           
2                                   .global TSK_image$sts, TSK_image$sts$stsobj     
2                           
2        00000020                   .sect ".sts"                       ; allocate STS_Obj 
2                                                                      ; (in section ".sts")
2                           TSK_image$sts  .tag    STS_Obj                    ; declare name as having 
2                                                                      ; type STS_Obj
2        00000020           TSK_image$sts$stsobj:
2                                                                     ; NOTE: on 32-bit targets
2                                                                     ; only prevh is used
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  167

2        00000020 00000000          .long   0                         ; allocate space for previous
2                                                                     ; 32-bit value
2        00000024           TSK_image$sts                                   
2        00000024 00000000          .long   0                         ; num
2        00000028 00000000          .long   0                         ; acc
2        0000002c 80000000          .long   80000000h                 ; max
2                           
2        00000600                   .sect    ".cinit"
2                                   .align    8
2        00000600 00000010          .field    STD_TARGWORDMAUS * 4
2        00000604 00000020+         .field    TSK_image$sts$stsobj                    
2        00000608 00000000          .field    0                  ; allocate space for history   
2        0000060c 00000000          .field    0                        ; num
2        00000610 00000000          .field    0                        ; acc
2        00000614 80000000          .field    80000000h                ; max
2                           
2        00000030                   .sect    ".sts"
2                           
1                                   .endif
1                           
1                                   .if $symcmp("_tskVideoInput", "_SYS_nop") = 0
1                                       .wmsg "Task :name: is being created to run :fxn:"
1                                   .endif
1                           
1                                   .if     0 > 0
1                                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1                                       .word       1 * STD_TARGWORDMAUS
1                                       .word       :name:$env + (HOOK$knl_index * (1 * STD_TARGWORDMAUS))
1                                       .word       :envp:
1                                   .endif
1                           
1                           
1                                   ;
1                                   ; generate a cinit record that will initialize the tasks's stack
1                                   ;
1        00000618                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1                           
1                                   ;
1                                   ; TSK_image$stkptr points one word *below* stack frame, so add 1 word
1                                   ; to the base address of the cinit record
1                                   ;
1        00000618 00000060          .word   24 * STD_TARGWORDMAUS, TSK_image$stkptr + (1 * STD_TARGWORDMAUS)
         0000061c 00004F9C-
1                           
1        00000620 00000000          .word   0
1        00000624 00000000          .word   00H
1        00000628 00000000!         .word   _KNL_exit
1        0000062c 00000000          .word   0
1        00000630 00000000!         .word   KNL_glue
1                                   ;
1                                   ; TSK_USEDSTACK is the total number of words in the startup
1                                   ; stack.  There are 15 words that are set explicitly, leaving
1                                   ; TSK_USEDSTACK - 15 words for which we need to leave space here.
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  168

1                                   ;
1                           
1                                   ; The .space directive for the C6x indicates bytes
1                           
1        00000634                   .space  (24 - 15) * STD_TARGWORDMAUS    ; 4 bytes per word
1                           
1                                   .eval   0, strCount$save
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000658 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        0000065c 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000660 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000664 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000668 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        0000066c 00000000              .word 00H
1                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  169

1                           
1                           ;
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           ;
1                           ;  Be careful with this little island of non-arg code!
1                           
1        00000670 00000000!         .word   _tskVideoInput
1        00000674 00000000!         .word   _TSK_exit
1                           
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000678 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        0000067c 00000000              .word 00H
1                                   .endif
1                           
1                                   ;
1                                   ; Create a record to fill unused portion of stack with stackstamp
1                                   ; Format: sequence of 3 words; <count, address, fill-value>
1                                   ;
1        00000018                   .sect ".gblinit"
1        00000018 000013E7          .word   ((TSK_image$stkptr - TSK_image$stack) / STD_TARGWORDMAUS) + 1   ; count
1        0000001c 00000000-         .word   TSK_image$stack
1        00000020 BEBEBEBE          .word   0xbebebebe 
1                           
1                           
1                                   ;
1                                   ; Finally, let TSK_image point to the right location
1                                   ;
1                                   .asg "TSK_image$base + OBJ_HDRSIZE * STD_TARGWORDMAUS", TSK_image
1                           
1                                   ;
1                                   ; Conditionally set up strings for arguments
1                                   ;
1                                   .eval   0, TSK$strCount
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg0(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  170

1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg1(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg2(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg3(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg4(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg5(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg6(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg7(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
     943                    
     944                    ;; ======== TSK_Obj TSK_algorithm ========
     945                    ;; algorithm task
     946                    ;;
     947                    ;; TSK_Obj TSK_algorithm (iFXN, iARG0, iARG1, iARG2, iARG3, iARG4, iARG5, iARG6, iARG7, iAUTOSTK, iMAN
     948                            .global TSK_algorithm
     949                            .asg _tskAlgorithm, _iFXN
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  171

     950                            .asg 00H, _iARG0
     951                            .asg 00H, _iARG1
     952                            .asg 00H, _iARG2
     953                            .asg 00H, _iARG3
     954                            .asg 00H, _iARG4
     955                            .asg 00H, _iARG5
     956                            .asg 00H, _iARG6
     957                            .asg 00H, _iARG7
     958                            .asg 01H, _iAUTOSTK
     959                            .asg null, _iMANSTK
     960                            .asg 07ff0H, _iSTKSZ
     961                            .asg SDRAM, _iSTKSEG
     962                            .asg 02H, _iPRI
     963                            .asg 080b00000H, _iENV
     964                            .asg 01H, _iEXITFLAG
     965                            .asg 00H, _iUSETSKNAME
     966                            .asg 00H, _iSTATREG
     967 00000024                   TSK_Obj 1, TSK_algorithm, 0, _iFXN, _iARG0, _iARG1, _iARG2, _iARG3, _iARG4, _iARG5, _iARG6, _i
1                           
1                                   .global _tskAlgorithm
1                                   .global TSK_algorithm
1                           
1                                   .if 00H
1                                           .sect   ".const"
1                           TSK$:TSK_algorithm:     .string ":name:",0      ; null-terminated name string
1                                   .endif
1                           
1        000000c0           TSK_algorithm$obj       .usect  ".tsk", 3 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        000000cc           TSK_algorithm           .usect  ".tsk", 21 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .if     0 > 0
1                           :name:$env      .usect  ".tsk", TSK$num_hooks * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .endif
1                           
1                 00007FF0  TSK_algorithm$stklen    .set    07ff0H
1                           
1                                   .if     01H
1                                       ;
1                                       ; Reserve space for automatically allocated stack
1                                       ;
1        00000000           TSK_algorithm$stack     .usect ".TSK_algorithm$stk", 07ff0H, STD_TARGALIGN
1                                           .global TSK_algorithm$stack, TSK_algorithm$stackname
1                                           .asg    "TSK_algorithm$stack", TSK_algorithm$stackname
1                                   .else
1                                       .if ($symcmp(":manstack:", "null") == 0)
1                                           .emsg "TSK :name: manually allocated stack cannot be null"
1                                       .else
1                                           .asg    ":manstack:", :name:$stackname
1                                       .endif
1                                   .endif
1                           
1                                   ;
1                                   ; stkptr for the idle stack is used by the IDL_F_stub function
1                                   ;
1                                   .global TSK_algorithm$stkptr
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  172

1                                   .if 01H
1                 00007F88- TSK_algorithm$stkptr    .set TSK_algorithm$stack + 07ff0H - STD_TARGALIGN - (24 * STD_TARGWORDMAUS)
1                                   .else
1                                           .asg "(:name:$stackname + :stacksize: - STD_TARGALIGN - (TSK_USEDSTACK * STD_TARGWORDM
1                                   .endif
1                           
1        00000680                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000680 00000060          .word   24 * STD_TARGWORDMAUS, TSK_algorithm$obj
         00000684 000000C0-
1                           
1        00000688                   OBJ_Obj TSK_algorithm, OBJ_TSK, (TSK_CORESIZE + TSK$num_hooks)  ; allocates 3 words
2                           
2                           ;
2                           ;  OBJ_SEM 
2                           ;
2                           
2                                   .if OBJ_TSK == OBJ_SEM
2                           
2                                       .if SEM$NUMOF != SEM$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word OBJ_TAB_SEM               ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sem$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sem$prev
2                           
2                                       .if SEM$sernum = 1                  ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sem$next
2                                       .endif
2                           
2                                       .eval       SEM$sernum+1, SEM$sernum
2                           
2                           ;
2                           ;  OBJ_SWI
2                           ;
2                            
2                                   .elseif OBJ_TSK == OBJ_SWI
2                            
2                                       .if SWI$NUMOF != SWI$sernum         ; if not the last SWI Obj
2                                           ; next points to next SWI Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SWI             ; next points back to OBJ_table
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  173

2                                       .endif
2                                    
2                                       .word       OBJ_swi$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_swi$prev
2                           
2                                       .if SWI$sernum = 1                  ; first SWI Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_swi$next  ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       SWI$sernum+1, SWI$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_TSK 
2                           ;
2                           
2                                   .elseif OBJ_TSK == OBJ_TSK
2                           
2                                       .if TSK$NUMOF != 3          ; if not the last TSK Obj
2                                           ; next points to next TSK Obj
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2        00000688 00000040-                 .word   _OBJ_table + 4 * STD_TARGWORDMAUS               ; next points back to OBJ_tabl
2                                       .endif
2                                   
2        0000068c 00000060-             .word       TSK_image$obj           ; previous object or OBJ_table
2                           
2        00000690 0000ABC2              .word       OBJ_TSK | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        "TSK_algorithm$obj", OBJ_tsk$prev
2                           
2                                       .if 3 = 1                   ; first TSK Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_tsk$next ; "next" field of OBJ_table
2                                       .endif
2                           
2                                       .eval       3+1, TSK$sernum
2                           
2                           ;
2                           ;  OBJ_MBX 
2                           ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  174

2                                   .elseif OBJ_TSK == OBJ_MBX
2                           
2                                       .if MBX$NUMOF != MBX$sernum         ; if not the last MBX Obj
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_MBX             ; next points back to OBJ_table
2                                       .endif
2                                   
2                                       .word       OBJ_mbx$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg        ":name:$obj", OBJ_mbx$prev
2                           
2                                       .if MBX$sernum = 1                  ; first MBX Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_mbx$next
2                                       .endif
2                           
2                                       .eval       MBX$sernum+1, MBX$sernum
2                           
2                           ;
2                           ;  OBJ_SIO 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_SIO
2                           
2                                       .if (SIO$NUMOF != SIO$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_SIO             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_sio$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_sio$prev
2                           
2                                       .if SIO$sernum = 1                  ; first SIO Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_sio$next
2                                       .endif
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  175

2                                       .eval       SIO$sernum+1, SIO$sernum
2                           
2                           ;
2                           ;  OBJ_DEV 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_DEV
2                                      
2                                       ; DEV_Device entry in OBJ table is sum of all the DEV_Device entry
2                                       ; that get created. These entries are created from UDEV, DGN, DHL
2                                       ; DPI and DIO. 
2                                       ; Sum of devices is provided by DEV$NUMDEVICES symbol(from cfg.xx)
2                           
2                                       .if DEV$NUMDEVICES != DEV$sernum
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
2                                       .else
2                                           .word   OBJ_TAB_DEV             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_dev$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       ; Below assignment is different from other OBJ modules. 
2                                       ; This is because in case of OBJ_DEV OBJ_cinitObj is passed
2                                       ; with :name:$obj itself. For example 'DGN_printData$obj', Note
2                                       ; that here we can't pass 'DGN_printData' to this macro
2                                       ; Because 'DGN_printData' is a string allocated in .const section
2                                       ; by driver macro(DGN_Obj). But this OBJ header needs to point
2                                       ; wherever DEV_Device, i.e., 'DGN_printData$obj' is allocated and
2                                       ; not string 'DGN_printData'
2                           
2                                       .asg ":name:", OBJ_dev$prev
2                           
2                                       .if DEV$sernum = 1                  ; first DEV_Device Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:", OBJ_dev$next
2                                       .endif
2                           
2                                       .eval       DEV$sernum+1, DEV$sernum
2                           
2                           
2                           ;
2                           ;  OBJ_BUF 
2                           ;
2                                   .elseif OBJ_TSK == OBJ_BUF
2                           
2                                       .if (BUF$NUMOF != BUF$sernum)
2                                           ; next points to next object
2                                           .word   :name: + :size: * STD_TARGWORDMAUS
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  176

2                                       .else
2                                           .word   OBJ_TAB_BUF             ; next points back to OBJ_table
2                                       .endif
2                           
2                                       .word       OBJ_buf$prev            ; previous object or OBJ_table
2                           
2                                       .word       :type: | OBJ_KEY
2                           
2                                       ;
2                                       ; For next obj, this one is prev
2                                       ;
2                                       .asg ":name:$obj", OBJ_buf$prev
2                           
2                                       .if BUF$sernum = 1                  ; first BUF Obj
2                                           ;
2                                           ; If this is the first element, queue head will point to this
2                                           ;
2                                           .asg ":name:$obj", OBJ_buf$next
2                                       .endif
2                                       
2                                       .eval       BUF$sernum+1, BUF$sernum
2                                   
2                                   .else
2                           
2                                       .emsg "OBJ_Obj: :name: passed invalid type :type:"
2                           
2                                   .endif
2                           
1                           
1        00000694 000000CC-         .word   TSK_algorithm, TSK_algorithm                    ; kobj.ready
         00000698 000000CC-
1        0000069c 000000D4-         .word   TSK_algorithm+2*STD_TARGWORDMAUS, TSK_algorithm+2*STD_TARGWORDMAUS      ; kobj.alarm
         000006a0 000000D4-
1        000006a4 000000DC-         .word   TSK_algorithm+4*STD_TARGWORDMAUS, TSK_algorithm+4*STD_TARGWORDMAUS      ; kobj.setpri
         000006a8 000000DC-
1                           
1                                   ;
1                                   ; GCONF gives priority of 0ffffffffh for -1, so we need to translate
1                                   ; since the assembler treats 0ffffffffh as unsigned
1                                   ;
1                                   .if 02H = 0ffffffffh
1                                       .eval       -1, local_priority
1                                   .else
1                                       .eval       02H, local_priority
1                                   .endif
1                           
1                                   .if 2 < 0
1                                       ;
1                                       ;  KNL_queues[3] is _KNL_inactive queue. All terminated and
1                                       ;  negative priority tasks go here.
1                                       ;
1                                       .word       _KNL_queues+3*2*STD_TARGWORDMAUS        ; kobj.queue = _KNL_inactive
1                                       .word       local_priority          ; kobj.priority
1                                       .word       0                       ; kobj.mask
1                                   .else
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  177

1                                       ;
1                                       ; KNL_priority[priority]
1                                       ;
1        000006ac 00000030!             .word       _KNL_queues+(2+4)*2*STD_TARGWORDMAUS
1                           
1        000006b0 00000002              .word       2               ; kobj.priority
1        000006b4 00000004              .word       1<<2    ; kobj.mask
1                                   .endif
1                           
1        000006b8 00007F88-         .word   TSK_algorithm$stkptr            ; kobj.sp
1                           
1        000006bc 00000000          .word   0                       ; kobj.timeout
1        000006c0 00000000          .word   0                       ; kobj.mode
1                           
1                                   .if GBL_ENABLEINST
1        000006c4 00000034+             .word       TSK_algorithm$sts       ; kobj.sts
1                                   .else
1                                       .word       0
1                                   .endif
1                           
1        000006c8 00000000          .short  0                       ; kobj.signalled
1                                   .align  STD_TARGWORDMAUS
1                           
1                                   ;
1                                   ;  stack - This field is only used by TSK_checkstacks to
1                                   ;  verify that the task stack is still valid.  It always
1                                   ;  points to the top (lowest address) of the task's stack.
1                                   ;
1        000006cc 00000000-         .word   TSK_algorithm$stack
1        000006d0 00007FF0          .word   07ff0H
1        000006d4 00000014-         .word   SDRAM           
1                           
1                           
1                                   ;
1                                   ;  Set up pointer to task's name or NULL
1                                   ;
1                                   .if     00H
1                                           .word   TSK$:name:              ; name
1                                   .else
1        000006d8 00000000                  .word   0
1                                   .endif
1                           
1                                   .if     0 == 0
1        000006dc 80B00000              .word       080b00000H                      ; environ
1                                   .else
1                                       .word       :name:$env
1                                   .endif
1                           
1        000006e0 00000000          .word   0                       ; errno
1        000006e4 00000001          .short  01H
1                                   .align  STD_TARGWORDMAUS                        ; short followed by word could misalign
1                           
1                                   ; End of TSK_Obj structure;
1                           
1                                   .if GBL_ENABLEINST
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  178

1        000006e8                       STS_Obj     1, TSK_algorithm$sts, 0, 0, 0
2                           
2        000006e8                   CHK_nargs "STS_Obj", prevl
2                           
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "STS_Obj parameter error."
2                                   .endif
2                           
2                                   .if (1 = 0)                  ; if this object is not
2                                                                      ; really to be allocated
2                                       .mexit                         ; exit quietly now
2                                   .endif
2                           
2                                   .global TSK_algorithm$sts, TSK_algorithm$sts$stsobj     
2                           
2        00000030                   .sect ".sts"                       ; allocate STS_Obj 
2                                                                      ; (in section ".sts")
2                           TSK_algorithm$sts  .tag    STS_Obj                    ; declare name as having 
2                                                                      ; type STS_Obj
2        00000030           TSK_algorithm$sts$stsobj:
2                                                                     ; NOTE: on 32-bit targets
2                                                                     ; only prevh is used
2        00000030 00000000          .long   0                         ; allocate space for previous
2                                                                     ; 32-bit value
2        00000034           TSK_algorithm$sts                                   
2        00000034 00000000          .long   0                         ; num
2        00000038 00000000          .long   0                         ; acc
2        0000003c 80000000          .long   80000000h                 ; max
2                           
2        000006e8                   .sect    ".cinit"
2                                   .align    8
2        000006e8 00000010          .field    STD_TARGWORDMAUS * 4
2        000006ec 00000030+         .field    TSK_algorithm$sts$stsobj                    
2        000006f0 00000000          .field    0                  ; allocate space for history   
2        000006f4 00000000          .field    0                        ; num
2        000006f8 00000000          .field    0                        ; acc
2        000006fc 80000000          .field    80000000h                ; max
2                           
2        00000040                   .sect    ".sts"
2                           
1                                   .endif
1                           
1                                   .if $symcmp("_tskAlgorithm", "_SYS_nop") = 0
1                                       .wmsg "Task :name: is being created to run :fxn:"
1                                   .endif
1                           
1                                   .if     0 > 0
1                                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1                                       .word       1 * STD_TARGWORDMAUS
1                                       .word       :name:$env + (HOOK$knl_index * (1 * STD_TARGWORDMAUS))
1                                       .word       :envp:
1                                   .endif
1                           
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  179

1                                   ;
1                                   ; generate a cinit record that will initialize the tasks's stack
1                                   ;
1        00000700                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1                           
1                                   ;
1                                   ; TSK_algorithm$stkptr points one word *below* stack frame, so add 1 word
1                                   ; to the base address of the cinit record
1                                   ;
1        00000700 00000060          .word   24 * STD_TARGWORDMAUS, TSK_algorithm$stkptr + (1 * STD_TARGWORDMAUS)
         00000704 00007F8C-
1                           
1        00000708 00000000          .word   0
1        0000070c 00000000          .word   00H
1        00000710 00000000!         .word   _KNL_exit
1        00000714 00000000          .word   0
1        00000718 00000000!         .word   KNL_glue
1                                   ;
1                                   ; TSK_USEDSTACK is the total number of words in the startup
1                                   ; stack.  There are 15 words that are set explicitly, leaving
1                                   ; TSK_USEDSTACK - 15 words for which we need to leave space here.
1                                   ;
1                           
1                                   ; The .space directive for the C6x indicates bytes
1                           
1        0000071c                   .space  (24 - 15) * STD_TARGWORDMAUS    ; 4 bytes per word
1                           
1                                   .eval   0, strCount$save
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000740 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000744 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000748 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  180

1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        0000074c 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000750 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000754 00000000              .word 00H
1                                   .endif
1                           
1                           ;
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           ;
1                           ;  Be careful with this little island of non-arg code!
1                           
1        00000758 00000000!         .word   _tskAlgorithm
1        0000075c 00000000!         .word   _TSK_exit
1                           
1                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000760 00000000              .word 00H
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .word       TSK$string:TSK$strCount:
1                                       .eval       TSK$strCount+1, TSK$strCount
1                                   .else
1        00000764 00000000              .word 00H
1                                   .endif
1                           
1                                   ;
1                                   ; Create a record to fill unused portion of stack with stackstamp
1                                   ; Format: sequence of 3 words; <count, address, fill-value>
1                                   ;
1        00000024                   .sect ".gblinit"
1        00000024 00001FE3          .word   ((TSK_algorithm$stkptr - TSK_algorithm$stack) / STD_TARGWORDMAUS) + 1   ; count
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  181

1        00000028 00000000-         .word   TSK_algorithm$stack
1        0000002c BEBEBEBE          .word   0xbebebebe 
1                           
1                           
1                                   ;
1                                   ; Finally, let TSK_algorithm point to the right location
1                                   ;
1                                   .asg "TSK_algorithm$base + OBJ_HDRSIZE * STD_TARGWORDMAUS", TSK_algorithm
1                           
1                                   ;
1                                   ; Conditionally set up strings for arguments
1                                   ;
1                                   .eval   0, TSK$strCount
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg0(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg1(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg2(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg3(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg4(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg5(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  182

1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg6(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
1                                   .eval $symlen("00H"),arglen
1                                   .if $symcmp("0","'") = 0 & $symcmp("H","'") = 0
1                                       .sect ".const"
1                           TSK$string:0:   .string ":arg7(2,arglen-2):",0
1                                       .eval TSK$strCount+1, TSK$strCount
1                                   .endif
1                           
     968                    
     969                    ;; ======== IDL_Obj LNK_dataPump ========
     970                    ;; This object cannot be deleted
     971                    ;;
     972                    ;; IDL_Obj LNK_dataPump (function, calibration)
     973                            .global LNK_dataPump
     974                            .asg LNK_F_dataPump, _function
     975                            .asg 01H, _calibration
     976 00000030                   IDL_Obj 1, LNK_dataPump, 0, _function, _calibration
1        00000030                   CHK_nargs "IDL_Obj", calibration
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                               .var fxnlen
1                               .eval $symlen("LNK_F_dataPump"),fxnlen
1                           
1                                   .if (1 = 0)   ; if this object is not really to be allocated
1                                       .mexit      ; exit quietly now
1                                   .endif
1                           
1                                   .global LNK_dataPump$
1                                   .global LNK_dataPump
1                           
1                                   .if ($symcmp("LNK_F_dataPump", "0") != 0)
1                               .global LNK_F_dataPump
1                                   .endif
1                           
1                           LNK_dataPump$ .tag    IDL_Obj         ; declare name$ as having type IDL_Obj
1                           
1        00000000           LNK_dataPump$ .usect ".idlcal", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        00000768                   .sect ".cinit"
1                           
1                               .align  8
1        00000768 00000004      .field  STD_TARGWORDMAUS * 1
1        0000076c 00000000-     .field  LNK_dataPump$    
1                                   .if (01H != 0) ; if to be included in IDL calibration
1        00000770 00000000!             .field  LNK_F_dataPump             ; fxn
1                               .else
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  183

1                                       .field  FXN_F_nop    ; else use FXN_F_nop
1                                   .endif
1                           
1                           LNK_dataPump  .tag    IDL_Obj         ; declare name as having type IDL_Obj
1                           
1        00000000           LNK_dataPump  .usect ".idl", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        00000774                   .sect ".cinit"
1                           
1                               .align  8
1        00000778 00000004      .field  STD_TARGWORDMAUS * 1
1        0000077c 00000000-     .field  LNK_dataPump    
1        00000780 00000000!     .field  LNK_F_dataPump           ; fxn
1                           
     977                    
     978                    ;; ======== IDL_Obj RTA_dispatcher ========
     979                    ;; This object cannot be deleted
     980                    ;;
     981                    ;; IDL_Obj RTA_dispatcher (function, calibration)
     982                            .global RTA_dispatcher
     983                            .asg RTA_F_dispatch, _function
     984                            .asg 01H, _calibration
     985 00000784                   IDL_Obj 1, RTA_dispatcher, 0, _function, _calibration
1        00000784                   CHK_nargs "IDL_Obj", calibration
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                               .var fxnlen
1                               .eval $symlen("RTA_F_dispatch"),fxnlen
1                           
1                                   .if (1 = 0)   ; if this object is not really to be allocated
1                                       .mexit      ; exit quietly now
1                                   .endif
1                           
1                                   .global RTA_dispatcher$
1                                   .global RTA_dispatcher
1                           
1                                   .if ($symcmp("RTA_F_dispatch", "0") != 0)
1                               .global RTA_F_dispatch
1                                   .endif
1                           
1                           RTA_dispatcher$ .tag    IDL_Obj         ; declare name$ as having type IDL_Obj
1                           
1        00000004           RTA_dispatcher$ .usect ".idlcal", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        00000784                   .sect ".cinit"
1                           
1                               .align  8
1        00000788 00000004      .field  STD_TARGWORDMAUS * 1
1        0000078c 00000004-     .field  RTA_dispatcher$    
1                                   .if (01H != 0) ; if to be included in IDL calibration
1        00000790 00000000!             .field  RTA_F_dispatch             ; fxn
1                               .else
1                                       .field  FXN_F_nop    ; else use FXN_F_nop
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  184

1                                   .endif
1                           
1                           RTA_dispatcher  .tag    IDL_Obj         ; declare name as having type IDL_Obj
1                           
1        00000004           RTA_dispatcher  .usect ".idl", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        00000794                   .sect ".cinit"
1                           
1                               .align  8
1        00000798 00000004      .field  STD_TARGWORDMAUS * 1
1        0000079c 00000004-     .field  RTA_dispatcher    
1        000007a0 00000000!     .field  RTA_F_dispatch           ; fxn
1                           
     986                    
     987                    ;; ======== IDL_Obj IDL_cpuLoad ========
     988                    ;; This object is required by the system to acquire CPU load data
     989                    ;;
     990                    ;; IDL_Obj IDL_cpuLoad (function, calibration)
     991                            .global IDL_cpuLoad
     992                            .asg IDL_F_busy, _function
     993                            .asg 01H, _calibration
     994 000007a4                   IDL_Obj 1, IDL_cpuLoad, 0, _function, _calibration
1        000007a4                   CHK_nargs "IDL_Obj", calibration
1                                   .if ($symcmp("", "error") = 0)
1                                       .mexit
1                                   .endif
1                           
1                               .var fxnlen
1                               .eval $symlen("IDL_F_busy"),fxnlen
1                           
1                                   .if (1 = 0)   ; if this object is not really to be allocated
1                                       .mexit      ; exit quietly now
1                                   .endif
1                           
1                                   .global IDL_cpuLoad$
1                                   .global IDL_cpuLoad
1                           
1                                   .if ($symcmp("IDL_F_busy", "0") != 0)
1                               .global IDL_F_busy
1                                   .endif
1                           
1                           IDL_cpuLoad$ .tag    IDL_Obj         ; declare name$ as having type IDL_Obj
1                           
1        00000008           IDL_cpuLoad$ .usect ".idlcal", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        000007a4                   .sect ".cinit"
1                           
1                               .align  8
1        000007a8 00000004      .field  STD_TARGWORDMAUS * 1
1        000007ac 00000008-     .field  IDL_cpuLoad$    
1                                   .if (01H != 0) ; if to be included in IDL calibration
1        000007b0 00000000!             .field  IDL_F_busy             ; fxn
1                               .else
1                                       .field  FXN_F_nop    ; else use FXN_F_nop
1                                   .endif
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  185

1                           
1                           IDL_cpuLoad  .tag    IDL_Obj         ; declare name as having type IDL_Obj
1                           
1        00000008           IDL_cpuLoad  .usect ".idl", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
1                           
1        000007b4                   .sect ".cinit"
1                           
1                               .align  8
1        000007b8 00000004      .field  STD_TARGWORDMAUS * 1
1        000007bc 00000008-     .field  IDL_cpuLoad    
1        000007c0 00000000!     .field  IDL_F_busy           ; fxn
1                           
     995                    
     996                    ;; ======== LOG_Obj LOG_system ========
     997                    ;; This object is required by the system to accumulate execution trace information
     998                    ;;
     999                    ;; LOG_Obj LOG_system (bufseg, buflen, logtype)
    1000                            .global LOG_system
    1001                            .asg SDRAM, _bufseg
    1002                            .asg 0400H, _buflen
    1003                            .asg "circular", _logtype
    1004 000007c4                   LOG_Obj 1, LOG_system, 0, _bufseg, _buflen, _logtype
1        000007c4                   CHK_domain LOG_Obj, mode, "circular,fixed", "circular"
2                           
1                                   .asg "circular", mode
1                                   .if ($isdefed("LOG_NOOP") = 1)
1                                       .mexit
1                               .elseif ($symcmp("circular", "error") = 0)
1                                   .emsg "LOG_Obj mode error."
1                                   .endif
1                           
1                                   .global LOG_system$buf
1                                   .global LOG_system$size
1                           
1                                   .var    bufbeg
1                                   .var    flag
1                                   .if ((1 != 0) & (0400H > 0))
1                                       .if (((0400H - 1) & 0400H) != 0)
1                                           .emsg   "The LOG :name: buffer size must be a power of 2"
1                                       .endif
1                           
1                                       .asg        0, flag         ; enable LOG
1                                       .asg        "LOG_system$buf", bufbeg
1                           
1                                                                  ;
1                                                                  ; place log buffers into 
1                                                                                                      ; .log0, .log1, etc. sectio
1                                       
1        000007c4                       GBL_Obj     LOG_system$buf, buflen, ".LOG_system$buf", "noalign", -1, 1
2        000007c4                   CHK_domain "GBL_Obj", alignFlag, "noalign,align", "noalign"
3                           
2                                   .if ($symcmp("noalign", "error") = 0)
2                                       .emsg "GBL_Obj align parameter error."
2                                   .endif
2                                   .asg "noalign", alignFlag
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  186

2                           
2        000007c4                   CHK_nargs "GBL_Obj", size
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "GBL_Obj size parameter error."
2                                   .endif
2                           
2                                   .if ($symlen(section) = 0)
2                                       .asg ".bss", section
2                                   .endif
2                           
2                                   .if ($symlen(fillValue) != 0)
2        00000030                       .sect ".gblinit"
2        00000030 00000400              .word 0400H
2        00000034 00000000-             .word LOG_system$buf
2        00000038 FFFFFFFF              .word -1
2                                   .endif
2                           
2                                   .if (($symcmp(section, ".data") = 0) | ($symcmp(alignFlag, "align") = 0))
2                                       .sect ":section:"
2                                       .if ($symcmp(alignFlag, "align") = 0)
2                                           .align  :alignValue:
2                                       .endif
2                           :name::
2                                       ;
2                                       ; Can't use .space directive here because it reserves
2                                       ; bits for some processors and bytes for others.
2                                       ;
2                                       .loop       :size:
2                                           .word 0
2                                       .endloop
2                           
2                                   .elseif ($symcmp(".LOG_system$buf", ".bss") = 0)
2                                       .bss :name:, :size: * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS / STD_TARGC
2                                   .else
2        00000000           LOG_system$buf:     .usect ".LOG_system$buf", 0400H * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARG
2                                   .endif
2                           
1                           
1                 00000400  LOG_system$size .set        0400H
1                           
1                                   .else
1                                       .asg        1, flag         ; disable LOG
1                                       .asg        0, bufbeg
1                           :name:$buf  .set        0
1                           :name:$size .set        0
1                                   .endif
1                           
1        00000000                   .sect ".log"                    ; place all LOG objects in
1                                                                   ; ".log"
1                                   .global LOG_system                  ; make name globally visable
1                           LOG_system  .tag    LOG_Obj                 ; declare name as having type
1                                                                   ; LOG_Obj
1                           
1        00000000           LOG_system                                  ; allocate and initialize 
1                                                                   ; LOG_Obj (in current section)
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  187

1                           
1        00000000 00000000          .word    0                      ; bufend 
1        00000004 00000000          .word    0                      ; flag
1        00000008 00000000          .word    0                      ; seqnum 
1        0000000c 00000000          .word    0                      ; curptr
1        00000010 00000000          .word    0                      ; lenmask 
1        00000014 00000000          .word    0                      ; bufbeg
1                           
1        000007c4                   .sect ".cinit"
1                                   .align  8
1        000007c8 00000018          .field  STD_TARGWORDMAUS * 6
1        000007cc 00000000+         .field  LOG_system    
1                               .if ($symcmp("circular", "fixed") = 0)    ; if (mode == "fixed")
1                                   .field  :bufbeg:+(:buflen: * STD_TARGWORDMAUS)-1 ; bufend = bufbeg+buflen-1
1                               .else                               ; else
1        000007d0 00000000          .field  0                       ;    bufend = 0
1                               .endif
1        000007d4 00000000          .field  0                  ; flag
1        000007d8 00000000          .field  0                       ; seqnum = 0
1        000007dc 00000000-         .field  LOG_system$buf                ; curptr
1                                                                   ; lenmask (= buflen-1)
1        000007e0 00000FFF          .field  (0400H * STD_TARGWORDMAUS)-1
1        000007e4 00000000-         .field  LOG_system$buf                ; bufbeg
1        00000018               .sect    ".log"
1                           
    1005                    
    1006                    ;; ======== LOG_Obj trace ========
    1007                    ;; <add comments here>
    1008                    ;;
    1009                    ;; LOG_Obj trace (bufseg, buflen, logtype)
    1010                            .global trace
    1011                            .asg SDRAM, _bufseg
    1012                            .asg 0400H, _buflen
    1013                            .asg "circular", _logtype
    1014 00000018                   LOG_Obj 1, trace, 0, _bufseg, _buflen, _logtype
1        00000018                   CHK_domain LOG_Obj, mode, "circular,fixed", "circular"
2                           
1                                   .asg "circular", mode
1                                   .if ($isdefed("LOG_NOOP") = 1)
1                                       .mexit
1                               .elseif ($symcmp("circular", "error") = 0)
1                                   .emsg "LOG_Obj mode error."
1                                   .endif
1                           
1                                   .global trace$buf
1                                   .global trace$size
1                           
1                                   .var    bufbeg
1                                   .var    flag
1                                   .if ((1 != 0) & (0400H > 0))
1                                       .if (((0400H - 1) & 0400H) != 0)
1                                           .emsg   "The LOG :name: buffer size must be a power of 2"
1                                       .endif
1                           
1                                       .asg        0, flag         ; enable LOG
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  188

1                                       .asg        "trace$buf", bufbeg
1                           
1                                                                  ;
1                                                                  ; place log buffers into 
1                                                                                                      ; .log0, .log1, etc. sectio
1                                       
1        00000018                       GBL_Obj     trace$buf, buflen, ".trace$buf", "noalign", -1, 1
2        00000018                   CHK_domain "GBL_Obj", alignFlag, "noalign,align", "noalign"
3                           
2                                   .if ($symcmp("noalign", "error") = 0)
2                                       .emsg "GBL_Obj align parameter error."
2                                   .endif
2                                   .asg "noalign", alignFlag
2                           
2        00000018                   CHK_nargs "GBL_Obj", size
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "GBL_Obj size parameter error."
2                                   .endif
2                           
2                                   .if ($symlen(section) = 0)
2                                       .asg ".bss", section
2                                   .endif
2                           
2                                   .if ($symlen(fillValue) != 0)
2        0000003c                       .sect ".gblinit"
2        0000003c 00000400              .word 0400H
2        00000040 00000000-             .word trace$buf
2        00000044 FFFFFFFF              .word -1
2                                   .endif
2                           
2                                   .if (($symcmp(section, ".data") = 0) | ($symcmp(alignFlag, "align") = 0))
2                                       .sect ":section:"
2                                       .if ($symcmp(alignFlag, "align") = 0)
2                                           .align  :alignValue:
2                                       .endif
2                           :name::
2                                       ;
2                                       ; Can't use .space directive here because it reserves
2                                       ; bits for some processors and bytes for others.
2                                       ;
2                                       .loop       :size:
2                                           .word 0
2                                       .endloop
2                           
2                                   .elseif ($symcmp(".trace$buf", ".bss") = 0)
2                                       .bss :name:, :size: * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS / STD_TARGC
2                                   .else
2        00000000           trace$buf:     .usect ".trace$buf", 0400H * (STD_TARGWORDMAUS / STD_TARGCHARMAUS), (STD_TARGWORDMAUS /
2                                   .endif
2                           
1                           
1                 00000400  trace$size .set        0400H
1                           
1                                   .else
1                                       .asg        1, flag         ; disable LOG
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  189

1                                       .asg        0, bufbeg
1                           :name:$buf  .set        0
1                           :name:$size .set        0
1                                   .endif
1                           
1        00000018                   .sect ".log"                    ; place all LOG objects in
1                                                                   ; ".log"
1                                   .global trace                  ; make name globally visable
1                           trace  .tag    LOG_Obj                 ; declare name as having type
1                                                                   ; LOG_Obj
1                           
1        00000018           trace                                  ; allocate and initialize 
1                                                                   ; LOG_Obj (in current section)
1                           
1        00000018 00000000          .word    0                      ; bufend 
1        0000001c 00000000          .word    0                      ; flag
1        00000020 00000000          .word    0                      ; seqnum 
1        00000024 00000000          .word    0                      ; curptr
1        00000028 00000000          .word    0                      ; lenmask 
1        0000002c 00000000          .word    0                      ; bufbeg
1                           
1        000007e8                   .sect ".cinit"
1                                   .align  8
1        000007e8 00000018          .field  STD_TARGWORDMAUS * 6
1        000007ec 00000018+         .field  trace    
1                               .if ($symcmp("circular", "fixed") = 0)    ; if (mode == "fixed")
1                                   .field  :bufbeg:+(:buflen: * STD_TARGWORDMAUS)-1 ; bufend = bufbeg+buflen-1
1                               .else                               ; else
1        000007f0 00000000          .field  0                       ;    bufend = 0
1                               .endif
1        000007f4 00000000          .field  0                  ; flag
1        000007f8 00000000          .field  0                       ; seqnum = 0
1        000007fc 00000000-         .field  trace$buf                ; curptr
1                                                                   ; lenmask (= buflen-1)
1        00000800 00000FFF          .field  (0400H * STD_TARGWORDMAUS)-1
1        00000804 00000000-         .field  trace$buf                ; bufbeg
1        00000030               .sect    ".log"
1                           
    1015                    
    1016                    ;; ======== QUE_Obj img_queue ========
    1017                    ;; img TSK used queue
    1018                    ;;
    1019                    ;; QUE_Obj img_queue)
    1020                            .global img_queue
    1021 00000030                   QUE_Obj 1, img_queue, 0
1                           
1                                   .global img_queue
1                           
1        00000000           img_queue       .usect  ".que",2 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000808                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000808 00000008          .word   2 * STD_TARGWORDMAUS
1        0000080c 00000000-         .word   img_queue
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  190

1        00000810 00000000-         .word   img_queue, img_queue            ; QUE_Elem:  prev & next
         00000814 00000000-
1                           
    1022                    
    1023                    ;; ======== QUE_Obj result_queue ========
    1024                    ;; alg TSK returned result
    1025                    ;;
    1026                    ;; QUE_Obj result_queue)
    1027                            .global result_queue
    1028 00000818                   QUE_Obj 1, result_queue, 0
1                           
1                                   .global result_queue
1                           
1        00000008           result_queue    .usect  ".que",2 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000818                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000818 00000008          .word   2 * STD_TARGWORDMAUS
1        0000081c 00000008-         .word   result_queue
1                           
1        00000820 00000008-         .word   result_queue, result_queue              ; QUE_Elem:  prev & next
         00000824 00000008-
1                           
    1029                    
    1030                    ;; ======== QUE_Obj match_queue ========
    1031                    ;; match TSK used queue
    1032                    ;;
    1033                    ;; QUE_Obj match_queue)
    1034                            .global match_queue
    1035 00000828                   QUE_Obj 1, match_queue, 0
1                           
1                                   .global match_queue
1                           
1        00000010           match_queue     .usect  ".que",2 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000828                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000828 00000008          .word   2 * STD_TARGWORDMAUS
1        0000082c 00000010-         .word   match_queue
1                           
1        00000830 00000010-         .word   match_queue, match_queue                ; QUE_Elem:  prev & next
         00000834 00000010-
1                           
    1036                    
    1037                    ;; ======== STS_Obj IDL_busyObj ========
    1038                    ;; This object is required by the system to accumulate CPU load statistics
    1039                    ;;
    1040                    ;; STS_Obj IDL_busyObj (prev, prevlow)
    1041                            .global IDL_busyObj
    1042                            .asg 00H, _prev
    1043                            .asg 00H, _prevlow
    1044 00000838                   STS_Obj 1, IDL_busyObj, 0, _prev, _prevlow
1                           
1        00000838                   CHK_nargs "STS_Obj", prevl
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  191

1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global IDL_busyObj, IDL_busyObj$stsobj     
1                           
1        00000040                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           IDL_busyObj  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000040           IDL_busyObj$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000040 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000044           IDL_busyObj                                   
1        00000044 00000000          .long   0                         ; num
1        00000048 00000000          .long   0                         ; acc
1        0000004c 80000000          .long   80000000h                 ; max
1                           
1        00000838                   .sect    ".cinit"
1                                   .align    8
1        00000838 00000010          .field    STD_TARGWORDMAUS * 4
1        0000083c 00000040+         .field    IDL_busyObj$stsobj                    
1        00000840 00000000          .field    00H                  ; allocate space for history   
1        00000844 00000000          .field    0                        ; num
1        00000848 00000000          .field    0                        ; acc
1        0000084c 80000000          .field    80000000h                ; max
1                           
1        00000050                   .sect    ".sts"
1                           
    1045                    
    1046                    ;; ======== STS_Obj stsCycleTime ========
    1047                    ;; <add comments here>
    1048                    ;;
    1049                    ;; STS_Obj stsCycleTime (prev, prevlow)
    1050                            .global stsCycleTime
    1051                            .asg 00H, _prev
    1052                            .asg 00H, _prevlow
    1053 00000050                   STS_Obj 1, stsCycleTime, 0, _prev, _prevlow
1                           
1        00000050                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  192

1                                   .endif
1                           
1                                   .global stsCycleTime, stsCycleTime$stsobj     
1                           
1        00000050                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsCycleTime  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000050           stsCycleTime$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000050 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000054           stsCycleTime                                   
1        00000054 00000000          .long   0                         ; num
1        00000058 00000000          .long   0                         ; acc
1        0000005c 80000000          .long   80000000h                 ; max
1                           
1        00000850                   .sect    ".cinit"
1                                   .align    8
1        00000850 00000010          .field    STD_TARGWORDMAUS * 4
1        00000854 00000050+         .field    stsCycleTime$stsobj                    
1        00000858 00000000          .field    00H                  ; allocate space for history   
1        0000085c 00000000          .field    0                        ; num
1        00000860 00000000          .field    0                        ; acc
1        00000864 80000000          .field    80000000h                ; max
1                           
1        00000060                   .sect    ".sts"
1                           
    1054                    
    1055                    ;; ======== STS_Obj stsDispTime ========
    1056                    ;; <add comments here>
    1057                    ;;
    1058                    ;; STS_Obj stsDispTime (prev, prevlow)
    1059                            .global stsDispTime
    1060                            .asg 00H, _prev
    1061                            .asg 00H, _prevlow
    1062 00000060                   STS_Obj 1, stsDispTime, 0, _prev, _prevlow
1                           
1        00000060                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsDispTime, stsDispTime$stsobj     
1                           
1        00000060                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsDispTime  .tag    STS_Obj                    ; declare name as having 
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  193

1                                                                      ; type STS_Obj
1        00000060           stsDispTime$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000060 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000064           stsDispTime                                   
1        00000064 00000000          .long   0                         ; num
1        00000068 00000000          .long   0                         ; acc
1        0000006c 80000000          .long   80000000h                 ; max
1                           
1        00000868                   .sect    ".cinit"
1                                   .align    8
1        00000868 00000010          .field    STD_TARGWORDMAUS * 4
1        0000086c 00000060+         .field    stsDispTime$stsobj                    
1        00000870 00000000          .field    00H                  ; allocate space for history   
1        00000874 00000000          .field    0                        ; num
1        00000878 00000000          .field    0                        ; acc
1        0000087c 80000000          .field    80000000h                ; max
1                           
1        00000070                   .sect    ".sts"
1                           
    1063                    
    1064                    ;; ======== STS_Obj stsExeTimeChJpegDec ========
    1065                    ;; <add comments here>
    1066                    ;;
    1067                    ;; STS_Obj stsExeTimeChJpegDec (prev, prevlow)
    1068                            .global stsExeTimeChJpegDec
    1069                            .asg 00H, _prev
    1070                            .asg 00H, _prevlow
    1071 00000070                   STS_Obj 1, stsExeTimeChJpegDec, 0, _prev, _prevlow
1                           
1        00000070                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsExeTimeChJpegDec, stsExeTimeChJpegDec$stsobj     
1                           
1        00000070                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsExeTimeChJpegDec  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000070           stsExeTimeChJpegDec$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000070 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000074           stsExeTimeChJpegDec                                   
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  194

1        00000074 00000000          .long   0                         ; num
1        00000078 00000000          .long   0                         ; acc
1        0000007c 80000000          .long   80000000h                 ; max
1                           
1        00000880                   .sect    ".cinit"
1                                   .align    8
1        00000880 00000010          .field    STD_TARGWORDMAUS * 4
1        00000884 00000070+         .field    stsExeTimeChJpegDec$stsobj                    
1        00000888 00000000          .field    00H                  ; allocate space for history   
1        0000088c 00000000          .field    0                        ; num
1        00000890 00000000          .field    0                        ; acc
1        00000894 80000000          .field    80000000h                ; max
1                           
1        00000080                   .sect    ".sts"
1                           
    1072                    
    1073                    ;; ======== STS_Obj stsExeTimeChJpegEnc ========
    1074                    ;; <add comments here>
    1075                    ;;
    1076                    ;; STS_Obj stsExeTimeChJpegEnc (prev, prevlow)
    1077                            .global stsExeTimeChJpegEnc
    1078                            .asg 00H, _prev
    1079                            .asg 00H, _prevlow
    1080 00000080                   STS_Obj 1, stsExeTimeChJpegEnc, 0, _prev, _prevlow
1                           
1        00000080                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsExeTimeChJpegEnc, stsExeTimeChJpegEnc$stsobj     
1                           
1        00000080                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsExeTimeChJpegEnc  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000080           stsExeTimeChJpegEnc$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000080 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000084           stsExeTimeChJpegEnc                                   
1        00000084 00000000          .long   0                         ; num
1        00000088 00000000          .long   0                         ; acc
1        0000008c 80000000          .long   80000000h                 ; max
1                           
1        00000898                   .sect    ".cinit"
1                                   .align    8
1        00000898 00000010          .field    STD_TARGWORDMAUS * 4
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  195

1        0000089c 00000080+         .field    stsExeTimeChJpegEnc$stsobj                    
1        000008a0 00000000          .field    00H                  ; allocate space for history   
1        000008a4 00000000          .field    0                        ; num
1        000008a8 00000000          .field    0                        ; acc
1        000008ac 80000000          .field    80000000h                ; max
1                           
1        00000090                   .sect    ".sts"
1                           
    1081                    
    1082                    ;; ======== STS_Obj stsCapTime ========
    1083                    ;; <add comments here>
    1084                    ;;
    1085                    ;; STS_Obj stsCapTime (prev, prevlow)
    1086                            .global stsCapTime
    1087                            .asg 00H, _prev
    1088                            .asg 00H, _prevlow
    1089 00000090                   STS_Obj 1, stsCapTime, 0, _prev, _prevlow
1                           
1        00000090                   CHK_nargs "STS_Obj", prevl
1                           
1                                   .if ($symcmp("", "error") = 0)
1                                       .emsg "STS_Obj parameter error."
1                                   .endif
1                           
1                                   .if (1 = 0)                  ; if this object is not
1                                                                      ; really to be allocated
1                                       .mexit                         ; exit quietly now
1                                   .endif
1                           
1                                   .global stsCapTime, stsCapTime$stsobj     
1                           
1        00000090                   .sect ".sts"                       ; allocate STS_Obj 
1                                                                      ; (in section ".sts")
1                           stsCapTime  .tag    STS_Obj                    ; declare name as having 
1                                                                      ; type STS_Obj
1        00000090           stsCapTime$stsobj:
1                                                                     ; NOTE: on 32-bit targets
1                                                                     ; only prevh is used
1        00000090 00000000          .long   0                         ; allocate space for previous
1                                                                     ; 32-bit value
1        00000094           stsCapTime                                   
1        00000094 00000000          .long   0                         ; num
1        00000098 00000000          .long   0                         ; acc
1        0000009c 80000000          .long   80000000h                 ; max
1                           
1        000008b0                   .sect    ".cinit"
1                                   .align    8
1        000008b0 00000010          .field    STD_TARGWORDMAUS * 4
1        000008b4 00000090+         .field    stsCapTime$stsobj                    
1        000008b8 00000000          .field    00H                  ; allocate space for history   
1        000008bc 00000000          .field    0                        ; num
1        000008c0 00000000          .field    0                        ; acc
1        000008c4 80000000          .field    80000000h                ; max
1                           
1        000000a0                   .sect    ".sts"
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  196

1                           
    1090                    
    1091                    ;; MODULE INITIALIZATION
    1092 00000000                   .sect ".sysinit"
    1093                            .global BIOS_init, _BIOS_init
    1094 00000000           BIOS_init:
    1095 00000000           _BIOS_init:
    1096 00000000                   GBL_preamble
1        00000000 01BC54F6          stw     b3, *b15--[2]
1                           
    1097 00000004                   GBL_init
1                           
1                                   ; call GBL_F_version
1        00000004 0180002A!         mvkl    GBL_F_version, b3
1        00000008 0180006A!         mvkh    GBL_F_version, b3
1        0000000c 000C0362          b b3
1        00000010 01800E2A+         mvkl versret?,b3
1        00000014 0180006A+         mvkh versret?,b3
1        00000018 00004000          nop 3 
1        0000001c           versret?:
1        0000001c 00824828          mvkl    GBL_A_VERSION, a1
1        00000020 00800068          mvkh    GBL_A_VERSION, a1
1                            
1        00000024 009028C0          sub a4,a1,a1
1        00000028 00840A58          cmpeq a1,0,a1
1                           
1        0000002c           selfspin? 
1                           
1        0000002c 90000192   [!a1]  b selfspin? 
1                           
1                                   ; only call user init function if non-zero
1                                   .if (GBL_USERINIT != 0)
1                                   ; USERINITFXN below is defined in GBL_config
1        00000030 0180002A!             mvkl _dm642_init, b3
1        00000034 0180006A!             mvkh _dm642_init, b3
1        00000038 000C0362              b b3
1        0000003c 0180242A+             mvkl ginit?, b3
1        00000040 0180006A+             mvkh ginit?, b3
1        00000044 00004000              nop 3
1                           ginit?:
1                                   .endif
1                           
1                                   .global HWI_A_VECS
1                           
1        00000048 00000028!         mvkl HWI_A_VECS,a0
1        0000004c 00000068!         mvkh HWI_A_VECS,a0
1        00000050 028013A2          mvc a0,istp                 ; load interrupt service table pointer
1                           
1        00000054 00000028          mvkl HWI_REGS,a0            ; load addr of Interrupt Selector Regs
1        00000058 0000CE68          mvkh HWI_REGS,a0
1                           
1        0000005c 009CD1AA          mvkl HWI_INTRMULTHIGH,b1    ; Value for Interrupt Multiplexer High
1        00000060 0084106A          mvkh HWI_INTRMULTHIGH,b1
1        00000064 00803676          stw b1,*a0++                ; Store into Interrupt Multiplexer High
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  197

1        00000068 008C522A          mvkl HWI_INTRMULTLOW,b1     ; Value for Interrupt Multiplexer Low
1        0000006c 009283EA          mvkh HWI_INTRMULTLOW,b1
1        00000070 00803676          stw b1,*a0++                ; Store into Interrupt Multiplexer Low
1                           
1        00000074 0080002A          mvkl HWI_POLARITYMASK,b1    ; Value for External Interrupt Polarity
1        00000078 0080006A          mvkh HWI_POLARITYMASK,b1
1        0000007c 00800276          stw b1,*a0                  ; Store into External Interrupt Polarity
1                           
1        00000080 00008000          nop 5                       ; allow settling for possible spurious
1        00000084 00008000          nop 5                       ; interrupts (10 cycles, per TI)
1                           
1        00000088 00FCA35A          mvk 0xffffffff,b1           ; clear any bits in IFR using ICR
1        0000008c 018403A2          mvc b1,icr
1                           
1        00000090 009003E2          mvc ier,b1
1        00000094 008448F2          or 2,b1,b1
1        00000098 020403A2          mvc b1,ier                  ; set NMIE bit (required to enable ISRs)
1                           
1                                   .if GBL_SUPPORTCSL
1                                       .ref    _GBL_cslInit
1                           
1        0000009c 0000002A!             mvkl    _GBL_cslInit, b0
1        000000a0 0000006A!             mvkh    _GBL_cslInit, b0
1        000000a4 00000362              b       b0
1        000000a8 01805A2A+             mvkl    hwi_init_ret?, b3
1        000000ac 0180006A+             mvkh    hwi_init_ret?, b3
1        000000b0 00004000              nop 3
1                           
1                           hwi_init_ret?:
1                                       .if GBL_CALLCSLCFGINIT
1                                           .ref        _CSL_cfgInit
1                           
1        000000b4 0080002A!                 mvkl        _CSL_cfgInit, b1
1        000000b8 0080006A!                 mvkh        _CSL_cfgInit, b1
1        000000bc 00040362                  b b1
1        000000c0 0180662A+                 mvkl        hwi_cslcfg_init_ret?, b3
1        000000c4 0180006A+                 mvkh        hwi_cslcfg_init_ret?, b3
1        000000c8 00004000                  nop 3
1                                       .endif
1                           hwi_cslcfg_init_ret?:
1                           
1                                   .endif
1                           
1                                   ; 
1                                   ; L2 CACHE initialization
1                                   ;
1                                   
1                                   .if (GBL_L2CONFIGURE != 0)
1                                       .ref  _GBL_cslCacheInit
1                           
1                                       mvkl  _GBL_cslCacheInit, b0
1                                       mvkh  _GBL_cslCacheInit, b0
1                           
1                                       .if .TMS320C6400
1                                           mvkl GBL_L2MODE, a4
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  198

1                           ||              mvkl GBL_C641XL2PRIORITY, b4
1                                           mvkh GBL_L2MODE, a4
1                           ||              mvkh GBL_C641XL2PRIORITY, b4
1                                           mvkl GBL_L2MARMASK1, a6
1                           ||              mvkl GBL_L2MARMASK2, b6
1                                           mvkh GBL_L2MARMASK1, a6
1                           ||              mvkh GBL_L2MARMASK2, b6
1                                           mvkl GBL_L2MARMASK3, a8
1                           ||              mvkl GBL_L2MARMASK4, b8
1                                           b       b0
1                                           mvkh GBL_L2MARMASK3, a8
1                           ||              mvkh GBL_L2MARMASK4, b8
1                                           mvkl GBL_L2MARMASK5, a10
1                           ||              mvkl GBL_L2CONFIGALLOC, b10
1                                           mvkh GBL_L2MARMASK5, a10
1                           ||              mvkh GBL_L2CONFIGALLOC, b10
1                                           mvkl GBL_L2ALLOC, a12
1                           ||              mvkl  gbl_cslcacheinit_ret?, b3
1                                           mvkh GBL_L2ALLOC, a12
1                           ||              mvkh  gbl_cslcacheinit_ret?, b3
1                                       .else
1                                           b       b0
1                                           mvkl  GBL_L2MODE, a4
1                           ||              mvkl  GBL_L2MARMASK, b4
1                                           mvkh  GBL_L2MODE, a4
1                           ||              mvkh  GBL_L2MARMASK, b4
1                                           mvkl  gbl_cslcacheinit_ret?, b3
1                                           mvkh  gbl_cslcacheinit_ret?, b3
1                                           nop 2
1                                       .endif
1                           
1                                   
1                                   .endif  ; GBL_L2CONFIGURE
1                           
1        000000cc           gbl_cslcacheinit_ret?:
1                           
1                                   ;
1                                   ; CACHE initialization
1                                   ;
1                           
1        000000cc 000403E2          mvc     csr, b0                 ; get CSR
1                           
1        000000d0 0100A35A          mvk     GBL_CACHE, b2           ; get cache bits from configuration
1                           
1        000000d4 00807E2A          mvk     C62_CCFIELDS, b1
1        000000d8 008029B2          and     b1, b0, b1              ; extract pcc+dcc fields of csr
1        000000dc 00002BB2          xor     b1, b0, b0              ; clear pcc+dcc fields of csr
1        000000e0 000048B2          or      b2, b0, b0              ; change pcc and dcc fields
1                           
1        000000e4 008003A2          mvc     b0, csr                 ; save CSR with new cache state
1                           
1                                   ;
1                                   ;  Calling TRC_init from here until there is at trc.cdb file.
1                                   ;
1        000000e8                   TRC_init
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  199

2                                   ; TRC is always configured, so until we have a trc.cdb
2                                   ; file, don't check if module is configured.
2        000000e8 02000028+         mvkl TRC_cinit, a4
2        000000ec 02000068+         mvkh TRC_cinit, a4
2        000000f0 02100264          ldw *a4, a4
2        000000f4 01000228+         mvkl TRC_R_mask, a2
2        000000f8 01000068+         mvkh TRC_R_mask, a2
2        000000fc 00002000          nop 2
2        00000100 02080274          stw a4, *a2
2                           
1                           
1                                   ;
1                                   ;  fill memory using triples (nwords, addr, value) from 
1                                   ;  gblinit table.
1                                   ;
1        00000104 02000028+         mvkl    gblinit, a4
1        00000108 02000068+         mvkh    gblinit, a4
1                           
1        0000010c           loop0?:
1        0000010c 00103666          ldw     *a4++[1], b0            ; nwords
1        00000110 00103664          ldw     *a4++[1], a0            ; address
1        00000114 01103666          ldw     *a4++[1], b2            ; value
1        00000118 00004000          nop     3
1        0000011c 30000812   [!b0]  b       done?
1        00000120 00008000          nop     5
1                           
1        00000124           loop1?:
1        00000124 01003676          stw     b2, *a0++[1]
1        0000012c 000029C2          sub     b0, 1, b0
1        00000130 20000092   [b0]   b       loop1?
1        00000134 00008000          nop     5
1                           
1        00000138 0FFFFD92          b       loop0?
1        0000013c 00008000          nop     5
1        00000140           done?:
1        00000140 0104A359          mvk     1, a2
1        00000144 0100042A+  ||     mvkl    GBL_initdone, b2
1        00000148 0100006A+         mvkh    GBL_initdone, b2
1        0000014c 010802F4          stw     a2, *b2
1                           
    1098 00000150                   SEM_init
1                           
1                                   ; only expand if the SEM module is configured
1                                   .if (SEM$ = 1)
1                                   .endif
1                           
    1099 00000150                   MEM_init
1                           
1                                   ; only expand if dyanmic memory heaps on configured by the user
1                                   .if (MEM_gNumHeap > 0)
1                                           .global _MEM_init
1                           
1        00000150 02000028!                 mvkl    _MEM_init, a4
1        00000154 02000068!                 mvkh    _MEM_init, a4
1        00000158 00101362                  b       a4
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  200

1        0000015c 0180B42A+                 mvkl    meminit?, b3
1        00000160 0180006A+                 mvkh    meminit?, b3
1        00000164 00004000                  nop     3
1                           meminit?:
1                           
1                                   .endif              
1                           
    1100 00000168                   OBJ_init
    1101 00000168                   BUF_init
1                           
1                                   ; only expand if the BUF module is configured
1                                   .if (BUF$ = 1)
1                                      .ref __BUF_init
1                            
1        00000168 02000028!            mvkl   __BUF_init,a4
1        0000016c 02000068!            mvkh   __BUF_init,a4
1        00000170 00101362             b      a4
1        00000174 0180C02A+            mvkl   bufstart?, b3
1        00000178 0180006A+            mvkh   bufstart?, b3
1        0000017c 00004000             nop 3
1                           bufstart?:
1                           
1                                   .endif
1                           
    1102 00000180                   CLK_init
1                           
1                                   ; only expand if the CLK module is configured by the user and he/she/it
1                                   ; asks to use the timer
1                                   .if ((CLK$ = 1) & (CLK_USETIMER = 1))
1                                   .endif
1                           
    1103 00000180                   PRD_init
1                           
1                                   ; only expand if the PRD module is configured by the user 
1                                   .if (PRD$ = 1) 
1                                   .endif
1                           
    1104 00000180                   RTDX_init
    1105 00000180                   IDL_init
1                           
1                               ; only expand if the IDL module is configured by the user
1                               .if (IDL$ = 1)
1                                   .if (01H)         ; defined in IDL_config
1                           
1                                       .def BIOS$$CLKON, BIOS$$CLKOFF
1                           
1        00000180           BIOS$$CLKON:
1                                   ; BIOS$$CLKON signals to the C6x fast simulators to switch into 
1                                   ; cycle-accurate mode.
1                                   ; This is to make the calibration of the IDL loop accurate, so that
1                                   ; CPU load, which is based on this calibration, will also be accurate.
1                                   ; The bookend label to this is BIOS$$CLKOFF.
1                           
1                                   ; Perform calibration twice; first time fills cache (6211), and 
1                                   ; second time yields the accurate calibration value. 
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  201

1        00000180 0080006C!         ldw *+b14(IDL_D_calibrate),a1
1        00000184 0180CC2A+         mvkl idlinit1?,b3
1        00000188 0180006A+         mvkh idlinit1?,b3
1        0000018c 00002000          nop 2
1        00000190 00041362          b a1
1        00000194 00008000          nop 5
1        00000198           idlinit1?:
1        00000198 0080006C!         ldw *+b14(IDL_D_calibrate),a1
1        0000019c 0180D82A+         mvkl idlinit2?,b3
1        000001a0 0180006A+         mvkh idlinit2?,b3
1        000001a4 00002000          nop 2
1        000001a8 00041362          b a1
1        000001ac 00008000          nop 5
1                           
1        000001b0           BIOS$$CLKOFF:
1                                   ; BIOS$$CLKOFF signals to the C6x fast simulators to switch out of 
1                                   ; cycle-accurate mode. This is the bookend label to BIOS$$CLKON.
1                           
1                                   ; Reset the IDL_busyObj values, and clear the "prev" value so the
1                                   ; first pass through the real IDL loop won't produce a garbage
1                                   ; value. The STS_reset API is not being used because the prev
1                                   ; value is not cleared in STS_reset, so doing it this way uses
1                                   ; less than half as many instructions as using the APIs. dsg-2/9/01
1        000001b0           idlinit2?:
1        000001b0 0200006C!         ldw *+b14(IDL_D_busyObj),a4  ; load IDL_busyObj address to a4
1        000001b4 0080A358          zero a1
1        000001b8 00004000          nop 3
1        000001bc 00902074          stw a1,*-a4(4)      ; clear prev
1        000001c0 00900274              stw a1,*+a4(0)              ; clear num
1        000001c4 00902274              stw a1,*+a4(4)              ; clear acc
1        000001c8 00C00068              mvklh 8000h, a1             ; form largest negative number
1        000001cc 00904274              stw a1,*+a4(8)              ; set max
1                                   .endif
1                               .endif
1                           
    1106 000001d0                   LCK_init
1                           
1                                   ; only expand if the LCK module is configured
1                                   .if (LCK$ = 1)
1                                   .endif
1                           
    1107 000001d0                   LOG_init
1                                   ; only expand if the LOG module is configured by the user
1                                   .if (LOG$ = 1)
1                                   .endif
1                           
    1108 000001d0                   MBX_init
1                           
1                                   ; only expand if the MBX module is configured
1                                   .if (MBX$ = 1)
1                                   .endif
1                           
    1109 000001d0                   PIP_init
    1110 000001d0                   QUE_init
    1111 000001d0                   STS_init
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  202

1                           
1                                   ; only expand if the STS module is configured
1                                   .if (STS$ = 1)
1                                   .endif
1                           
    1112 000001d0                   SYS_init
1                           
1                                   ; only expand if the SYS module is configured
1                                   .if (SYS$ = 1)
1                                   .endif
1                           
    1113 000001d0                   HWI_init
    1114 000001d0                   HST_init
1                                   ; only expand if the HST module is configured by the user
1                                   .if(HST$ != 0)
1        000001d0                       LNK_init    ; do any required LNK initialization
2                                   ;
2                                   ; no need to call LNK_F_init when it's an empty function
2                                   ;
1                                   .endif
    1115 000001d0                   DEV_init
1                                   .if DEV$NUMDEVICES != 0
1                           
1                                       .global     _DEV_init
1                           
1        000001d0 02000028!             mvkl        _DEV_init, a4
1        000001d4 02000068!             mvkh        _DEV_init, a4
1        000001d8 00101362              b           a4
1        000001dc 0180F42A+             mvkl        devinit?, b3
1        000001e0 0180006A+             mvkh        devinit?, b3
1        000001e4 00004000              nop 3
1                           devinit?:
1                           
1                                   .endif
1                           
    1116 000001e8                   UDEV_init
    1117 000001e8                   DGN_init
    1118 000001e8                   DHL_init
    1119 000001e8                   DPI_init
    1120 000001e8                   SIO_init
1                           
1                                   .if SIO$NUMOF != 0
1                           
1                                       .global     _SIO_init
1                           
1                                       mvkl        _SIO_init, a4
1                                       mvkh        _SIO_init, a4
1                                       b           a4
1                                       mvkl        siostart?, b3
1                                       mvkh        siostart?, b3
1                                       nop 3
1                           siostart?:
1                           
1                                   .endif
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  203

    1121 000001e8                   SWI_init
1                                   ; only expand if the SWI module is configured by the user
1                                   .if (SWI$ = 1)
1                                   .endif
1                           
    1122 000001e8                   HOOK_init
1                           
1                                   ; only expand if the HOOK module is configured
1                                   .if (HOOK$ = 1)
1                           
1                                   .ref    __HOOK_doInit
1                           
1                                   mvkl    __HOOK_doInit, a0
1                                   mvkh    __HOOK_doInit, a0
1                                   b       a0
1                                   mvkl    init_ret, b3
1                                   mvkh    init_ret, b3
1                                   nop     3
1                           init_ret:
1                           
1                                   .endif
1                           
    1123 000001e8                   TSK_init
1                           
1                                   ; only expand if the TSK module is configured
1                                   .if (TSK$ = 1)
1                           
1                                       .global _TSK_init
1                                       .global _TSK_setup
1                           
1        000001e8 02000028!             mvkl        _TSK_init, a4
1        000001ec 02000068!             mvkh        _TSK_init, a4
1        000001f0 00101362              b           a4
1        000001f4 0181002A+             mvkl        tskinit?, b3
1        000001f8 0180006A+             mvkh        tskinit?, b3
1        000001fc 00004000              nop         3
1                           
1                           tskinit?:
1                                       .if TSK$NUMOF != 0
1                           
1        00000200 02000028!                 mvkl    _TSK_setup, a4
1        00000204 02000068!                 mvkh    _TSK_setup, a4
1        00000208 00101362                  b       a4
1        0000020c 01810C2A+                 mvkl    tskstup?, b3      ; return address
1        00000210 0180006A+                 mvkh    tskstup?, b3
1        00000214 00004000                  nop     3
1                                       .else
1                                           .emsg "There must be at least one task defined under TSK."
1                                       .endif
1                           
1                           tskstup?:
1                           
1                                   .endif
1                           
    1124 00000218                   ISRC_init
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  204

    1125 00000218                   GIO_init
1                           
1                                   ; only expand if the GIO module is configured
1                                   .if (GIO$ = 1)
1                                   .endif
1                           
    1126 00000218                   DIO_init
    1127 00000218                   GBL_postamble
1        00000218 01BC52E6          ldw     *++b15[2], b3
1        0000021c 00006000          nop     4
1        00000220 000C0362          b       b3
1        00000224 00008000          nop     5
1                           
    1128                    
    1129                    ;; MODULE STARTUP
    1130 00000228                   .sect ".sysinit"
    1131                            .global BIOS_start, _BIOS_start
    1132 00000228           BIOS_start:
    1133 00000228           _BIOS_start:
    1134 00000228                   GBL_preamble
1        00000228 01BC54F6          stw     b3, *b15--[2]
1                           
    1135 0000022c                   GBL_startup
    1136 0000022c                   SEM_startup
1                           
1                                   .if     SEM$NUMOF != 0
1                                   .endif
    1137 0000022c                   MEM_startup
    1138 0000022c                   OBJ_startup
    1139 0000022c                   BUF_startup
1                           
1                                   .if     BUF$NUMOF != 0
1                                   .endif
    1140 0000022c                   CLK_startup
1                           
1                                   ; only expand if the CLK module is configured by the user and he/she
1                                   ; asks to use the timer
1                                   .if ((CLK$ = 1) & (CLK_USETIMER = 1))
1                                   
1                                   .if GBL_SUPPORTCSL
1                           
1                                       ;
1                                       ; Force a reference to the appropriate CLK_startXXX function.
1                                       ; CLK_start will be aliased to this function in the cfg.cmd file.
1                                       ;
1                                       ; A forced reference is necessary because no module directly
1                                       ; references this function, and the aliasing performed in the
1                                       ; linker command file cfg.cmd needs the symbol to be well
1                                       ; defined at the time of the alias, which is after the libraries
1                                       ; have already been scanned.  The following reference alone will
1                                       ; cause the function to be linked in from the BIOS library,
1                                       ; allowing the subsequent alias to be satisfied.
1                                       ;
1                                       .ref        _CLK_start6x            ; only one version now
1                                       .ref        _CLK_start
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  205

1                                   
1        0000022c 00000028!             mvkl        _CLK_start, a0
1        00000230 00000068!             mvkh        _CLK_start, a0
1        00000234 00001362              b   a0
1        00000238 0181222A+             mvkl        clk_startup_ret?, b3
1        0000023c 0180006A+             mvkh        clk_startup_ret?, b3
1        00000240 00004000              nop 3
1                           clk_startup_ret?:
1                           
1                                   .else
1                           
1                                       mvkl CLK_REGS,a0            ; get address to Timer Control register
1                                ||     mvkl CLK_CLKSRC,b2
1                                       mvkh CLK_REGS,a0
1                                ||     mvkh CLK_CLKSRC,b2
1                                       stw b2,*a0              ; write /HLD=0 and CLKSRC=1 to Timer Control
1                           
1                                       ; set the period
1                                       mvkl CLK_PRD, a1
1                                       mvkh CLK_PRD, a1
1                                       stw a1, *+a0[1]
1                           
1                                       ; start timer
1                                       ldw *a0, a1
1                                       mvk CLK_START,b1    ; get start mask
1                                       nop 3
1                                       or b1,a1,a1         ; set GO=1 and /HLD=1
1                                       stw a1,*a0          ; write to Timer Control to start timer
1                           
1                                       ; enable Timer interrupt in IER
1                                       mvkl CLK_INTBIT,a0
1                                       mvkh CLK_INTBIT,a0
1                                       mvc ier,b1
1                                       or a0,b1,b1         ; set CLK_INTBIT
1                                       mvc b1,ier
1                           
1                                   .endif
1                           
1                                   .endif
1                           
    1141 00000244                   PRD_startup
    1142 00000244                   RTDX_startup
    1143 00000244                   IDL_startup
    1144 00000244                   LCK_startup
1                           
1                                   .if     LCK$NUMOF != 0
1                                   .endif
    1145 00000244                   LOG_startup
    1146 00000244                   MBX_startup
1                           
1                                   .if     MBX$NUMOF != 0
1                                   .endif
    1147 00000244                   PIP_startup
1        00000244                   CHK_void PIP_startup, dummy
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  206

1                                   ; expand startup code only if some PIP objects are configured
1                                   .if((PIP$ + PIP_gNumEmbed) !=0 )
1        00000244 0200002A!             mvkl PIP_F_start,b4         ; set up for far branch
1        00000248 0200006A!             mvkh PIP_F_start,b4
1        0000024c 00100362              b b4                        ; start branch to startup function
1        00000250 02000028!             mvkl PIP_D_tabbeg,a4        ; set a4 for PIP_F_start call
1        00000254 02000068!             mvkh PIP_D_tabbeg,a4
1        00000258 00000000              nop
1        0000025c 0181322A+             mvkl pips?,b3               ; set return for here
1        00000260 0180006A+             mvkh pips?,b3
1                                   .endif
1                           
1                           pips?:  
1                           
    1148 00000264                   QUE_startup
    1149 00000264                   STS_startup
    1150 00000264                   SYS_startup
    1151 00000264                   HWI_startup
1                           
1                                   ; globally enable interrupts
1        00000264                   HWI_enable
2        00000264 00000312          b hwie?
2        00000268 000403E2          mvc csr,b0
2        0000026c 000028F2          or GIE,b0,b0
2        00000270 008003A2          mvc b0,csr      
2        00000274 00002000          nop 2
2                           hwie?:
1                           
    1152 00000278                   HST_startup
    1153 00000278                   DEV_startup
    1154 00000278                   UDEV_startup
    1155 00000278                   DGN_startup
1                                   .if     DGN$NUMOF != 0
1                           
1                                   ;
1                                   ; DGN_init is #defined as SYS_nop in dgn.h,
1                                   ; so we won't do anything here.
1                                   ;
1                                   ;.global _DGN_init
1                                   ; call   _DGN_init
1                           
1                                   .endif
    1156 00000278                   DHL_startup
1                                   .if     DHL$NUMOF != 0
1                           
1                                   .endif
    1157 00000278                   DPI_startup
1                                   .if     DPI$NUMOF != 0
1                                   .endif
    1158 00000278                   SIO_startup
    1159 00000278                   SWI_startup
1        00000278                   CHK_void SWI_startup, dummy
1                           
1                                   ; only expand if the SWI module is configured by the user
1                                   .if (SWI$ = 1)
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  207

1        00000278 02000028!             mvkl SWI_F_enable,a4                ; prepare for far branch
1        0000027c 02000068!             mvkh SWI_F_enable,a4
1        00000280 00101362              b a4                        ; start branch to SWI_F_enable  
1        00000284 0181482A+             mvkl swii?,b3               ; setup b3 pointer to come back here
1        00000288 0180006A+             mvkh swii?,b3
1        0000028c 00004000              nop 3
1                           swii?:
1                                   .endif  
    1160 00000290                   HOOK_startup
1                           
1                                   ; only expand if the HOOK module is configured
1                                   .if (HOOK$ = 1)
1                           
1                                   .endif
1                           
    1161 00000290                   TSK_startup
1                           
1                                   ; only expand if the TSK module is configured
1                                   .if (TSK$ = 1)
1                           
1                                       .global _TSK_startup
1                           
1                                       .if TSK$NUMOF != 0
1                           
1        00000290 02000028!                 mvkl _TSK_startup, a4
1        00000294 02000068!                 mvkh _TSK_startup, a4
1        00000298 00101362                  b    a4
1        0000029c 0181542A+                 mvkl tskstup?, b3      ; return address
1        000002a0 0180006A+                 mvkh tskstup?, b3
1        000002a4 00004000                  nop  3
1                           
1                                       .endif
1                           
1                           tskstup?:
1                                   .endif
    1162 000002a8                   ISRC_startup
    1163 000002a8                   GIO_startup
    1164 000002a8                   DIO_startup
    1165 000002a8                   GBL_postamble
1        000002a8 01BC52E6          ldw     *++b15[2], b3
1        000002ac 00006000          nop     4
1        000002b0 000C0362          b       b3
1        000002b4 00008000          nop     5
1                           
    1166                    
    1167                    ;; EPILOGUE
    1168 000002b8                   GBL_end
1                           
1        00000048                   .sect ".gblinit"
1        00000048 00000000          .word 0                 ; end of gblinit table marker
1                           
    1169 0000004c                   MEM_end
    1170 0000004c                   OBJ_end
1                           
1                                   ;
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  208

1                                   ;  We only need the OBJ_table if any of the objects in the modules
1                                   ;  below are created in the configuration, or if they can be created
1                                   ;  dynamically (requires heaps).
1                                   ;
1                                   .if (MEM_gNumHeap > 0) | MBX$ | SEM$ | SIO$ | TSK$ | DEV$NUMDEVICES | BUF$
1                           
1                                    .global _OBJ_table
1        00000030                   .bss    _OBJ_table, OBJ_MODULES * STD_TARGWORDMAUS * 2, STD_TARGWORDMAUS
1                           
1        000008c8                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        000008c8 00000038          .word   OBJ_MODULES * STD_TARGWORDMAUS * 2
1        000008cc 00000030-         .word   _OBJ_table
1        000008d0 00000030-         .word   _OBJ_table + 0 * STD_TARGWORDMAUS, _OBJ_table + 0 * STD_TARGWORDMAUS
         000008d4 00000030-
1        000008d8 00000038-         .word   _OBJ_table + 2 * STD_TARGWORDMAUS, _OBJ_table + 2 * STD_TARGWORDMAUS
         000008dc 00000038-
1        000008e0 00000000-         .word   TSK_idle$obj, TSK_algorithm$obj
         000008e4 000000C0-
1        000008e8 00000048-         .word   _OBJ_table + 6 * STD_TARGWORDMAUS, _OBJ_table + 6 * STD_TARGWORDMAUS
         000008ec 00000048-
1        000008f0 00000050-         .word   _OBJ_table + 8 * STD_TARGWORDMAUS, _OBJ_table + 8 * STD_TARGWORDMAUS
         000008f4 00000050-
1        000008f8 00000000-         .word   UDEV_VP0CAPTURE$obj, UDEV_VP2DISPLAY$obj
         000008fc 00000048-
1        00000900 00000000-         .word   BUF_imgPool$obj, BUF_capFrame$obj
         00000904 00000078-
1                           
1                                   .endif
1                           
    1171 00000908                   BUF_end
    1172 00000908                   CLK_end
1                                   .if (CLK$NUMOF != 0)
1        00000908                       CLK_Obj     1,CLK_null,-1,0 ; NULL terminate clock isr fxn table
2        00000908                   CHK_nargs "CLK_Obj", fxn
2                                   .if ($symcmp("", "error") = 0)
2                                       .emsg "CLK_OBJ parameter error."
2                                   .endif
2                           
2                                   .var fxnlen
2                                   .eval $symlen("0"),fxnlen
2                           
2                                   .if (1 = 0)
2                                       .mexit
2                                   .endif
2                           
2                                   .global CLK_null
2                           
2                                   .if ($symcmp("0", "0") != 0)
2                                   .global fxn
2                                   .endif
2                           
2                           CLK_null  .tag    CLK_Obj         ; declare name as having type CLK_Obj
2                           
2                           ; allocate all CLK objs contiguously in ".clk"
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  209

2        00000004           CLK_null        .usect ".clk", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        00000908                   .sect ".cinit"
2                           
2                                   .align  8
2                           
2        00000908 00000004          .field  STD_TARGWORDMAUS * 1
2                           
2        0000090c 00000004-         .field  CLK_null    
2                           
2        00000910 00000000          .field  0           ; fxn
2                           
1                                   .endif
1                           
    1173 00000914                   PRD_end
1                 00000000  PRD_SWIHANDLE .set 0
    1174 00000914                   RTDX_end
    1175 00000914                   HST_end
    1176 00000914                   HWI_end
    1177 00000914                   SWI_end
    1178 00000914                   TSK_end
1                           
1                                   ; expand only if TSK is enabled.
1                                   .if (TSK$ == 1)
1                           
1                           ;
1                           ; The following two .bss/.cinit sets make configured values readable
1                           ; in the established SPOX manner, e.g., TSK->STACKSIZE.
1                           ;
1                           ;
1                           
1        00000068                   .bss    TSK_config,8 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000914                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000918 00000020          .word 8 * STD_TARGWORDMAUS
1        0000091c 00000068-         .word TSK_config
1        00000920 00000000          .word SDRAM$idx
1        00000924 00000001          .word TSK_PRIORITY
1        00000928 00005000          .word TSK_STACKSIZE     ; This shall be interpreted as number of MAU's
1        0000092c 00000000!         .word TSK_VCREATEFXN
1        00000930 00000000!         .word TSK_VDELETEFXN
1        00000934 00000000!         .word TSK_VEXITFXN
1        00000938 00000000          .word TSK_SWITCHFXN
1        0000093c 00000000          .word TSK_READYFXN
1                           
1                                   .def _TSK                       ; Pointer to configuration parameters
1        00000088                   .bss        _TSK, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        00000940                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000940 00000004          .word   1 * STD_TARGWORDMAUS
1        00000944 00000088-         .word   _TSK
1        00000948 00000068-         .word   TSK_config
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  210

1                                   ;
1                                   ; The startup stack will be borrowed from the idle task's stack.  The
1                                   ; startup stack must begin beyond the portion of the stack that is
1                                   ; statically initialized, so the __STACK_SIZE will be decremented by
1                                   ; that amount.
1                                   ;
1                           ;       .def    __stack, __STACK_SIZE
1                           
1                           ;__stack                .set    TSK_idle$stack
1                           ;__STACK_SIZE   .set    TSK_idle$stklen - (TSK_USEDSTACK * STD_TARGWORDMAUS)
1                           
1                                   .endif          ; if (TSK$ == 1)
1                           
    1179 0000094c                   IDL_end
1        0000094c               IDL_Obj 1,IDL_END,-1,0,1     ; NULL terminate idle function table
2        0000094c                   CHK_nargs "IDL_Obj", calibration
2                                   .if ($symcmp("", "error") = 0)
2                                       .mexit
2                                   .endif
2                           
2                               .var fxnlen
2                               .eval $symlen("0"),fxnlen
2                           
2                                   .if (1 = 0)   ; if this object is not really to be allocated
2                                       .mexit      ; exit quietly now
2                                   .endif
2                           
2                                   .global IDL_END$
2                                   .global IDL_END
2                           
2                                   .if ($symcmp("0", "0") != 0)
2                               .global :fxn:
2                                   .endif
2                           
2                           IDL_END$ .tag    IDL_Obj         ; declare name$ as having type IDL_Obj
2                           
2        0000000c           IDL_END$ .usect ".idlcal", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000094c                   .sect ".cinit"
2                           
2                               .align  8
2        00000950 00000004      .field  STD_TARGWORDMAUS * 1
2        00000954 0000000C-     .field  IDL_END$    
2                                   .if (1 != 0) ; if to be included in IDL calibration
2        00000958 00000000              .field  0             ; fxn
2                               .else
2                                       .field  FXN_F_nop    ; else use FXN_F_nop
2                                   .endif
2                           
2                           IDL_END  .tag    IDL_Obj         ; declare name as having type IDL_Obj
2                           
2        0000000c           IDL_END  .usect ".idl", STD_TARGWORDMAUS * 1, STD_TARGWORDMAUS
2                           
2        0000095c                   .sect ".cinit"
2                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  211

2                               .align  8
2        00000960 00000004      .field  STD_TARGWORDMAUS * 1
2        00000964 0000000C-     .field  IDL_END    
2        00000968 00000000      .field  0           ; fxn
2                           
1                           
    1180 0000096c                   ISRC_end
    1181 0000096c                   LOG_end
    1182 0000096c                   PIP_end
    1183 0000096c                   SEM_end
    1184 0000096c                   MBX_end
    1185 0000096c                   QUE_end
    1186 0000096c                   LCK_end
    1187 0000096c                   SIO_end
    1188 0000096c                   STS_end
    1189 0000096c                   SYS_end
    1190 0000096c                   GIO_end
    1191 0000096c                   DEV_end
1                           
1                           ;
1                           ;  We reserve uninitialized space for the initialization table
1                           ;  (_DEV_devinit). This is a table that contains pointers to all the
1                           ;  initialization routines for all the devices.
1                           ;
1                           
1                                   .if (DEV$NUMDEVICES > 0)        ; expand only if devices are configured.
1                           
1                                   .global _DEV_devinit
1                                   .global _DEV_D_devinit          ; init pointer to _DEV_devinit
1                           
1        0000008c                   .bss    _DEV_devinit, 0 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        0000008c                   .bss    _DEV_D_devinit, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000096c                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000970 00000004          .word   1 * STD_TARGWORDMAUS
1        00000974 0000008C-         .word   _DEV_D_devinit
1        00000978 0000008C-         .word   _DEV_devinit
1                           
1                           ;
1                           ; __DEV_NUMINITFXNS keeps track of the number of initialization routines for
1                           ; device drivers that need to be called at initialization.
1                           ;
1                                   .global __DEV_NUMINITFXNS
1                                   .global __DEV_D_NUMINITFXNS     ; init pointer to DEV_NUMINITFXNS
1                           
1        00000090                   .bss    __DEV_NUMINITFXNS, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1        00000094                   .bss    __DEV_D_NUMINITFXNS, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000097c                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        00000980 00000004          .word   1 * STD_TARGWORDMAUS
1        00000984 00000090-         .word   __DEV_NUMINITFXNS
1        00000988 00000000          .word   0
1                           
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  212

1                                   .align  STD_TARGALIGN
1        00000990 00000004          .word   1 * STD_TARGWORDMAUS
1        00000994 00000094-         .word   __DEV_D_NUMINITFXNS
1        00000998 00000090-         .word   __DEV_NUMINITFXNS
1                           
1                                   .endif          ; .if (DEV$NUMDEVICES > 0)
1                           
    1192 0000099c                   UDEV_end
    1193 0000099c                   DGN_end
    1194 0000099c                   DHL_end
1                           
1                                   ; expand only if there are DHL devices configured.
1                                   .if (0 > 0)
1                           
1                                       .global  __DHL_tab
1                                       .bss  __DHL_tab, DHL$count * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                       .global  __DHL_numof
1                                       .bss  __DHL_numof, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                       .sect       ".cinit"
1                                       .align      STD_TARGALIGN
1                                       .word       1 * STD_TARGWORDMAUS
1                                       .word       __DHL_numof
1                                       .word       DHL$count
1                           
1                                   .endif
1                           
    1195 0000099c                   DPI_end
    1196 0000099c                   HOOK_end
1                           
1                                   ; expand only if HOOK is enabled.
1                                   .if (HOOK$ == 1)
1                           
1                                   .bss    __HOOK_initFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_createFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_deleteFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_exitFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_readyFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                                   .bss    __HOOK_switchFxnTable, HOOK$index * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1                                   .endif
1                           
1                                   ;
1                                   ; always define _HOOK_NUMHOOKS
1                                   ;
1                                   .def    __HOOK_NUMHOOKS
1                           
1        00000098                   .bss    __HOOK_NUMHOOKS, 1 * STD_TARGWORDMAUS, STD_TARGWORDMAUS
1                           
1        0000099c                   .sect   ".cinit"
1                                   .align  STD_TARGALIGN
1        000009a0 00000004          .word   1 * STD_TARGWORDMAUS
1        000009a4 00000098-         .word   __HOOK_NUMHOOKS
1        000009a8 00000000          .word   0
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  213

1                           
    1197 000009ac                   DIO_end
    1198                    
    1199                            .copy confend.s62
 +     1                    ;
 +     2                    ;  Copyright 2003 by Texas Instruments Incorporated.
 +     3                    ;  All rights reserved. Property of Texas Instruments Incorporated.
 +     4                    ;  Restricted rights to use, duplicate or disclose this code are
 +     5                    ;  granted through contract.
 +     6                    ;  
 +     7                    ;
 +     8                    ; "@(#) DSP/BIOS 4.90.270 01-13-05 (barracuda-o07)"
 +     9                    ;
 +    10                    ;  ======== confend.s62 ========
 +    11                    ;  The statements in this file are inserted at the end of 
 +    12                    ;  every BIOS configuration file.
 +    13                    ;
 +    14                            .include vers.h62
 +    15                    
 +    16 000009ac                   VERS_create VERS$DATE, VERS$CDB, VERS$TREE, VERS$CDBRELATIVEPATH
1+       000009ac                   CHK_nargs "VERS_create", tree
1+                                  .if ($symcmp("", "error") = 0)
1+                                      .mexit
1+                                  .endif
1+                          
1+       00000000                   .sect ".vers"
1+       00000000 00000046          .byte "Fri Jan 07 14:25:10 2011"
         00000001 00000072 
         00000002 00000069 
         00000003 00000020 
         00000004 0000004A 
         00000005 00000061 
         00000006 0000006E 
         00000007 00000020 
         00000008 00000030 
         00000009 00000037 
         0000000a 00000020 
         0000000b 00000031 
         0000000c 00000034 
         0000000d 0000003A 
         0000000e 00000032 
         0000000f 00000035 
         00000010 0000003A 
         00000011 00000031 
         00000012 00000030 
         00000013 00000020 
         00000014 00000032 
         00000015 00000030 
         00000016 00000031 
         00000017 00000031 
1+       00000018 00000000          .byte 0
1+       00000019 00000066          .byte "framework.cdb"
         0000001a 00000072 
         0000001b 00000061 
         0000001c 0000006D 
TMS320C6x COFF Assembler PC v5.1.0 Fri Mar 25 16:49:50 2011

Tools Copyright (c) 1996-2005 Texas Instruments Incorporated
frameworkcfg.s62                                                     PAGE  214

         0000001d 00000065 
         0000001e 00000077 
         0000001f 0000006F 
         00000020 00000072 
         00000021 0000006B 
         00000022 0000002E 
         00000023 00000063 
         00000024 00000064 
         00000025 00000062 
1+       00000026 00000000          .byte 0
1+       00000027 00000040          .byte "@(#)*** xdc-c38"
         00000028 00000028 
         00000029 00000023 
         0000002a 00000029 
         0000002b 0000002A 
         0000002c 0000002A 
         0000002d 0000002A 
         0000002e 00000020 
         0000002f 00000078 
         00000030 00000064 
         00000031 00000063 
         00000032 0000002D 
         00000033 00000063 
         00000034 00000033 
         00000035 00000038 
1+       00000036 00000000          .byte 0
1+       00000037 0000003B          .byte ";;;;"
         00000038 0000003B 
         00000039 0000003B 
         0000003a 0000003B 
1+       0000003b 00000000          .byte 0
1+       00000000                   .text
 +    17                    
 +    18 00000000                   .text
 +    19                    

No Assembly Errors, No Assembly Warnings
